{
  "openapi": "3.0.0",
  "servers": [
    {
      "url": "/api/v1"
    }
  ],
  "info": {
    "description": "\nCopyright © 2017-2021 Rubrik Inc. [Legal](#section/Legal)\n\n# Introduction\n\nWelcome to the Rubrik™ REST API documentation.\n\nThe Rubrik REST API provides a RESTful interface for working with Rubrik clusters and Rubrik Edge virtual appliances. The Rubrik REST API can be used to query, configure, and control nearly all of the operations of the Rubrik software.\n\nThrough authenticated and encrypted interaction with the Rubrik REST API server, perform any of the operations that are available through the Rubrik web UI and many bulk-type operations that might otherwise be difficult or impossible to perform.\n\nThis documentation provides reference information and examples of typical workflows for the Rubrik REST API. For more detailed information about working with Rubrik clusters and Rubrik Edge virtual appliances refer to the *Rubrik User Guide*.\n\nA quick way to become familiar with the Rubrik REST API, is to use the Rubrik REST API Explorer. [OpenAPI](#section/OpenAPI) describes this tool.\n\nRefer to the [changelog](#section/Changelog) to see information about changes within this version of the Rubrik REST API.\n\n# Changelog\n\n Revisions are listed with the most recent revision first.\n\n ### Changes to V1 API in Rubrik Version 6.0.0\n ## Feature additions/improvements:\n * Added optional fields: id(type: string) and networkType(type:\n   VmwareNetworkType Enum) to VmwareNetworkInfo, which is used by:\n   `Get /vmware/vm/{id}/snapshot`\n   `Get /vmware/config/recovery/networks`\n * Added new optional field `maxLocalRetentionLimit` to\n   `CloudOutForecastSlaParameters`.\n * Added following new endpoints for health monitor:\n   `POST /health_monitor/run_policy`\n   `GET /health_monitor/policies`\n   `GET /health_monitor/policy_status`\n * Added new endpoints `POST /sap_hana/db/{id}/configure_restore` and\n   `/sap_hana/db/{id}/unconfigure_restore` to configure and unconfigure\n   system copy restore on the target SAP HANA database.\n * Added new endpoint `POST /sla_domain/assign_to_downloaded_snapshots` to\n   assign retention SLA only to snapshots at downloaded locations.\n * Copied the following endpoints from the internal Rubrik REST API listing\n   to the v1 listing:\n   `GET /oracle/db`\n   `GET /oracle/db/{id}`\n   `PATCH /oracle/db/{id}`\n   Added a new optional parameter `is_data_guard_group` to `GET /oracle/db`.\n * Added new optional fields `advancedRecoveryConfigMap`, `preScriptPath`,\n   `postScriptPath`, and `shouldStopRecoveryOnPreScriptFailure` to\n   `ExportOracleDbConfig` and `MountOracleDbConfig` which specify the\n   Advanced Cloning Options (ACO) map, pre script path, post script path,\n   and whether to stop the recovery on pre-script failure, respectively.\n * Added new endpoint `POST /oracle/validate_aco_file` to validate the given\n   Advanced Cloning Options (ACO) file and retrieve the validation results.\n * Added new endpoint `GET /oracle/aco_parameter_list` to fetch the list of\n   supported Advanced Cloning Options (ACO) parameter names.\n * Added new endpoint `PATCH /oracle/data_guard_group/{id}` to update the SLA\n   and user settings for a Data Guard group.\n * Added new endpoints to get and change hostnames of nodes in a Rubrik cluster.\n   'GET /cluster/{id}/node_hostname',\n   'POST /cluster/{id}/node_hostname'.\n * Added a new object `NodeHostnameInfo` used by\n   `GET /cluster/{id}/node_hostname` and `POST /cluster/{id}/node_hostname`.\n * Added new endpoint to get Rubrik Backup Service details for a host.\n   `GET /host/rbs`\n * Added new endpoint to install Rubrik Backup Service on a host.\n   `POST /host/rbs/install`\n * Added new endpoint to uninstall Rubrik Backup Service from a host.\n   `POST /host/rbs/uninstall`\n * Added new endpoint to upgrade Rubrik Backup Service on a host.\n   `POST /host/rbs/upgrade`\n * Added new endpoints for user-defined tags management\n   `GET /user_defined_tag`\n   `POST /user_defined_tag`\n   `DELETE /user_defined_tag`\n   `GET /user_defined_tag/{id}`\n   `PATCH /user_defined_tag/{id}`\n   `DELETE /user_defined_tag/{id}`\n * Added new optional field 'numChannels' to 'OracleValidateConfig' object.\n   This field specifies the number of channels used when validating Oracle\n   backups.\n * Added new endpoint for batch VM snpshots query.\n   `POST /vmware/vm/snapshots`\n * Added new endpoints for SQL Server host configuration.\n   `GET /mssql/host/configuration`,\n   `POST /mssql/host/configuration`,\n   `GET /mssql/host/configuration/{host_id}`,\n   `PATCH /mssql/host/configuration/{host_id}`,\n   `DELETE /mssql/host/configuration/{host_id}`\n * Added new optional field `dataRetrievalCostInUSD` to\n   `CloudOutStorageForecastSummary`.\n * Added `POST /cloud_utilization/cloud_out_forecast` endpoint to forecast cloud\n   utilization for archival use case.\n * Changed `lastUpdatedTime` to be required in\n * Changed `retryStatus` to be required in\n   `JobMonitoringInfo` which is used in endpoints `GET /job_monitoring`\n   and `GET /polaris/job_monitoring`.\n * Changed `lastUpdatedTime` to be required in\n   `JobMonitoringInfo` which is used in endpoints `GET /job_monitoring`\n   and `GET /polaris/job_monitoring`.\n * Added a new endpoint to bulk tier existing snapshots\n   `POST /unmanaged_object/snapshot/bulk_archive_tier`\n * Added new field `snapshotVerificationInfo` to\n   `VerificationResponse` to include event information\n   about snapshots.\n * Added new optional fields `errorInfo` and\n   `retryStatus` to `JobMonitoringInfo` to include backup\n   failure remediation status.\n * Added new optional fields `snapMirrorLabelForFullBackup` and\n   `snapMirrorLabelForIncrementalBackup` to `FilesetSummary`, `FilesetUpdate`\n   and `FilesetCreate` to support SnapMirror destination volume\n   backup.\n   `FilesetSummary` is used by endpoints:\n    `GET /v1/fileset`,\n    `GET /v1/fileset/{id}`.\n   `FilesetUpdate` is used by endpoints:\n    `PATCH /v1/fileset/{id}`.\n   `FilesetCreate` is used by endpoints:\n    `POST /internal/fileset/bulk`,\n    `POST /v1/fileset`.\n * Added new values of `IoFilterStatus` and `HostUiFilterStatus`\n   to help distinguish cluster and ESXi host states when there is\n   a mismatch between the installed IO filter and ESXi host versions,\n   instead of defaulting to Unsupported.\n * Added new endpoints `GET /cluster/{id}/security/totp/setting` and\n   `PUT /cluster/{id}/security/totp/setting` for retreiving and\n   updating the 2-Step Verification global setting, respectively.\n * Added new optional field `computeVisibilityFilter` to\n   `GET /vmware/vcenter/{id}`, `POST /vmware/vcenter` and `PUT /vmware/vcenter`\n    to specify compute resource visibility.\n ## New features:\n * Added new endpoint for querying LDAP domain names.\n   `GET /ldap_service/domain_name`\n * Added new endpoints for supporting truststores\n   `GET /v1/cluster/{id}/security/truststore`\n   `DELETE /v1/cluster/{id}/security/truststore`\n   `PATCH /v1/cluster/{id}/security/truststore`\n * Added new field `isOnSnapMirrorDestVolume` to HostHierarchyObjectSummary\n   returned by `GET /host/hierarchy/{id}/children`.\n * Added new endpoint, `GET /volume_group/{id}/request/force_full_snapshot`.\n   This endpoint retrieves the configuration used to force a full snapshot\n   of a Volume Group.\n * Added new endpoint, `POST /volume_group/{id}/request/force_full_snapshot`.\n   This endpoint requests to force a full snapshot of a Volume Group.\n * Added new endpoint, `POST /archive/location/{id}/owner/disable` to disable\n   archival location.\n * Added new endpoint, `POST /archive/location/{id}/owner/enable` to enable\n   archival location.\n * Added new optional field `dataPathSpec` to `SapHanaSystemConfig` include\n   details of SAP HANA system data path\n * Copied the following endpoints from the internal Rubrik REST API listing\n  to the v1 listings:\n     * `GET /vcd/hierarchy/{id}` to get summary of a vCD hierarchy object.\n     * `GET /vcd/hierarchy/{id}/children` to get immediate descendant objects.\n     * `GET /vcd/hierarchy/{id}/descendants` to get list of descendant objects.\n     * `GET /vcd/cluster` to get summary for all vCD Clusters.\n     * `POST /vcd/cluster` to add a vCD Cluster.\n     * `GET /vcd/cluster/{id}/vimserver` to get VimServers of a vCD Cluster.\n     * `POST /vcd/cluster/{id}/refresh` to refresh a vCD Cluster.\n     * `GET /vcd/cluster/{id}` to get vCD Cluster details.\n     * `PATCH /vcd/cluster/{id}` to modify the hostname and credentials of a\n      specified vCD Cluster object.\n     * `DELETE /vcd/cluster/{id}` to remove vCD Cluster.\n     * `GET /vcd/cluster/request/{id}` to get vCD Cluster job status.\n     * `GET /vcd/vapp` to get summary for vApps.\n     * `GET /vcd/vapp/{id}` to get vApp details.\n     * `PATCH /vcd/vapp/{id}` to make changes to the parameters of a\n      specified vApp object.\n     * `GET /vcd/vapp/{id}/snapshot` to retrieve summary information for each\n      of the snapshot objects of a specified vApp object.\n     * `POST /vcd/vapp/{id}/snapshot` to start an asynchronous job to create\n      an on-demand snapshot for a specified vApp object.\n     * `DELETE /vcd/vapp/{id}/snapshot` to delete all snapshots of vApp.\n     * `GET /vcd/vapp/snapshot/{id}` to get vApp snapshot details.\n     * `DELETE /vcd/vapp/snapshot/{id}` to delete vApp snapshot.\n     * `GET /vcd/vapp/{id}/missed_snapshot` to get details about missed\n      snapshots for a vApp.\n     * `GET /vcd/vapp/snapshot/{snapshot_id}/export/options` to get\n      exportable network configurations.\n     * `POST /vcd/vapp/snapshot/{snapshot_id}/export` to export vApp snapshot.\n     * `POST /vcd/vapp/snapshot/{snapshot_id}/instant_recover` to instant\n      Recovery of vApp virtual machines.\n     * `GET /vcd/vapp/snapshot/{snapshot_id}/instant_recover/options` to get\n      Instant Recovery information.\n     * `GET /vcd/vapp/request/{id}` to retrieve the details of a specified\n      asynchronous job for a vApp.\n     * `GET /vcd/vapp/{id}/search` to search for a file from a vApp.\n     * `POST /vcd/vapp/snapshot/{id}/download` to download snapshot from\n      archive.\n * Added new endpoint, `GET /hyperv/vm/{id}/request/force_full_snapshot`.\n   This endpoint retrieves the configuration used to force a full snapshot\n   of a Hyper-V virtual machine.\n * Added new endpoint, `POST /hyperv/vm/{id}/request/force_full_snapshot`.\n   This endpoint requests to force a full snapshot of a Hyper-V virtual machine.\n * Added new endpoint, `GET /vmware/vm/{id}/request/force_full_snapshot`.\n  This endpoint retrieves the configuration used to force a full snapshot\n  of a VMware virtual machine.\n * Added new endpoint `POST /vmware/vm/{id}/request/force_full_snapshot`.\n  This endpoint requests to force a full snapshot of a VMware virtual machine.\n### Changes to V1 API in Rubrik Version 5.3.2\n ## Feature additions/improvements:\n * Modified instanceName field in the `GET /mssql/db` endpoint by adding\n   the network name for SQL Server databases belonging to a cluster\n   instance.\n\n ### Changes to V1 API in Rubrik Version 5.3.1\n ## Feature additions/improvements:\n * Added `GET /exclusion_pattern`\n   endpoint to get all exclusion patterns.\n * Added `GET /exclusion_pattern/{id}`\n   endpoint to get a exclusion pattern by id.\n * Added `POST /exclusion_pattern`\n   endpoint to create a new exclusion pattern.\n * Added `POST /exclusion_pattern/bulk`\n   endpoint to bulk create new exclusion patterns.\n * Added `PATCH /exclusion_pattern/{id}`\n   endpoint to update a exclusion pattern.\n * Added `DELETE /exclusion_pattern/{id}`\n   endpoint to delete a exclusion pattern.\n * Added `DELETE /exclusion_pattern/bulk`\n   endpoint to bulk delete exclusion patterns.\n * Added new optional field `keyProtection` to `EncryptionStatus`\n   to support returning key protection status via v1 API\n   `GET /cluster/{id}/security/encryption`.\n * Added `Post /vmware/vm/snapshot/{id}/export_with_download` endpoint to export\n   a vm snapshot from an archival location.\n * Added new field `index` to `JobMonitoringObjectsCountByType`, which contains\n   the total count of all Index jobs.\n * Added `Index` to `JobMonitoringTaskType`.\n * Added new optional field `isTotpEnforced` to `LdapServiceInfo`,\n   `LdapServiceSummary`, and `LdapServiceInfoUpdate` to support\n   TOTP enforcement for LDAP services in followin APIs.\n   `POST /v1/ldap_service`\n   `GET /v1/ldap_service`\n   `GET /v1/ldap_service/{id}`\n   `PATCH /v1/ldap_service/{id}`\n   `PUT /v1/ldap_service/{id}`\n * Added new optional field `isTotpEnabled` as a query param in API\n   `GET /v1/principal` for fetch users with TOTP enabled.\n * Added new optional fields `mfaServerName`, `isTotpEnabled`, and\n   `isTotpEnforced` to `PrincipalSummaryV1` as part of response from\n   API `GET /v1/principal` for rendering principals' MFA status.\n * Modified `AgentConnectStatus` enum to add value SecondaryCluster for\n   multicluster Rubrik Backup Service support. This will be the status on a\n   cluster that is not the primary.\n * Added new endpoint and optional fields for VMware network selection.\n    GET /vmware/config/recovery/networks for getting recovery networks.\n\n ## New features:\n * Added new endpoints for supporting TOTP configuration.\n   `GET /user/{id}/totp/status`\n   `PUT /user/{id}/totp/config`\n   `DELETE /user/{id}/totp/config`\n   `POST /user/{id}/totp/new_secret`\n * Added new endpoints for supporting multicluster Rubrik Backup Service.\n   `POST /vmware/vm/make_primary`\n   `POST /host/make_primary`\n * Added new endpoints for managing multicluster Rubrik Backup Service\n   certificates.\n   `GET /certificate/agent`\n   `POST /certificate/agent`\n   `DELETE /certificate/agent/{id}`\n\n ### Changes to V1 API in Rubrik Version 5.3.0\n ## Deprecation:\n * Deprecated `SnapshotCloudStorageTier` enum value Cold. It will be left,\n   but will be mapped internally to the new value, AzureArchive,\n   which is recommended as a replacement.\n * Removed signature and sigAlg return fields from `SamlSsoAuthnRequestDetail`,\n   which were wrongly introduced in 5.1.\n * Removed `GET /vmware/resource_pool` endpoint, which doesn't have backend implementation.\n * Removed `GET /vmware/resource_pool/{id}` endpoint, which doesn't have backend implementation.\n ## New features:\n * Added `Deleted` as new failover cluster node connection status in\n   FailoverClusterNodeConnectionStatus. The FailoverClusterNodeConnectionStatus\n   is in FailoverClusterNode object and is used by\n   `GET /failover_cluster`,\n   `GET /failover_cluster/{id}`,\n   `GET /failover_cluster/hierarchy/{id}`,\n   `GET /failover_cluster/hierarchy/{id}/children`,\n   `GET /failover_cluster/hierarchy/{id}/descendants` endpoints.\n * Added `POST /cluster/{id}/manual_discover_ll_ipv4` endpoint to allow discovery of new\n   nodes over link local ipv4 network.\n * Added new optional field `groupMaxLevel` to `AdvancedLdapConfiguration`\n   included in `LdapServiceSummary`, `LdapServiceInfo` and `LdapServiceInfoUpdate`\n   objects used by endpoints:\n   `GET /ldap_service`,\n   `POST /ldap_service`,\n   `GET /ldap_service/{id}`,\n   `PUT /ldap_service/{id}`,\n   `PATCH /ldap_service/{id}`.\n * Added `is_on_demand` as an optional parameter to `GET /job_monitoring`\n * Added `GET /cluster/{id}/syslog_msg_mib_link` and\n   `GET /cluster/{id}/syslog_tc_mib_link` endpoints to allow downloading syslog\n   SNMP MIB files.\n * Added `POST /vmware/vm/missed_recoverable_range` endpoint to get missed recoverable\n   ranges for a list of virtual machines.\n * Added `GET /backup/retry/{id}` endpoint to get status of reschedule\n   operation.\n * Added `POST /backup/retry` endpoint to reschedule unsuccessful backup tasks.\n * Added `POST /vmware/vm/recoverable_range` endpoint to get recoverable ranges\n   for a list of virtual machines.\n * Added endpoint `POST /hierarchy/bulk_sla_conflicts`. Bulk get the list of\n   descendant objects with SLA conflicts.\n * Added endpoint `GET /snapshot/{id}/storage/stats`. Returns storage stats\n   for a snapshot.\n * Added optional query parameter `include_expired` to `GET /certificate`\n   endpoint, excluded expired certs by default after the change.\n * Added endpoint\n   `GET /job_monitoring/subscription`. Gets all subscriptions to\n   monitoring page.\n * Modified `SnapshotCloudStorageTier`, enum adding values AzureArchive, Glacier,\n   and GlacierDeepArchive.\n * Added endpoint\n   `GET /backup/verify/{id}`. Get asynchronous request\n   details for a Backup Verification job.\n * Added new optional field `privateKey` to `CertificateImportRequest`\n   object sent to `POST /certificate`. Using this field will fail the request\n   if the provided private key is not successfully parsed.\n * Added endpoint\n   `DELETE /job_monitoring/subscription/{subscription_id}`. Delete a\n   monitoring page email subscription.\n * Added endpoint\n   `PATCH /job_monitoring/subscription/{subscription_id}`. Update a\n   monitoring email subscription.\n * Added endpoint\n   `GET /job_monitoring/subscription/{subscription_id}`. Get a\n   specific monitoring email subscription by id.\n * Added endpoint\n   `POST /job_monitoring/subscription`. Create an email subscription\n   to the job monitoring page.\n * Added new endpoint `POST /backup/verify`\n    Verifies the validity of a snapshot.\n * Added endpoint `PATCH /organization/{id}/envoy/bulk`. Update a list of\n   Rubrik Envoy objects.\n * Added new field `isGpsLoginEnabled` to `SamlSsoStatus` returned by\n   `GET /saml/sso_status`\n * Added endpoint `GET /oracle/aco_example_download_link`. Get a download link\n   for an example Advanced Recovery Options file.\n * Added endpoint `POST /organization/{id}/envoy/bulk`. Create a list of Rubrik\n   Envoy objects.\n * Added endpoint `Delete /organization/{id}/envoy/bulk`. Remove a list of\n   Rubrik Envoy objects.\n * Added organization ID parameter to the response object\n   IdProviderAuthDomainSummary.\n * Added endpoint `GET /vmware/vcenter/hotadd/vm`. Gets details about\n    all HotAdd proxy virtual machines.\n * Added endpoint `POST /sap_hana/system/{id}/refresh`. Initiates an\n    asynchronous job to refresh SAP HANA system metadata.\n * Added new field `vcenterName` to `VritualMachineDetail` returned by\n   `GET /vmware/vm/{id}`.\n * Added endpoint `DELETE /sap_hana/system/{id}`. Initiates an asynchronous\n    job to delete a SAP HANA system object.\n * Added endpoint `GET /sap_hana/system/request/{id}`. Gets details about\n    a SAP HANA system related asynchronous request.\n * Added endpoint `POST /sap_hana/db/{id}/snapshot`. Initiates a job to\n    take an on-demand full snapshot of a SAP HANA database.\n * Added endpoint `GET /sap_hana/db/request/{id}`. Gets details about\n    a SAP HANA database related request.\n * Added endpoint `GET /sap_hana/db/{id}/snapshot`. Returns a list of\n    summary of snapshots of a SAP HANA database.\n * Added endpoint `GET /sap_hana/db/snapshot/{id}`. Gets details about\n    a SAP HANA database snapshot.\n * Added the `POST /oracle/db/{id}/validate` to trigger an validation job on Oracle backups.\n * Added new values `RetentionSlaDomainName` , `ObjectType`, `SnapshotCount`,\n   `AutoSnapshotCount` and  `ManualSnapshotCount` to\n   `UnmanagedObjectSortAttribute` field of the\n   `GET /unmanaged_object/reader_object` endpont.\n * Added new values `RetentionSlaDomainName` , `ObjectType`, `SnapshotCount`,\n   `AutoSnapshotCount` and  `ManualSnapshotCount` to\n   `UnmanagedObjectSortAttribute` field of the `GET /unmanaged_object` endpont.\n * Added the `POST /replication/location_pause/disable` to\n    resume replication from source cluster(s).\n * Added the `POST /replication/location_pause/enable` to\n    pause replication from source cluster(s).\n * Added endpoint `POST /sap_hana/system`. Adds new entry for SAP HANA system\n    and stores in database.\n * Added endpoint `GET /sap_hana/db`. Returns summary of all discovered\n    SAP HANA databases.\n * Added endpoint `GET /sap_hana/db/{id}` Returns summary of SAP HANA database\n    with given ID.\n * Added `AggregateSapHanaDb`, `SapHanaDb` and `SapHanaSystem` to the\n    `object_type` filtering field of the `GET /event/latest` endpoint.\n * Added the new optional field `failoverClusterAppName` to FilesetSummary\n    returned by `GET /fileset` and `GET /fileset/{id}`.\n * Added the `GET /user/lockout` endpoint to\n    get the status of local user account lockout.\n * Added the `PATCH /user/lockout` endpoint to\n    update the local user account lockout config.\n * Added the `POST /user/{id}/unlock` endpoint to unlock local user.\n * Added the `GET /cluster/{id}/upgrade/precheck_status` endpoint to\n    get the result of the latest run of periodic upgrade prechecks.\n * Added the `POST /cluster/{id}/upgrade/precheck_status` endpoint to\n    start an on-demand run of the periodic upgrade prechecks.\n * Added the `GET /cluster/{id}/rubrik_support_portal_credentials`\n    endpoint to check if the cluster already has credentials\n    for the Rubrik support portal.\n * Added the `POST /cluster/{id}/rubrik_support_portal_credentials`\n    endpoint to update Rubrik support portal credentials for\n    the cluster.\n * Added the `GET /vmware/vcenter/{id}/networks` endpoint to get the\n    networks in a vCenter.\n * Added new field `isOracleHost` to HostDetail\n   returned by `GET /host/{id}`.\n * Added the `POST /vmware/vcenter/{id}/hotadd/network` endpoint to set\n   the network for a HotAdd proxy virtual machine.\n * Added new endpoint `GET /host/{id}/nas_share_discover`. Returns all\n   shares on the NAS host specified by 'id'.\n * Added new endpoint `POST /host/share/bulk` to allow adding NAS\n   shares in bulk without validating their share credentials.\n * Added `GET /volume_group` to retrieve a current list of Volume Groups.\n * Added `GET /volume_group/{id}` to retrieve the details of a Volume Group.\n * Added `PATCH /volume_group/{id}` to modify the details of a Volume Group.\n * Added `GET /volume_group/{id}/snapshot` to retrieve the details of all\n   snapshots of a Volume Group.\n * Added `POST /volume_group/{id}/snapshot` to create an on-demand snapshot\n   of a Volume Group.\n * Added `GET /volume_group/snapshot/{id}` to get the details of a Volume\n   Group snapshot.\n * Added `GET /volume_group/snapshot/mount` to retrieve summary information\n   of all Volume Group mounts.\n * Added `GET /volume_group/snapshot/mount/{id}` to retrieve summary\n   information of one Volume Group mount.\n * Added `GET /host/{id}/volume` to retrieve a list of all volumes on a\n   Volume Group host.\n * Made field `restoreScriptSmbPath` optional in `VolumeGroupMountSummary`.\n   This change affects the endpoints `/volume_group/snapshot/mount` and\n   `/volume_group/snapshot/mount/{id}`.\n * Added endpoint `GET /mfa/rsa/server` to get all MFA servers.\n * Added endpoint `POST /mfa/rsa/server` to create a new MFA server.\n * Added endpoint `GET /mfa/rsa/server/{id}` to get a specific MFA server.\n * Added endpoint `PATCH /mfa/rsa/server/{id}` to update an MFA server.\n * Added endpoint `DELETE /mfa/rsa/server/{id}` to delete an MFA server.\n * Added endpoint `PUT /cluster/{id}/security/web_signed_cert`\n    to set the web server certificate.\n * Added endpoint `DELETE /cluster/{id}/security/web_signed_cert`\n    to use the default, self-signed web server certificate.\n * Added endpoint `PUT /cluster/{id}/security/kmip/client` to configure\n    the KMIP client on Rubrik.\n * Added endpoint `GET /cluster/{id}/security/kmip/client` to get\n    the KMIP client configuration.\n * Added endpoint `GET /cluster/{id}/security/kmip/server` to get the\n    KMIP server configurations.\n * Added endpoint `PUT /cluster/{id}/security/kmip/server` to configure a\n    KMIP server.\n * Added endpoint `DELETE /cluster/{id}/security/kmip/server` to delete a\n    configured KMIP server.\n * Added endpoint `GET /database/log_report` to retrieve the database log\n    report summary.\n * Added endpoint `POST /unmanaged_object/assign_retention_sla` to assign\n    a retention SLA to unmanaged objects asynchronously.\n * Added endpoint `GET /sap_hana/db/{id}/recoverable_range`. Gets details\n    about recoverable ranges of a SAP HANA database.\n * Added new  field `legalHoldDownloadConfig` to `MssqlBackupSelection` and\n   `DownloadMssqlBackupFilesByIdJobConfig`. An optional Boolean that specifies\n   whether the download is in response to a Legal Hold. This change affects\n   endpoints `/mssql/db/{id}/download_files_by_id`,\n   `/mssql/db/{id}/download_files` and `/mssql/db/{id}/browse`.\n * Added new field `canUnmount` to `VolumeGroupMountSummary`, an optional\n   boolean value that indicates if the logged-in user has the authority\n   to remove the specified mount.\n * Added `GET /vmware/vcenter/{id}/hotadd/needed` endpoint to get the\n    number of HotAdd proxies needed for a vCenter.\n * Added endpoint `DELETE /sap_hana/db/snapshot/{id}`. Initiates a request\n   to delete a full snapshot of a SAP HANA database.\n * Added new field `needsMigration` to `VolumeGroupSummary`. This change\n   affects the endpoints `GET /volume_group` and `GET /volume_group/{id}`.\n * Added new fields `usedFastVhdx` and `fileSizeInBytes` to\n   `VolumeGroupSnapshotSummary`. This change affects the endpoints\n   `GET /volume_group/{id}/snapshot` and `GET /volume_group/snapshot/{id}`.\n * Added endpoint `GET /cluster/me/upgrade/monitor_events` to get notifications\n   about events occurring at CDM.\n * Added endpoint `GET /volume_group/{id}/latest_snapshot` to retrieve summary\n   information of the latest snapshot of a Volume Group.\n * Added `GET /vmware/vcenter/{id}/hotadd/bandwidth` endpoint to get the\n   HotAdd bandwidth limits for a vCenter.\n * Added `POST /vmware/vcenter/{id}/hotadd/bandwidth` endpoint to set the\n   HotAdd bandwidth limits for a vCenter.\n * Added field `isVmc` returned by `GET /vmware/vcenter` to retrieve summary\n   information of a vCenter.\n * Added new optional field `unreadable` to `BrowseResponse`, which is used by\n   `GET /browse`.\n * Added new endpoint `GET /config/history/list_updates` Returns a list of\n   filtered configuration updates.\n * Added new endpoint `GET /config/history/ondate` Returns a list of\n   configurations and their values on a given date.\n * Added new field `dataToTransfer` to `EventSeriesSummaryV1`, an optional\n   integer value that represents the amount of data that needs to be\n   transferred by the job corresponding to the event.\n * Added new field `estimatedTimeRemaining` to `EventSeriesSummaryV1`, an\n   optional string value that represents the estimated time remaining until\n   the job corresponding to the event has completed. The estimated time has\n   millisecond granularity.\n * Added endpoint `GET /sap_hana/db/{id}/missed_snapshot` Returns a list of\n    summary information for the missed snapshots of a SAP HANA database.\n * Added new field `forceFull` to `VolumeGroupSummary`. This change\n   affects the endpoints `GET /volume_group` and `GET /volume_group/{id}`.\n * Modified afterId in response of `GET /event/latest` and `GET /event`\n   to point to each individual event in the list response instead of having\n   all afterId values in the list response point to the last event in the\n   list.\n * Copied `GET /mssql/availability_group` endpoint from internal to v1 to get\n   all SQL Server availability groups.\n * Copied `GET /mssql/availability_group/{id}` endpoint from internal to v1 to\n   get details of a SQL Server availability group.\n * Copied `PATCH /mssql/availability_group/{id}` endpoint from internal to\n   v1 to update a SQL Server availability group.\n * Copied `PATCH /mssql/db/bulk` endpoint from internal to v1 to update multiple\n   SQL Server databases.\n * Copied `POST /mssql/db/bulk/snapshot` endpoint from internal to v1 to take on\n   demand snapshot of multiple SQL Server databases.\n * Copied `GET /mssql/db/bulk/snapshot/{id}` endpoint from internal to v1 to get\n   details of on demand snapshot of multiple SQL Server databases.\n * Copied `GET /mssql/db/count` endpoint from internal to v1 to get the count of\n   SQL Server databases.\n * Copied `GET /mssql/instance/count` endpoint from internal to v1 to get the\n   count of SQL Server instances.\n * Copied `DELETE /mssql/db/{id}/recoverable_range/download` endpoint from\n   internal to v1 to delete downloaded recoverable ranges of a SQL Server\n   database.\n * Copied `GET /mssql/db/recoverable_range/download/{id}` endpoint from\n   internal to v1 to get the status of delete downloaded recoverable range job.\n * Copied `GET /mssql/db/{id}/compatible_instance` endpoint from internal to v1\n   to get compatible instances for the recovery of a SQL Server database.\n * Copied `GET /mssql/db/{id}/restore_estimate` endpoint from internal to v1 to\n   get size estimate for restore or export of a SQL Server database.\n * Copied `GET /mssql/db/{id}/restore_files` endpoint from internal to v1 to get\n   all data files to be restored for an export or restore operation on a SQL\n   Server database.\n * Copied `GET /mssql/db/{id}/snappable_id` endpoint from internal to v1 to get\n   the snappable id of a SQL Server database.\n * Copied `GET /mssql/db/defaults` endpoint from internal to v1 to get the\n   default properties for SQL Server databases.\n * Copied `PATCH /mssql/db/defaults` endpoint from internal to v1 to update the\n * Added new field `instanceChildrenInfo` to the response from the v1 endpoint\n   `GET /mssql/hierarchy/root/children`. The new field is an array of type\n   `MssqlInstanceShortSummary` that contains the managed identifier, the name and\n   active node for a Windows Failover Cluster instance.\n * Added enums for the `sort_by` parameter in `GET /mssql/db`.\n * Added `POST /cluster/{id}/manual_discover_ipv4` endpoint to allow discovery of new\n   nodes over IPv4 network.\n ## Breaking changes:\n * Added new field `nodeName` in FailoverClusterNodeOrder object used by\n   `PATCH /failover_cluster/failover_cluster_app/{id}` and\n   `POST /failover_cluster/failover_cluster_app` endpoints.\n   The `nodeName` is the name of the failover cluster node.\n * Renamed the field `vips` in FailoverClusterAppSource object to\n   `virtualIps`. The FailoverClusterAppSource is used by\n   `GET /failover_cluster/failover_cluster_app`,\n   `GET /failover_cluster/failover_cluster_app/{id}`,\n   `GET /failover_cluster/hierarchy/{id}`,\n   `GET /failover_cluster/hierarchy/{id}/children`,\n   `GET /failover_cluster/hierarchy/{id}/descendants`,\n   `PATCH /failover_cluster/failover_cluster_app/{id}` and\n   `POST /failover_cluster/failover_cluster_app` endpoints.\n * Removed `POST /cluster/{id}/manual_discover_ll_ipv4`\n\n### Changes to V1 API in Rubrik Version 5.2.2\n ## New features:\n * Added optional field isOnDemand to `EventSeriesSummaryV1`.\n   The parameter indicates if the job associated with the event\n   series is a on demand job.\n\n ### Changes to V1 API in Rubrik Version 5.2.1\n ## New features:\n * Added optional query parameters limit and offset to support pagination for\n   GET /role endpoint.\n\n ### Changes to V1 API in Rubrik Version 5.2.0\n ## Deprecation:\n * Deprecating `slaId` field returned by `GET /mssql/db/{id}/snapshot`.\n    See **snapshotRetentionInfo** to track retention for\n    snapshots.\n * Deprecating `slaId` field returned by `GET /mssql/db/snapshot/{id}`.\n    See **snapshotRetentionInfo** to track retention for\n    snapshots.\n * Deprecating `slaId` field returned by `GET /vmware/vm/{id}/snapshot`.\n    See **snapshotRetentionInfo** to track retention for\n    snapshots.\n * Deprecating `slaId` field returned by `GET /vmware/vm/{id}`.\n    See **snapshotRetentionInfo** to track retention for\n    snapshots.\n * Deprecating `slaId` field returned by `GET /vmware/vm/snapshot/{id}`.\n    See **snapshotRetentionInfo** to track retention for\n    snapshots.\n * Deprecating `slaId` field returned by `GET /hdfs/snapshot/{id}`.\n    See **snapshotRetentionInfo** to track retention for\n    snapshots.\n * Deprecating `slaId` field returned by `GET /hdfs`.\n    See **snapshotRetentionInfo** to track retention for\n    snapshots.\n * Deprecating `slaId` field returned by `POST /hdfs`.\n    See **snapshotRetentionInfo** to track retention for\n    snapshots.\n * Deprecating `slaId` field returned by `GET /hdfs/{id}`.\n    See **snapshotRetentionInfo** to track retention for\n    snapshots.\n * Deprecating `slaId` field returned by `PATCH /hdfs/{id}`.\n    See **snapshotRetentionInfo** to track retention for\n    snapshots.\n * Deprecating `slaId` field returned by `GET /fileset/snapshot/{id}`.\n    See **snapshotRetentionInfo** to track retention for\n    snapshots.\n * Deprecating `slaId` field returned by `GET /fileset`.\n    See **snapshotRetentionInfo** to track retention for\n    snapshots.\n * Deprecating `slaId` field returned by `POST /fileset`.\n    See **snapshotRetentionInfo** to track retention for\n    snapshots.\n * Deprecating `slaId` field returned by `GET /fileset/{id}`.\n    See **snapshotRetentionInfo** to track retention for\n    snapshots.\n * Deprecating `slaId` field returned by `PATCH /fileset/{id}`.\n    See **snapshotRetentionInfo** to track retention for\n    snapshots.\n * Deprecating `slaId` field returned by `GET /failover_cluster/\n    failover_cluster_app/{id}`.\n    See **snapshotRetentionInfo** to track retention for\n    snapshots.\n ## New features:\n * Added new endpoint\n  `GET /data_source/{id}/expired_custom_retention_snapshots`.\n   Get all expired snapshots which were explicitly assigned a SLA domain.\n * Added new field `parentSnapshotId` to FilesetSnapshotDetail returned by\n   `GET /fileset/snapshot/{id}`.\n * Added new field `parentSnapshotId` to HdfsSnapshotDetail returned by\n   `GET /hdfs/snapshot/{id}`.\n * Added new field `parentSnapshotId` to MssqlDbSnapshotSummary returned by\n   `GET /mssql/db/{id}/snapshot`.\n * Added new field `parentSnapshotId` to MssqlDbSnapshotDetail returned by\n   `GET /mssql/db/snapshot/{id}`.\n * Added new field `parentSnapshotId` to VmSnapshotSummary returned by\n   `GET /vmware/vm/{id}/snapshot`.\n * Added new field `parentSnapshotId` to VmSnapshotDetail returned by\n   `GET /vmware/vm/snapshot/{id}`.\n * Added new field `retentionSlaDomanId` to MssqlHierarchyObjectSummary\n   returned by `GET /mssql/hierarchy/{id}`.\n * Added new field `retentionSlaDomanId` to MssqlHierarchyObjectSummary\n   returned by `GET /mssql/hierarchy/{id}/descendants`.\n * Added new field `retentionSlaDomanId` to MssqlHierarchyObjectSummary\n   returned by `GET /mssql/hierarchy/{id}/children`.\n * Added new field `retentionSlaDomanId` to MssqlDbDetail\n   returned by `GET /mssql/db/{id}`.\n * Added new field `retentionSlaDomanId` to MssqlDbDetail\n   returned by `PATCH /mssql/db/{id}`.\n * Added new field `retentionSlaDomanId` to MssqlDbDetail\n   returned by `PATCH /mssql/db/bulk`.\n * Added new field `retentionSlaDomanId` to MssqlDbSnapshotDetail\n   returned by `GET /mssql/db/snapshot/{id}`.\n * Added new field `retentionSlaDomanId` to MssqlDbSummary\n   returned by `GET /mssql/db`.\n * Added new field `retentionSlaDomainId` to ComputeClusterDetail\n   returned by `PATCH /vmware/compute_cluster/{id}`.\n * Added new field `retentionSlaDomainId` to VmwareHostDetail\n   returned by `PATCH /vmware/host/{id}`.\n * Added new field `retentionSlaDomainId` to VmwareVmMountDetailV1\n   returned by `PATCH /vmware/vm/snapshot/mount/{id}`.\n * Added new field `retentionSlaDomainId` to VmwareVmMountSummary\n   returned by `GET /vmware/vm/snapshot/mount`.\n * Added new field `retentionSlaDomainId` to BulkOracleDbDetails\n   returned by `PATCH /oracle/db/bulk`.\n * Added new field `retentionSlaDomainId` to ComputeClusterDetail\n   returned by `GET /vmware/compute_cluster/{id}`.\n * Added new field `retentionSlaDomainId` to UnmanagedObjectDetails\n   returned by `GET /unmanaged_object`.\n * Added new field `retentionSlaDomainId` to UnmanagedObjectSummary\n   returned by `GET /unmanaged_object/reader_object`.\n * Added new field `retentionSlaDomainId` to VirtualMachineDetail\n   returned by `GET /vmware/vm/{id}`.\n * Added new field `retentionSlaDomainId` to VirtualMachineDetail\n   returned by `PATCH /vmware/vm/{id}`.\n * Added new field `retentionSlaDomainId` to VirtualMachineSummary\n   returned by `GET /vmware/vm`.\n * Added new field `retentionSlaDomainId` to VmSnapshotDetail\n   returned by `GET /vmware/vm/snapshot/{id}`.\n * Added new field `retentionSlaDomainId` to VmwareHostDetail\n   returned by `GET /vmware/host/{id}`.\n * Added new field `retentionSlaDomainId` to VmwareVmMountDetailV1\n   returned by `GET /vmware/vm/snapshot/mount/{id}`.\n * Added new field `retentionSlaDomainId` to UnmanagedObjectSummary\n   returned by `GET /unmanaged_object`.\n * Added new endpoint `GET /report/compliance_summary_sla`. Returns the\n   compliance summary information for all protected objects based on a\n   SLA Domain-based requirement of whether the last expected snapshot was taken.\n   Currently behind flag, will not return correct information\n   until flag is flipped.\n * Added endpoint `GET /cluster/{id}/upgrade/available_version` which\n      retrieves a list of Rubrik CDM versions available to upgrade the Rubrik\n      cluster.\n * Added endpoint `GET /cluster/{id}/upgrade/request/${request_id}` to\n   query the status of an asynchronous upgrade related request.\n * Added endpoint `POST /cluster/{id}/upgrade/stage_cdm_software` which\n   allows staging CDM software for upgrades on the cluster.\n * Added new field `hasSnapshotsWithPolicy` to UnmanagedObjectDetails returned\n   by GET `/unmanaged_object`.\n * Added new field `hasSnapshotsWithPolicy` to UnmanagedObjectSummary returned\n   by GET `/unmanaged_object`.\n * Added new field `hasSnapshotsWithPolicy` to UnmanagedObjectSummary returned\n   by GET `/unmanaged_object/reader_object`\n * Added new field `slaLastUpdateTime` to BulkOracleDbDetails\n   returned by `PATCH /oracle/db/bulk`.\n * Added new field `slaLastUpdateTime` to BulkOracleHostDetails\n   returned by `PATCH /oracle/host/bulk`.\n * Added new field `slaLastUpdateTime` to BulkOracleRacDetails\n   returned by `PATCH /oracle/rac/bulk`.\n * Added new field `slaLastUpdateTime` to ComputeClusterDetail\n   returned by `GET /vmware/compute_cluster/{id}`.\n * Added new field `slaLastUpdateTime` to ComputeClusterDetail\n   returned by `PATCH /vmware/compute_cluster/{id}`.\n * Added new field `slaLastUpdateTime` to ComputeClusterSummary\n   returned by `GET /vmware/compute_cluster`.\n * Added new field `slaLastUpdateTime` to FailoverClusterAppDetail\n   returned by `GET /failover_cluster/failover_cluster_app/{id}`.\n * Added new field `slaLastUpdateTime` to FailoverClusterAppSummary\n   returned by `GET /failover_cluster/failover_cluster_app`.\n * Added new field `slaLastUpdateTime` to FailoverClusterAppSummary\n   returned by POST `/failover_cluster/failover_cluster_app`.\n * Added new field `slaLastUpdateTime` to FailoverClusterAppSummary\n   returned by `PATCH /failover_cluster/failover_cluster_app/{id}`.\n * Added new field `slaLastUpdateTime` to FailoverClusterDetail\n   returned by POST `/failover_cluster`.\n * Added new field `slaLastUpdateTime` to FailoverClusterDetail\n   returned by `GET /failover_cluster/{id}`.\n * Added new field `slaLastUpdateTime` to FailoverClusterDetail\n   returned by `PATCH /failover_cluster/{id}`.\n * Added new field `slaLastUpdateTime` to FailoverClusterHierarchyObjectSummary\n   returned by `GET /failover_cluster/hierarchy/{id}`.\n * Added new field `slaLastUpdateTime` to FailoverClusterHierarchyObjectSummary\n   returned by `GET /failover_cluster/hierarchy/{id}/children`.\n * Added new field `slaLastUpdateTime` to FailoverClusterHierarchyObjectSummary\n   returned by `GET /failover_cluster/hierarchy/{id}/descendants`.\n * Added new field `slaLastUpdateTime` to FailoverClusterSummary\n   returned by `GET /failover_cluster`.\n * Added new field `slaLastUpdateTime` to FilesetDetail\n   returned by `POST /fileset`.\n * Added new field `slaLastUpdateTime` to FilesetDetail\n   returned by `GET /fileset/{id}`.\n * Added new field `slaLastUpdateTime` to FilesetDetail\n   returned by `PATCH /fileset/{id}`.\n * Added new field `slaLastUpdateTime` to FilesetSummary\n   returned by `GET /fileset`.\n * Added new field `slaLastUpdateTime` to HdfsDetail\n   returned by `POST /hdfs`.\n * Added new field `slaLastUpdateTime` to HdfsDetail\n   returned by `GET /hdfs/{id}`.\n * Added new field `slaLastUpdateTime` to HdfsDetail\n   returned by `PATCH /hdfs/{id}`.\n * Added new field `slaLastUpdateTime` to HdfsSummary\n   returned by `GET /hdfs`.\n * Added new field `slaLastUpdateTime` to HostHierarchyObjectSummary\n   returned by `GET /host/hierarchy/{id}`.\n * Added new field `slaLastUpdateTime` to HostHierarchyObjectSummary\n   returned by `GET /host/hierarchy/{id}/children`.\n * Added new field `slaLastUpdateTime` to VcenterDetail\n   returned by `GET /vmware/vcenter/{id}`.\n * Added new field `slaLastUpdateTime` to VcenterSummary\n   returned by `GET /vmware/vcenter`.\n * Added new field `slaLastUpdateTime` to VcenterSummary\n   returned by `PATCH /vmware/vcenter/{id}`.\n * Added new field `slaLastUpdateTime` to VcenterSummary\n   returned by `PUT /vmware/vcenter/{id}`.\n * Added new field `slaLastUpdateTime` to VirtualMachineDetail\n * Added `PATCH /host/share/bulk` endpoint to update multiple network shares.\n * Added new field `isCustomRetentionApplied` to SnapshotSummary returned by\n   `GET /unmanaged_object/{id}/snapshot`.\n * Added new field `slaLastUpdateTime` to VirtualMachineDetail\n   returned by `GET /vmware/vm/{id}`.\n * Added new field `slaLastUpdateTime` to VirtualMachineDetail\n   returned by `PATCH /vmware/vm/{id}`.\n * Added new field `slaLastUpdateTime` to VirtualMachineSummary\n   returned by `GET /vmware/vm`.\n * Added new field `slaLastUpdateTime` to VmSnapshotDetail\n   returned by `GET /vmware/vm/snapshot/{id}`.\n * Added new field `slaLastUpdateTime` to VmwareHostDetail\n   returned by `GET /vmware/host/{id}`.\n * Added new field `slaLastUpdateTime` to VmwareHostDetail\n   returned by `PATCH /vmware/host/{id}`.\n * Added new field `slaLastUpdateTime` to VmwareHostSummary\n   returned by `GET /vmware/host`.\n * Added new field `slaLastUpdateTime` to VmwareVmMountDetailV1\n   returned by `GET /vmware/vm/snapshot/mount/{id}`.\n * Added new field `slaLastUpdateTime` to VmwareVmMountDetailV1\n   returned by `PATCH /vmware/vm/snapshot/mount/{id}`.\n * Added new field `slaLastUpdateTime` to VmwareVmMountSummary\n   returned by `GET /vmware/vm/snapshot/mount`.\n * Added new field `isCustomRetentionApplied` to SnapshotSummary returned by\n   `GET /unmanaged_object/{id}/snapshot`.\n * Added new Field `configuredSlaDomainType` to BulkOracleDbDetails returned by\n  `PATCH /oracle/db/bulk`.\n * Added new Field `configuredSlaDomainType` to BulkOracleHostDetails returned\n   by `PATCH /oracle/host/bulk`.\n * Added new Field `configuredSlaDomainType` to BulkOracleRacDetails returned by\n  `PATCH /oracle/rac/bulk`.\n * Added new Field `configuredSlaDomainType` to ComputeClusterDetail returned by\n  `GET /vmware/compute_cluster/{id}`.\n * Added new Field `configuredSlaDomainType` to ComputeClusterDetail returned by\n  `PATCH /vmware/compute_cluster/{id}`.\n * Added new Field `configuredSlaDomainType` to ComputeClusterSummary returned\n   by `GET /vmware/compute_cluster`.\n * Added new Field `configuredSlaDomainType` to FailoverClusterAppDetail\n   returned by `GET /failover_cluster/failover_cluster_app/{id}`.\n * Added new Field `configuredSlaDomainType` to FailoverClusterAppSummary\n   returned by `GET /failover_cluster/failover_cluster_app`.\n * Added new Field `configuredSlaDomainType` to FailoverClusterAppSummary\n   returned by `POST /failover_cluster/failover_cluster_app`.\n * Added new Field `configuredSlaDomainType` to FailoverClusterAppSummary\n   returned by `PATCH /failover_cluster/failover_cluster_app/{id}`.\n * Added new Field `configuredSlaDomainType` to FailoverClusterDetail returned\n   by `POST /failover_cluster`.\n * Added new Field `configuredSlaDomainType` to FailoverClusterDetail returned\n   by `GET /failover_cluster/{id}`.\n * Added new Field `configuredSlaDomainType` to FailoverClusterDetail returned\n   by `PATCH /failover_cluster/{id}`.\n * Added new Field `configuredSlaDomainType` to\n   FailoverClusterHierarchyObjectSummary returned by\n   `GET /failover_cluster/hierarchy/{id}`.\n * Added new Field `configuredSlaDomainType` to\n   FailoverClusterHierarchyObjectSummary returned by\n   `GET /failover_cluster/hierarchy/{id}/children`.\n * Added new Field `configuredSlaDomainType` to\n   FailoverClusterHierarchyObjectSummary returned by\n   `GET /failover_cluster/hierarchy/{id}/descendants`.\n * Added new Field `configuredSlaDomainType` to  FailoverClusterSummary returned\n   by `GET /failover_cluster`.\n * Added new Field `configuredSlaDomainType` to FilesetDetail returned by\n  `POST /fileset`.\n * Added new Field `configuredSlaDomainType` to FilesetDetail returned by\n  `GET /fileset/{id}`.\n * Added new Field `configuredSlaDomainType` to FilesetDetail returned by\n  `PATCH /fileset/{id}`.\n * Added new Field `configuredSlaDomainType` to FilesetSummary returned by\n  `GET /fileset`.\n * Added new Field `configuredSlaDomainType` to HdfsDetail returned by\n  `POST /hdfs`.\n * Added new Field `configuredSlaDomainType` to HdfsDetail returned by\n  `GET /hdfs/{id}`.\n * Added new Field `configuredSlaDomainType` to HdfsDetail returned by\n  `PATCH /hdfs/{id}`.\n * Added new Field `configuredSlaDomainType` to HdfsSummary returned by\n  `GET /hdfs`.\n * Added new Field `configuredSlaDomainType` to HostHierarchyObjectSummary\n   returned by `GET /host/hierarchy/{id}`.\n * Added new Field `configuredSlaDomainType` to HostHierarchyObjectSummary\n   returned by `GET /host/hierarchy/{id}/children`.\n * Added new Field `configuredSlaDomainType` to UnmanagedObjectDetails returned\n   by `GET /unmanaged_object`.\n * Added new Field `configuredSlaDomainType` to UnmanagedObjectSummary returned\n   by `GET /unmanaged_object`.\n * Added new Field `configuredSlaDomainType` to UnmanagedObjectSummary returned\n   by `GET /unmanaged_object/reader_object`.\n * Added new Field `configuredSlaDomainType` to VcenterDetail returned by\n   `GET /vmware/vcenter/{id}`.\n * Added new Field `configuredSlaDomainType` to VcenterSummary returned by\n   `GET /vmware/vcenter`.\n * Added new Field `configuredSlaDomainType` to VcenterSummary returned by\n   `PATCH /vmware/vcenter/{id}`.\n * Added new Field `configuredSlaDomainType` to VcenterSummary returned by\n   `PUT /vmware/vcenter/{id}`.\n * Added new Field `configuredSlaDomainType` to VirtualMachineDetail returned by\n   `GET /vmware/vm/{id}`.\n * Added new Field `configuredSlaDomainType` to VirtualMachineDetail returned by\n  `PATCH /vmware/vm/{id}`.\n * Added new Field `configuredSlaDomainType` to VirtualMachineSummary returned\n   by `GET /vmware/vm`.\n * Added new Field `configuredSlaDomainType` to VmSnapshotDetail returned by\n  `GET /vmware/vm/snapshot/{id}`.\n * Added new Field `configuredSlaDomainType` to VmwareHostDetail returned by\n  `GET /vmware/host/{id}`.\n * Added new Field `configuredSlaDomainType` to VmwareHostDetail returned by\n  `PATCH /vmware/host/{id}`.\n * Added new Field `configuredSlaDomainType` to VmwareHostSummary returned by\n  `GET /vmware/host`.\n * Added new Field `configuredSlaDomainType` to VmwareVmMountDetailV1 returned\n   by `GET /vmware/vm/snapshot/mount/{id}`.\n * Added new Field `configuredSlaDomainType` to VmwareVmMountDetailV1 returned\n   by `PATCH /vmware/vm/snapshot/mount/{id}`.\n * Added new Field `configuredSlaDomainType` to VmwareVmMountSummary returned by\n  `GET /vmware/vm/snapshot/mount`.\n * Added new field `isCustomRetentionApplied` to FilesetSnapshotDetail returned\n   by `GET /fileset/snapshot/{id}`.\n * Added new field `isCustomRetentionApplied` to HdfsSnapshotDetail returned by\n   `GET /hdfs/snapshot/{id}`.\n * Added new field `isCustomRetentionApplied` to MssqlDbSnapshotSummary returned\n   by `GET /mssql/db/{id}/snapshot`.\n * Added new field `isCustomRetentionApplied` to MssqlDbSnapshotDetail returned\n   by `GET /mssql/db/snapshot/{id}`.\n * Added new field `isCustomRetentionApplied` to VmSnapshotSummary returned by\n   `GET /vmware/vm/{id}/snapshot`.\n * Added new field `isCustomRetentionApplied` to VmSnapshotDetail returned by\n   `GET /vmware/vm/snapshot/{id}`.\n * Added endpoint `POST /cluster/{id}/manual_discover`, which allows\n   the customer to manually input data that would be learned using\n   mDNS discovery. Returns same output as the `discover` endpoint.\n * Added new endpoint `POST /data_source/{id}/snapshot/bulk_delete`.\n    Delete given snapshots for an object.\n * Added new endpoint `POST /data_source/snapshot/bulk_delete`.\n    Delete all snapshots for given objects.\n * Added new field `snapshotFrequency` to `snapshotLocationRetentionInfo` field\n   of `SnapshotRetentionInfo` field of FilesetSnapshotDetail returned by\n   `GET /fileset/snapshot/{id}`.\n * Added new field `snapshotFrequency` to `snapshotLocationRetentionInfo` field\n   of `SnapshotRetentionInfo` field of HdfsSnapshotDetail returned by\n   `GET/hdfs/snapshot/{id}`.\n * Added new field `snapshotFrequency` to `snapshotLocationRetentionInfo` field\n   of `SnapshotRetentionInfo` field of MssqlDbSnapshotSummary returned by\n   `GET /mssql/db/{id}/snapshot`.\n * Added new field `snapshotFrequency` to `snapshotLocationRetentionInfo` field\n   of `SnapshotRetentionInfo` field of MssqlDbSnapshotDetail returned by\n   `GET /mssql/db/snapshot/{id}`.\n * Added new field `snapshotFrequency` to `snapshotLocationRetentionInfo` field\n   of `SnapshotRetentionInfo` field of VmSnapshotSummary returned by\n   `GET /vmware/vm/{id}/snapshot`.\n * Added new field `snapshotFrequency` to `snapshotLocationRetentionInfo` field\n   of `SnapshotRetentionInfo` field of VmSnapshotDetail returned by\n   `GET /vmware/vm/snapshot/{id}`.\n * Added new field `SnapshotRetentionInfo` to FilesetSnapshotDetail returned by\n   `GET /fileset/snapshot/{id}`.\n * Added new field `SnapshotRetentionInfo` to HdfsSnapshotDetail returned by\n   `GET /hdfs/snapshot/{id}`.\n * Added new field `SnapshotRetentionInfo` to MssqlDbSnapshotSummary returned by\n   `GET /mssql/db/{id}/snapshot`.\n * Added new field `SnapshotRetentionInfo` to MssqlDbSnapshotDetail returned by\n   `GET /mssql/db/snapshot/{id}`.\n * Added new field `SnapshotRetentionInfo` to VmSnapshotSummary returned by\n   `GET /vmware/vm/{id}/snapshot`.\n * Added new field `SnapshotRetentionInfo` to VmSnapshotDetail returned by\n   `GET /vmware/vm/snapshot/{id}`.\n * Added new endpoint `GET /unmanaged_object/{id}/snapshot`. Returns summary\n   of all the snapshots for a given object.\n * Added new endpoint `GET /unmanaged_object`. Returns the summary of all the\n   objects with unmanaged snapshots.\n * Added new endpoint `GET /report/compliance_summary`. Returns the summary of\n   snapshot compliance based on a time-based requirement of at least one\n   snapshot in each 24 hour report period for each protected object.\n   This endpoint ignores the policies assigned to protected objects through SLA\n   Domains.\n * Added new endpoint `GET /cluster/{id}/node_id`. Returns the IDs of the\n   nodes in the cluster.\n * Added new endpoint `GET /role`. Returns role metadata for all roles in an\n   organization.\n * Added new endpoint `POST /role`. Create a new role.\n * Added new endpoint `GET /role/{id}`. Get role metadata and the list of\n   principals assigned to a specific role.\n * Added new endpoint `PATCH /role/{id}`. Update metadata for a specific role.\n * Added new endpoint `DELETE /role/{id}`. Delete a role.\n * Added new endpoint `GET /principal`. Get principals.\n * Added new endpoint `GET /principal/role`. Get list of roles assigned to\n   principals.\n * Added new endpoint `POST /principal/role`. Assign roles to principals.\n * Added new endpoint `POST /principal/role/bulk_revoke`. Revoke roles from\n   principals.\n * Added `DELETE /certificate/{id}` endpoint to delete a certificate.\n * Added `PATCH /cluster/{id}/security/cors` endpoint to update the current CORS\n   support configuration for a web server.\n * Added `GET /cluster/{id}/security/cors` endpoint to get the current CORS\n   support configuration for a web server.\n * Added new optional field `failoverClusterAppId` to FilesetSummary and\n   FilesetCreate in `POST /fileset`, `GET /fileset` and `PATCH /fileset/{id}`\n   endpoints to enable clustered fileset backup.\n * Added `GET /unmanaged_object/reader_object` endpoint to get all\n   unmanaged objects that are recovered from reader archival locations.\n * Added `GET /failover_cluster` endpoint to get all failover clusters.\n * Added `POST /failover_cluster` endpoint to create a failover cluster.\n * Added `GET /failover_cluster/{id}` endpoint to retrieve a failover\n   cluster by id.\n * Added `PATCH /failover_cluster/{id}` endpoint to update a failover cluster.\n * Added `DELETE /failover_cluster/{id}` endpoint to delete a failover cluster.\n * Added `GET /failover_cluster/failover_cluster_app` endpoint to get all\n   failover cluster apps.\n * Added `POST /failover_cluster/failover_cluster_app` endpoint to create a\n   failover cluster app.\n * Added `GET /failover_cluster/failover_cluster_app/{id}` endpoint to retrieve\n   a failover cluster app by ID.\n * Added `PATCH /failover_cluster/failover_cluster_app/{id}` endpoint to update\n   a failover cluster app.\n * Added `DELETE /failover_cluster/failover_cluster_app/{id}` endpoint to delete\n   a failover cluster app.\n * Added `GET /legal_hold/snapshot` endpoint to get snapshots under legal hold.\n * Added `POST /legal_hold/snapshot` endpoint to apply legal hold on a snapshot.\n * Added `GET /legal_hold/object` endpoint to get all objects with snasphot\n   under legal hold.\n * Added `POST /legal_hold/snapshot/dissolve` to dissolve legal hold from\n   snapshots.\n * Added optional field `shouldUseAgent` to `RestoreFileJobConfig`.\n   in `POST /vmware/vm/snapshot/{id}/restore_file` to specify\n   whether to use Rubrik Backup Service to restore file. Default value is true.\n * Added `America/Costa_Rica`and `America/St_Johns` as supported cluster time\n   zones.\n * Added `GET /failover_cluster/hierarchy/{id}` to get summary of a\n   failover cluster hierarchy object.\n * Added `GET /failover_cluster/hierarchy/{id}/children` to get list of\n   immediate descendant objects.\n * Added `GET /failover_cluster/hierarchy/{id}/descendants` to get list of\n   descendant objects.\n * Added `GET /job_monitoring` to get job summary information, with options\n   to filter and sort the results for protection and recovery jobs that are\n   currently running, scheduled to run or completed in the past 24 hours.\n * Added `GET /job_monitoring/summary_by_job_type` to get job summary\n   information separated by job type for all jobs that are currently running,\n   scheduled to run or completed in the past 24 hours.\n * Added `GET /job_monitoring/summary_by_job_state` to get job summary\n   information separated by job state for all running jobs, jobs that have\n   been scheduled and jobs that are complete, for protection and recovery\n   jobs in the past 24 hours.\n * Added `GET /job_monitoring/csv_download_link` which returns a link to\n   download job summary information with the same filters as the\n   `GET /job_monitoring` API.\n * Added optional field 'legalHoldDownloadConfig' to\n   'FilesetDownloadFileJobConfig', 'DownloadFileJobConfig'.\n   This is an optional argument containing a Boolean parameter to depict if\n   the download is being triggered for Legal Hold use case.\n * Added optional field isPlacedOnLegalHold to BaseSnapshotSummary.\n   The Boolean parameter specifies whether the snapshot is placed under a\n   Legal Hold.\n * Added `POST /mssql/db/{id}/browse` endpoint to list backups, which includes\n   both snapshots and logs.\n * Added `POST /mssql/db/{id}/download_files` endpoint to download a list of\n   backup files specified by time range or point in time.\n * Added `POST /mssql/db/{id}/download_files_by_id` endpoint to download a list\n   of backup files specified by ID.\n * Added `PATCH /report/config` to set the number of days for which the report\n   job instances for log jobs are retained.\n * Added ISO8601 format date as a way of specifying time in MssqlRecoveryPoint.\n * Added primaryDatabaseLogBackupFrequency parameter to the response objects\n   MssqlLogShippingSummary and MssqlLogShippingDetail.\n * Added targetInstanceName parameter to MssqlMountSummary\n * Added `POST /mssql/db/{id}/download` endpoint to download the logs/snapshots\n   required to restore a SQL database to a given recovery point.\n * Added the optional fields uid, surname, and emailAddress to the\n   GenericCsrRequest (renamed from CsrRequest) and renamed WebCsrRequest\n   to CsrRequest.\n * Added new endpoints `PATCH /oracle/db/bulk`,\n   `PATCH /oracle/host/bulk`, and `PATCH /oracle/rac/bulk` for bulk\n   updating an array of IDs with `OracleProperties`.\n * Added an optional query parameter\n   `should_apply_to_existing_snapshots` to `PATCH /sla_domain/{id}` to\n   apply the new SLA configuration to existing snapshots of data sources\n   retained by the specified SLA Domain.\n * Added an optional query parameter\n   `should_apply_to_existing_snapshots` to `PUT /sla_domain/{id}` to\n   apply the new SLA configuration to existing snapshots of data sources\n   retained by the specified SLA Domain.\n * Added optional field 'shouldForce' to 'UpdateMountConfig' in PATCH\n   vmware/vm/snapshot/mount/{id} endpoint. Use this field to forcibly power\n   down a virtual machine mounted with Storage vMotion.\n * Added a new optional field `isOracleHost` to `HostRegister` in `POST /host`.\n   and `HostUpdate` in `PATCH /host/{id}` to indicate if we should discover\n   Oracle information during registration and host refresh.\n * Added a new model `EventCsvDownloadResponse` and REST API endpoints\n   `/event/csv_download_link` for downloading CSV file for event summary\n   information in the Activity log UI page.\n * Added `GET /host/hierarchy/{id}` to get summary of a\n   host/share hierarchy object.\n * Added `GET /host/hierarchy/{id}/children` to get list of\n   immediate descendant objects.\n * Added `isInVmc` in `GET /vmware/vm/{id}` and `PATCH /vmware/vm/{id}`.\n   to return whether the virtual machine is in a VMC setup.\n * Added `pendingSlaDomain` field to `GET /vmware/vm/{id}` and\n   `PATCH /vmware/vm/{id}` to indicate a pending SLA Domain assignment\n   on the Virtual Machine.\n * Added `pendingSlaDomain` field to `GET /mssql/hierarchy/{id}`,\n   `GET /mssql/hierarchy/{id}/children`, and\n   `GET /mssql/hierarchy/{id}/descendants` to indicate a pending SLA\n   Domain assignment on the MSSQL object.\n * Added `pendingSlaDomain` field to `GET /fileset`,\n   `POST /fileset`, `GET /fileset/{id}`, and `PATCH /fileset/{id}`\n   to indicate a pending SLA Domain assignment on the Fileset.\n * Added `pendingSlaDomain` field to the objects referenced by the\n   `filesets` field in the response objects of\n   `GET /failover_cluster/hierarchy/{id}`,\n   `GET /failover_cluster/hierarchy/{id}/children`,\n   `GET /failover_cluster/hierarchy/{id}/descendants`,\n   `GET /host/hierarchy/{id}`, and `GET /host/hierarchy/{id}/children`\n   to indicate a pending SLA Domain assignment on the object.\n * Added endpoint `POST /vmware/vcenter/{id}/refresh_vm` which\n    allows refreshing metadata for a single virtual machine in a vCenter.\n * Added optional field `shouldForceFull` to the body parameter of\n   `PATCH /mssql/db/{id}` to enable requiring a full snapshot for a specified\n    SQL Server database.\n * Added `LinuxHost`, `WindowsHost` and `NasHost` to the\n   `object_type` filtering field of the `GET /event/latest` endpoint.\n\n ### Changes to V1 API in Rubrik Version 5.1.1\n ## Breaking changes:\n\n ## New features:\n * Added `has_instances` parameter to GET `/mssql/hierarchy/{id}/descendants`.\n   and GET `/mssql/hierarchy/{id}/children`. Added `hasInstances` field in the\n   response object.\n\n ### Changes to V1 API in Rubrik Version 5.1.0\n ## Deprecation:\n\n ## New features:\n * Added `GET /archive/aws/s3/{id}/account_id` endpoint to get the\n   account ID of the AWS data location.\n * Added `DELETE /authorization/cache` endpoint to clear cached authorization\n   information.\n * Added the `GET /syslog/export` endpoint to get all syslog export rules.\n * Added the `POST /syslog/export` endpoint to add a syslog export rule.\n * Added the `GET /syslog/export/{id}` endpoint to get a syslog export rule.\n * Added the `PATCH /syslog/export/{id}` endpoint to update a syslog export\n   rule.\n * Added the `DELETE /syslog/export/{id}` endpoint to delete a syslog export\n   rule.\n * Added the `POST /syslog/export/test` endpoint to test a syslog export rule.\n * Added stubs for the `GET /event/latest` endpoint to V1 to\n   facilitate a future migration from internal to V1.\n * Added stubs for the `GET /event_series/{id}` endpoint to V1\n   to facilitate a future migration from internal to V1.\n * Added stubs for the `GET /event` endpoint to V1 to facilitate\n   a future migration from internal to V1.\n * Added optional query parameter 'snappableStatus' to /vmware/vcenter,\n   /vmware/compute_cluster, /vmware/host,  /host, /mssql/instance, and\n   /windows_cluster. This parameter enables a user to fetch the set of\n   protectable objects from the list of objects visible to that user.\n * Added optional field `alias` to HostSummary, HostRegister, and HostUpdate\n   schemas. This field will allow the user to specify an alias for each host\n   which can be used for search.\n * Added `POST /archive/location/{location_id}/reader/refresh/data_sources`.\n   endpoint to refresh the metadata of a list of given data sources from\n   the given reader location.\n * Added `POST /managed_volume/snapshot/export/{id}/script` endpoint to\n   generate a script to create a directory to view all files in all channels\n   of a managed volume snapshot export.\n * Moved the `GET /blackout_window` endpoint from internal to V1.\n * Moved the `PATCH /blackout_window` endpoint from internal to V1.\n * Added `GET /certificate` endpoint to get all imported certificates.\n * Added `POST /certificate` endpoint to import a certificate.\n * Added `GET /certificate/{id}` endpoint to retrieve a certificate by id.\n * Added `PATCH /certificate/{id}` endpoint to update a certificate.\n * Added `GET /csr` endpoint to get all outstanding\n   Certificate-Signing-Requests.\n * Added `POST /csr` endpoint to generate a Certificate-Signing-Request.\n * Added 'DELETE /oracle/db/{id}/downloaded__snapshots' endpoint\n   to delete downloaded Oracle db snapshots and log snapshots.\n * Added unauthenticated endpoint `GET /saml/sso_status` to check\n   SAML SSO status. For example, we can check whether SSO is enabled or not.\n * Added optional field archivalTieringSpec to ArchivalSpecV2 to support\n   archival tiering. This enables the user to configure either Instant Tiering\n   or Smart Tiering (with a corresponding minimum accessible duration) on an\n   SLA domain with archival configured to an Azure archival location.\n * Updated endpoint /mssql/db to have a new optional query paramter,\n   indicating if backup task information should be included.\n * Added the `IoFilterSummary` object with `id`, `name`, `version`, `vendor`.\n   fields and `summary`, `releaseDate` optional fields.\n * Added `GET /vmware/computer_cluster/request/{id}` endpoint to get the details\n   of an asynchronous request that involves a VMware compute cluster.\n * Added `PATCH /vmware/computer_cluster/{id}` endpoint to update\n   the configuredSlaDomainId for a VMware compute cluster with a specific ID.\n * Added `GET /vmware/compute_cluster/{id}/io_filter` to get the ioFilters on\n   the VMware compute cluster with a specific ID.\n * Added `POST /vmware/compute_cluster/{id}/install_io_filter` endpoint to\n   install the Rubrik ioFilter to the VMware compute cluster with a specific\n   ID.\n * Added `POST /vmware/compute_cluster/{id}/uninstall_io_filter` endpoint to\n   uninstall the Rubrik ioFilter from the VMware compute cluster with a\n   specific ID.\n * Added `POST /vmware/compute_cluster/{id}/upgrade_io_filter` endpoint to\n   upgrade the Rubrik ioFilter to the latest version for the VMware compute\n   cluster with a specific ID.\n * Moved the `GET /vmware/compute_cluster` endpoint from internal to V1.\n * Moved the `GET /vmware/compute_cluster/{id}` endpoint from internal to V1.\n * Added endpoint /saml/authn_request/{idp_name} for making SAML\n * Added an optional field 'isRetentionLocked' to 'POST /sla_domain',\n   'PUT /sla_domain/{id}' and 'PATCH /sla_domain/{id}' to allow users to manage\n   the Retention Lock capabilities of an SLA Domain.\n * Added endpoint 'POST /saml/authn_request/{idp_name}' for making SAML\n   authentication request for a given ID Provider.\n * Added endpoint 'POST /saml/rubrik_metadata' for downloading Rubrik SAML\n   metadata file.\n * Added a series of new endpoints /idp_auth_domain for managing SAML\n   Id Provider integration.\n * Moved the 'connectionStatus' field from VcenterDetail to VcenterSummary.\n * Added new optional query parameters 'data_sources' and 'snapshot_ids' to\n   'GET /sla_domain' endpoint. This allows users to filter SLA Domains based\n   on whether they can be assigned to specified data sources and snapshots.\n * Changed the existing endpoints `GET /mssql/db/` `GET /mssql/instance`.\n   `GET /mssql/db/{id}` `PATCH /mssql/db/{id}` `GET /mssql/db/snapshot/{id}`.\n   `GET /mssql/instance/{id}` `GET /mssql/instance/{id}` to return an\n   unprotectable reason as a string in the 'unprotectableReason' field instead\n   of a JSON struct.\n * Added a `PUT /host/certificate/{id}` endpoint to update the\n   certificate of the given host\n * Added `GET /vcd/vapp/template/snapshot/{snapshot_id}/export` to get\n   available options for a vApp template snapshot export.\n * Added `POST /vcd/vapp/template/snapshot/{snapshot_id}/export` to queue\n   export of a vApp template snapshot.\n * Added continuous data protection state for each VMware virtual machine.\n * Added optional field 'isIoFilterInstalled' to vCenter summary. Returns true\n   if any Rubrik IO filters are installed on any compute clusters that are\n   a part of the vCenter.\n * Added optional field `cloudStorageTier` to `BaseSnapshotSummary`, to indicate\n   the current storage tier of the archived copy of a snapshot.\n * Added `POST ` /vmware/vm/cdp endpoint to get live CDP info for a list of\n   virtual machines.\n * Added `POST ` /vmware/vm/cdp_state endpoint to get CDP state info for a list\n   of virtual machines.\n * Added the optional field isEffectiveSlaDomainRetentionLocked to\n   FilesetSummary. The field is a Boolean that specifies whether the effective\n   SLA Domain of a fileset is retention locked.\n * Added optional field isEffectiveSlaDomainRetentionLocked to `Snappable`.\n   The parameter depicts if the effective SLA domain for the data source is\n   a Retention Lock SLA Domain.\n * Added optional field isConfiguredSlaDomainRetentionLocked to SlaAssignable.\n   The parameter depicts if the configured SLA domain for the object is a\n   Retention Lock SLA Domain.\n * Added optional parameter `ignore_connection_status` to `GET /vmware/vcenter`.\n   to skip calculating connection status.\n * Added required fields: isCdpEnabled(type: boolean) and cdpState(type:\n   CdpState Enum) to VirtualMachineDetails.\n * Moved the GET `/mssql/hierarchy/{id}/descendants` and\n   GET `/mssql/hierarchy/{id}/children` endpoints from internal to v1.\n   Added the `is_relic`, `is_live_mount` `is_clustered`, and\n   `is_log_shipping_secondary`.\n   parameters. Changed acceptable values of `object_type` and `sort_by`.\n   parameters. Added `hasPermissions`, `isInAvailabilityGroup`,\n   `descendantSlaDomains`, `instanceChildren`,\n   `unprotectableReasons`, `isLiveMount`, `isLogShippingSecondary`,\n   `hostStatus`, `cbtEnabled`, `cbtEffectiveStatus`, `isClustered` and\n   `clusterInstanceAddress` fields in the\n   response object. Removed `replicaCount` field in the response object.\n   Added support for returning non-availability databases.\n   Changed `object_type` query parameter to take a comma-separated list of\n   object types.\n   Added the GET `/mssql/hierarchy/{id}` endpoint to get a specific hierarchy\n   object.\n * Added the POST `/mssql/sla_domain/assign` endpoint to assign SLA properties\n   to SQL Server objects.\n * Added isRetentionLocked to MssqlInstanceSummary.\n\n ### Changes to V1 API in Rubrik Version 5.0.3\n ## Deprecation:\n\n ## New features and improvements:\n * Added a new optional field 'oracleQueryUser' to HostRegister, HostUpdate\n   and HostDetail objects, for setting the Oracle username for account with\n   query privileges on the host. This applies the following endpoints:\n   POST /host/bulk, PATCH /host/{id}, and GET /host/{id}.\n\n ### Changes to V1 API in Rubrik Version 5.0.2\n ## Deprecation:\n\n ## New features and improvements:\n * Added `GET /oracle/db/{id}/restore_estimate` endpoint to provide an\n   estimate of the amount of data that must be downloaded for a restore\n   operation.\n * Introduced optional field `logicalSize` to `VirtualMachineDetail`. This\n   field gives the sum of logical sizes of all the disks in the virtual\n   machine.\n * Added optional parameter `ignore_connection_status` to\n   `GET /vmware/vcenter/{id}`. Set this parameter to skip calculating\n   connection status.\n\n ### Changes to V1 API in Rubrik Version 5.0.1\n ## Deprecation:\n\n ## New features and improvements:\n * Added `GET /cluster/{id}/security/encryption` endpoint to provide encryption\n   at rest status of the cluster.\n * Added `GET /vmware/host/{id}/datastore` endpoint to get the details\n   of datastores for an ESXi host.\n * Added `POST /vmware/vm/mount/{id}/relocate` endpoint to migrate datastore\n   for a virtual machine from Live Mount or Instant Recovery.\n * Added `America/Santiago`, `Australia/Adelaide` and `Australia/Brisbane` as\n   supported cluster time zones.\n\n ### Changes to V1 API in Rubrik Version 5.0.0\n ## Deprecation:\n * Deprecating query paramter `hostname` of `GET /host` and response property\n   `hostname` of `GET /host`, `POST /host`, `PUT /host/certificate/{id}`,\n   `GET /host/{id}`, `PATCH /host/{id}`, and `POST /host/{id}/refresh`.\n   Use `name` instead. Support for `hostname` is present in v1 and removed in v2.\n * Deprecating response property `isArchived` of `GET /mssql/db`,\n   `GET /mssql/db/{id}`, and `PATCH /mssql/db/{id}`. Use\n   `isDeleted` instead. Support for `isArchived` is present in v1 and removed in v2.\n * Deprecating parameter `datastoreName` of `Post /vmware/vm/snapshot/{id}/mount`.\n\n ## New features:\n * Added a new PUT endpoint to /ldap_service/{id}.\n * Added /cluster/{id}/snmp_mib_link endpoint.\n * Added a new optional field 'oracleSysDbaUser' to /host/{id} POST endpoint\n   during register host for setting the Oracle username for account with sysdba\n   privileges on this host.\n * Added a new optional field 'oracleSysDbaUser' to /host/{id} endpoint for\n   changing the Oracle username for account with sysdba privileges on this\n   host.\n * Added a new optional field 'mfaServerId' to /ldap_service endpoint for\n   associating a configured MFA server.\n * Added a new /sla_domain endpoint with the same functionality as /v1, but\n   added support for weekly and quarterly time units and modify the config of\n   monthly and yearly.\n * Added a new optional field 'isArrayEnabled' to 'FilesetTemplateCreate'\n   for creation of storage array-enabled fileset templates. We also include\n   this new field in 'FilesetTemplateDetail'.\n * Added a new optional field 'arraySpec' to 'FilesetCreate' for\n   creation of storage array-enabled filesets. We also include\n   this new field in the responses of the `GET /fileset/{id}` and\n   `GET /fileset` endpoints.\n * Added ability to use the /host/{id} endpoint to specify a host level\n   setting for enabling or disabling CBT backups of SQL Server databases,\n   along with new optional fields 'mssqlCbtEnabled', 'mssqlCbtEffectiveStatus'\n   and 'mssqlCbtDriverInstalled'.\n * Added ability to use the /host/{id} endpoint to instruct the Rubrik cluster\n   to remove the CBT driver from a Windows host that has CBT backups of SQL\n   Server databases disabled.\n * Added new optional field 'isPassthrough' to 'POST /fileset' endpoint to\n   indicate if we want to take a direct archive backup.\n * Added a new field unprotectable_reasons to GET /mssql/db/{id} and\n   GET /mssql/instance/{id}. This field keeps track of the reasons that a\n   SQL Server database or instance cannot be protected by Rubrik.\n * Added ability to use the /host/{id} endpoint to specify a host level\n   setting for enabling or disabling VFD backups of volumes on Windows hosts.\n * Added ability to use the /host/{id} endpoint to instruct the Rubrik cluster\n   to remove the VFD driver from a Windows host that has VFD backups of volumes\n   disabled.\n * Added new optional field 'isOverwrite' to ExportMssqlDbJobConfig for\n   'POST /mssql/db/{id}/export' endpoint to enable overwriting an existing\n   database while using the export operation.\n * Added a new optional field 'allowOverwrite' to the\n   'POST /mssql/db/{id}/export' endpoint to allow overwriting an existing\n   database during the export.\n * Added a new field 'hasAttachingDisk' to 'GET /vmware/vm/snapshot/mount' and\n   'GET /vmware/vm/snapshot/mount/{id}' that indicates to the user whether\n   this is an attaching disk mount job.\n * Added a new field 'attachingDiskCount' to 'GET /vmware/vm/snapshot/mount'\n   and 'GET /vmware/vm/snapshot/mount/{id}' that indicate to the user how many\n   disks are attached.\n * Removed optional field 'clusterInstanceAddress' from\n   'PATCH /mssql/instance/{id}' endpoint since host-centric discovery for\n   cluster instances eliminates the need to edit the instance address.\n * Added new field `missedSnapshotTimeUnits` in `MissedSnapshot`.\n * Added new field 'vmxFileContent' in getSnapshotDetail\n * Added new optional fields 'organizationId' and 'organizationName' to\n   `/host/{id}` and `/host` endpoints to get the organization a host is\n   assigned to due to Envoy.\n * Added new field 'vmwareTagList' in getSnapshotDetail\n * Added new endpoint GET /cluster/{id}/certificate to get the cluster cert.\n * Added new optional field PATCH /vmware/vm/{id} to indicate whether or not\n   to refresh the in-memory cache after updates to a virtual machine record.\n * Added new field 'shouldRecoverTags' in MountSnapshotJobConfigV1\n * Added new field 'shouldRecoverTags' in InstantRecoveryJobConfig\n * Added new field 'shouldRecoverTags' in ExportSnapshotJobConfig\n * Added a new optional field 'operating_system' to 'GET /host'.\n * Added a new optional field 'apiEndpoint' to 'NasBaseConfig'.\n * Added new optional field 'enableSymlinkResolution' to FilesetSummary in\n   'POST /fileset', \"GET /fileset\" and \"PATCH /fileset/{id}\" endpoints to\n   indicate if we want to resolve symlinks during metadata scan.\n * Added new optional field 'enableHardlinkSupport' to FilesetSummary and\n   FilesetCreate in 'POST /fileset', \"GET /fileset\" and \"PATCH /fileset/{id}\"\n   endpoints to enable recognition and deduplication of hardlinks in\n   fileset backup.\n\n ## Improvements:\n * Added optional 'apiToken' and 'apiEndpoint' fields to NasConfig to support\n   Pure FlashBlade devices.\n * Added a new field 'guestOsName' to GET /vmware/vm. This allows users to\n   filter virtual machines based on the guest operating system name.\n * Enhanced GET /vmware/vm/snapshot/{id} response by adding disk details\n   such as fileName and deviceKey.\n * Added isMountAllowed field to the response of GET\n   /mssql/db/{id}/recoverable_range. This helps identify which recoverable\n   ranges support Live Mount, which is affected by whether a database snapshot\n   contains filestreams.\n * Added optional query parameters limit and offset to support pagination for\n   GET /mssql/db endpoint.\n * Added optional query parameters sortOrder and sortBy to enable users to\n   sort the results of GET /mssql/db endpoint by effectiveSlaDomainId and name.\n\n ### Changes to V1 API in Rubrik Version 4.2\n ## Breaking changes:\n * The input field OperatingSystemType value `Linux` is replaced by `UnixLike`.\n   in FilesetTemplateCreateDefinition, used by POST /fileset-template, and\n   in FilesetTemplatePatchDefinition, used by PATCH /fileset_template/{id}.\n * The input field operating_system_type value `Linux` is replaced by `UnixLike`.\n   in GET /fileset-template and GET /host.\n\n ## New features:\n * Added a new /ldap_service endpoint for managing Active Directory integration.\n * Added a new optional field 'nasBaseConfig' to GET /api/v1/host. This field\n   allows NAS (Isilon/NetApp) api credential to be displayed and edited.\n * GET /host/{id}/search now returns search results for filesets, Windows volume\n   groups, and storage array volume groups belonging to the host. Previously,\n   the endpoint would only return fileset search results.\n * Added endpoints for actions related to log shipping configurations:\n   POST /mssql/db/{id}/log_shipping to create, GET /mssql/db/log_shipping to\n   query, GET /mssql/db/log_shipping/{id} to retrieve individual details,\n   DELETE /mssql/db/log_shipping/{id} to delete, and POST\n   /mssql/db/log_shipping/{id}/reseed to reseed an unhealthy secondary\n   database.\n * Added `Africa/Johannesburg`, `Africa/Lagos` and `Africa/Nairobi` as\n   supported cluster time zones.\n ## Improvements:\n * Added 2 new optional fields `apiHostname` and `zoneName` to POST /host\n   and GET /host. These fields allow different zones to be configured for\n   Isilon NAS.\n * Added a new field 'geolocation' to GET /cluster/{id} and PATCH /cluster/{id}.\n   These allow users to view and modify the geolocation of the cluster,\n   respectively.\n * Added a new field `guestOsType` to the `VirtualMachineDetail`.\n   object used in response of `GET /vmware/vm/{id}`.\n * Added an optional organizationId field to the HostRegister request in POST\n   /host to allow users with the global admin RBAC role to add a host to an\n   organization specified by the value of the organizationId field.\n * Added canLiveMount field to the responses of `GET /mssql/db/snapshot/{id}`.\n   and `GET /mssql/db/{id}/snapshot`.\n * Added an optional field `agentStatus` to `VirtualMachineSummary` object used\n   in response of `GET /vmware/vm` endpoint. This allows user to check the\n   Rubrik Backup Service connection status of the corresponding VMware VM.\n * Added the `POST /vmware/vm/{id}/register_agent` endpoint.\n * Added a new field 'createDatastoreOnly' to POST\n   /vmware/vm/snapshot/{id}/mount. This allows user to mount snapshot to vmware\n   datastore only, without create a virtual machine.\n * Added a new field `numWindowsVolumeGroups` to the `SlaDomainDetail` and\n   `SlaDomainSummary` objects used in response to `GET /sla_domain` endpoints.\n * Added new optional field 'shouldRefreshCacheAfterUpdate' for PATCH\n   /vmware/vm/{id} to indicate whether or not to refresh the in-memory cache\n   after updates to a virtual machine record.\n\n ### Changes to V1 API in Rubrik Version 4.1\n\n ## Breaking changes:\n * The 'allowedBackupWindow' and 'firstFullBackupWindow' input field for\n   /sla_domain now take the cluster time zone instead of UTC.\n\n ## New features:\n * Added POST /host/{id}/refresh endpoint to refresh hosts without\n   registering them again\n * Added GET /fileset/snapshot/{id} endpoint to retrieve details of a\n   fileset snapshot.\n * Added POST /mssql/db/{id}/log_backup endpoint for taking on-demand\n   log backup of SQL Server databases.\n * Added a new optional query parameter 'is_agentless' to\n   GET /windows_cluster. This allows users to filter all clusters that\n   do not have any hosts with Rubrik connectors installed. If this\n   parameter is omitted, all clusters are returned.\n * Added a new field 'isAgentless' to GET /windows_cluster. This indicates\n   whether all the hosts on this windows cluster do not have Rubrik connector\n   installed. If even one host has Rubrik connector installed, this will\n   be set to false.\n * Added a new optional 'organization_id' query parameter on POST /session.\n   This allows users to specify the organization to which they intend to\n   authenticate. If this parameter is omitted, an organization is chosen\n   automatically.\n * Added a new 'organizationId' field to the response on POST /session. This\n   indicates the organization to which the user has authenticated.\n * Added a new field 'moid' on GET /vmware/vm. This allows users to search\n   VMWare VMs by Managed Object ID. The list of results of the call can now\n   additionally be sorted in ascending/descending order by moid.\n * Added new fields 'replicas' and 'availabilityGroupId' on GET /mssql/db\n   and GET /mssql/db/{id}. If a database is an availability database,\n   it will have some number of replicas, which are copies of the database\n   running on different instances. Otherwise, there will only be one\n   replica, which represents the single copy of the database. The field\n   'availabilityGroupId' will be set only for availability databases\n   and points to the availability group of the database. Also deprecated\n   several fields on these endpoints, as they should now be accessed via\n   the 'replicas' field.\n * Added a field 'cloudInstantiationSpec' on GET /vmware/vm and PATCH\n   /vmware/vm/{id} to allow enabling/disabling/updating specs for automatic\n   conversion to cloud image on a per VM basis\n * Added a new optional query parameter 'availabilityGroupId' to GET /mssql/db,\n   in order to filter databases by their availability group ID.\n * Added a new field 'timezone' to GET /cluster/{id} and PATCH /cluster/{id}.\n   These calls show and change, the current time zone setting of the cluster.\n * Add a new field 'ignoreErrors' to POST /vmware/vm/snapshot/{id}/restore_file\n   that will let job to ignore file errors during restore jobs.\n * Added `Asia/Kolkata` and `Asia/Kathmandu` as supported cluster time zones.\n\n ### Changes to V1 API in Rubrik version 4.0\n\n New features:\n * Added a new field 'name' on GET /sla_domain. This allows users to search\n   SLA Domains by name. Users can also sort the SLA Domain summary results\n   in ascending/descending order by name\n * The Rubrik cluster generates a unique ID for each virtual machine when a\n   vCenter Server is added. When a virtual machine changes to another vCenter\n   Server or unregisters and registers with the same vCenter Server, a new\n   unique ID is generated for that virtual machine. When this happens, the\n   virtual machine object associated with the original ID becomes a relic.\n   In this release we have added the option conflictResolutionAuthz to\n   add/edit vCenter endpoints of the Rubrik REST APIs. This option can take\n   either 'AllowAutoConflictResolution' to authorize the linking of relic\n   virtual machine objects with the current virtual machine object of a\n   specific virtual machine, and makes the collective snapshot history\n   available through the current object. Or it can take 'NoConflictResolution'\n   to not allow linking. Default value is 'NoConflictResolution'.\n * Introduced endpoints for SQL Server Live Mounts: POST /mssql/db/{id}/mount,\n   GET /mssql/db/mount, GET /mssql/db/mount/{id}, and\n   DELETE /mssql/db/mount/{id}. These allow users to create, query for, and\n   delete Live Mounts for SQL Server databases.\n * Added the isLiveMount field to the response of GET /mssql/db. Added an\n   optional is_live_mount query parameter to filter by this field.\n * Added links field to the paginated responses of\n   GET /vmware/vm, /vmware/vm/mount and /fileset endpoints. This allows users\n   to navigate between pages by following the href in links.prev and links.next.\n * Introduced optional caCerts parameter for the vCenter post/put/patch\n   endpoints to specify trusted CA certs to use when connecting to a vCenter\n   server and associated ESX hosts.\n * Modified PATCH /mssql/instance/{id} endpoint to support SQL db\n   auto-protection, added fields configuredSlaDomainId,\n   logBackupFrequencyInSeconds, logRetentionHours, and copyOnly to the PATCH\n   request, as well as configuredSlaDomainId, configuredSlaDomainName,\n   logBackupFrequencyInSeconds, logRetentionHours, and copyOnly to the GET and\n   PATCH responses.\n * Added GET /vmware/vcenter/{id} endpoint to allow fetching details of a\n   single vCenter server, including its refresh and delete status.\n * Introduced optional parameter keepMacAddresses to\n   POST /vmware/vm/snapshot/{id}/mount, /vmware/vm/snapshot/{id}/export, and\n   /vmware/vm/snapshot/{id}/instant_recovery endpints.\n   This allows new VMs to have the same MAC address as their source VMs.\n * Introduced optional parameters offset and limit to support\n   pagination for Browse end-point.\n * Added `nodeId` to `AsyncRequestStatus` to improve debugging job failures.\n\n\n ### Changes to V1 API in Rubrik version 3.2\n\n New features:\n * Added an option to preserve the virtual machine moid during instant recovery.\n   Use this option cautiously. It will permanently overwrite the source\n   virtual machine. The source virtual machine cannot be recovered if the\n   operation fails. It will not create a new virtual machine and rename\n   the original one so we could fall back to the original in case of a failure\n   in the process. This is not exposed in the Web UI and the API user should\n   be careful to not destroy the original virtual machine by accident.\n * Introduced shareId into /fileset endpoints to support\n   the creation of filesets based on network shares.\n * Introduced optional config parameter for all on demand\n   snapshot endpoints. The config parameter includes an optional slaId field.\n   The policies of the specified SLA Domain determine the retention of backups\n   on the local Rubrik cluster, the retention target, and the archival location.\n * Introduced optional parameters to endpoint /mssql/db/{id}/export,\n   so that physical filenames and logical filenames can be changed\n   for exported databases. These two parameters are newFilename and\n   newLogicalName.\n * Introduced optional config parameter for the VM patch endpoint\n   (PATCH /vmware/vm/{id}) to specify a guest credential for a\n   specific VM.\n * Introduced optional query parameters to endpoint /host, to\n   support infix searching by hostname and sort order of results.\n * Introduced slaId and slaName field to all snapshot summary/details object.\n   These fields specify the SLA Domain object that is associated with the\n   snapshot.\n\nBug Fixes:\n * Made path parameter required in GET /fileset/snapshot/{id}/browse\n   and GET /vmware/vm/snapshot/{id}/browse. Previously, an error was\n   thrown when path wasn't passed in. This solves that bug.\n\n ### Changes to V1 API in Rubrik version 3.1\n Initial GA release\n\n# Overview #\nThe Rubrik REST API provides a means to work with Rubrik clusters and Rubrik Edge virtual appliances using text-based representations of the resource objects that are managed by the Rubrik software.\n\nIn its simplest form, the RESTful architecture used by the Rubrik REST API has the following workflow:\n1. Client authenticates with the Rubrik REST API server and starts a session.\n2. Client sends an HTTP request to the URI for a resource object.\n3. Server handles the request and sends an HTTP response with a JSON formatted response body.\n\nThis overview section provides a basic description of the HTTP requests and responses used with the Rubrik REST API. The [Authentication](#section/Authentication) section provides information about how a client authenticates with the Rubrik REST API server.\n\n## Documentation conventions\n\nThe descriptions in this documentation use 'Rubrik cluster' to refer to both Rubrik clusters and Rubrik Edge virtual appliances.\n\nThe documentation uses a dollar symbol to indicate a variable in body text and code samples. Some examples:\n* `$cluster_address` to represent a Rubrik cluster IP or resolvable host name\n* `$snapshot_id` to represent the ID of a specific snapshot\n* `$request_id` to represent the ID of a specific asynchronous request\n\nTo shorten the path shown in a code sample, the documentation sometimes replaces a longer variable form with the variable form `{id}`. This variable form represents the `id` value for an associated member string in a response body or request URL.\n\nThe documentation use the term 'snappable' to refer to all objects that have data that can be protected by a Rubrik cluster or a Rubrik Edge appliance. For example, all of the following are 'snappables':\n* Virtual machines\n* File systems\n* SQL Server databases\n\n## Versioning\n\nThe Rubrik REST API structures the request URL to include the version of the API. This ensures that backwards incompatible improvements in a new version are not unintentionally used with an earlier version of the API.\n\nThe URL of a request includes a segment that identifies the version of the API. In the URL, the version segment always follows immediately after the Rubrik REST API server name or IPv4 address.\n\nFor example, for a Rubrik cluster with the server address `$cluster_address` a request to the cluster endpoint for Rubrik REST API v1 would look like this:\n`https://$cluster_address/api/v1/cluster`\n\nIn this URL, the `v1` represents the version number for Rubrik REST API v1.\n\nThe Rubrik REST API increments the version number when the new version includes a change that is not backward compatible.\n\nExamples of changes that are not backward compatible include:\n* Resource type removed\n* Required parameter added to an existing resource type\n* Required parameter removed from an existing resource type\n* Renamed resource or parameter\n* Authentication requirement added for a previously unauthenticated resource\n\nWhen the Rubrik REST API has changes that are not backward compatible, those changes appear in a new version. For example, incompatible changes to v1 appear in v2. The Rubrik REST API server makes v2 endpoints available on the path: `https://$cluster_address/api/v2/`. The Rubrik REST API server continues to provide the v1 endpoints on the path: `https://$cluster_address/api/v1/`.\n\n### Changes within a version\n\nBackward compatible changes can be added to the Rubrik REST API as part of an update of the Rubrik CDM software on a Rubrik cluster or Rubrik Edge appliance. When this occurs, the version number remains the same and the URL segment that identifies the API version does not change. The [Changelog](#section/Changelog) that is provided in the docs for each version of the Rubrik REST API describes the changes that are made within that version.\n\nExamples of backward compatible changes include:\n* New API resource added\n* New optional request parameters added to existing resources\n* New properties added to existing responses\n\n## Architecture\n\nThe Rubrik REST API architecture centers around logical entities called *resource objects*. Resource objects can be discrete entities or can contain a hierarchy of other, dependent, resource objects. A dependent, or child, resource object is referenced through the parent object.\n\nFor example, a virtualization environment is a resource object that contains virtual machines as child resource objects. The virtual machines, in turn, contain snapshots as child resource objects. To address this hierarchy, the path to a snapshot must include the parent objects.\nAs shown here those parent objects are the virtualization environment (`vmware`) and the virtual machine (`vm`): `/vmware/vm/snapshot`.\n\nWhen a request addresses a specific resource object the path must include the  `id` of that specific object.\n\nFor example, to address a specific snapshot with the `id` value of `123-456` the path would be: `/vmware/vm/snapshot/123-456`.\n\nThe full URL for the request would be: `https://$cluster_address/api/v1/vmware/vm/snapshot/123-456`\n\nThe path in this example points to a specific snapshot with the `id` value of `123-456`.\n\nThe `id` is an opaque value which is generated by the Rubrik REST API. It does not follow any specific format.\n\n### API base path\n\nEach endpoint in the Rubrik REST API exists on one of two possible base paths:\n* `https://$cluster_address/api/v1/`\n* `https://$cluster_address/api/internal/`\n\nThe `/api/v1` base path provides the most commonly used endpoints. Rubrik considers these endpoints to be stable. Rubrik designs new releases of the Rubrik REST API to provide as much backward compatibility for these endpoints as possible. After an upgrade to a new version of the Rubrik CDM software, or to a new version of the Rubrik REST API, existing calls to endpoints on the `/api/v1` base path will normally continue to work.\n\nThe primary purpose of the `/api/internal` base path is to provide endpoints that are used by the Rubrik cluster. These endpoints are *internal* in the sense that the Rubrik CDM software uses them to provide a wide variety of cloud data management features. The evolution and improvement of the Rubrik CDM software can cause changes to these endpoints, removal of these endpoints, or addition of new `/api/internal` endpoints. Rubrik does not attempt to make the `/api/internal` endpoints backward compatible.\n\n### Requests\n\nTo perform a task, the Rubrik REST API uses an HTTP request. Most requests perform one of these actions:\n* Get an instance of an object from a list\n* Add an instance of an object to a list\n* Perform an operation on an object using the `id` of the object.\n\nThe following table describes the HTTP method and endpoint excerpts for some typical HTTP requests.\n\n**Note:** The endpoints shown here would be appended to the base URL: `https://$cluster_address/vmware`.\n\n| Method | Endpoint | Description |\n| ------ | --- | ----------- |\n| GET | `/vm/snapshot` | Returns a list of snapshots. |\n| POST | `/vm/snapshot` | Creates a new snapshot resource object. |\n| GET | `/vm/snapshot/{id}` | Returns information about the snapshot that is identified by `id`. |\n| PATCH | `/vm/snapshot/mount/{id}` | Changes the power status of the mounted snapshot that is identified by `id`. |\n| PUT | `/vcenter/{id}` | Provides a request body with a complete update of the properties of the vCenter Server object that is identified by `id`. |\n| DELETE | `/vm/snapshot/{id}` | Deletes the snapshot that is identified by `id`. |\n| GET | `/vm/{id}/missed_snapshot` | Returns the value of `missed_snapshot` for a snapshot that is identified by `id`. |\n| POST | `/vm/snapshot/{id}/mount` | Performs a `mount` operation using the snapshot that is identified by `id`. |\n\n#### Reserved ID alias\n\nThe alias `me` can be used with some endpoints as a shorthand replacement for the current, or local, value of that resource object type. For example, for the resource object type `/cluster` the alias `me` can be substituted for the `id` of the Rubrik cluster that is hosting the current session. For the resource object type `/session` the alias `me` can be substituted for the `id` of the current session.\n\nIn filters, use the alias `local` to refer to the Rubrik cluster that is hosting the current session.\n\n#### Timestamp\n\nThe Rubrik REST API uses a timestamp to express all time values. The timestamp meets the standards of ISO 8601 and uses Coordinated Universal Time (UTC). Timestamps take the form: YYYY-MM-DDTHH:MM:SSZ, with YYYY for the four digit year value, MM for the two digit month value, DD for the two digit day of the month value, HH for the two digit hour value using a 24-hour clock, MM for the two digit minute value, and SS for the two digit second value. The T stands for time and the Z stands for Zulu time, another name for UTC.\n\n**Example:** Timestamp in a JSON-formatted response body\n\n```bash\n{\n  \"createdTimestamp\": \"2016-02-11T18:02:24Z\"\n}\n```\n\n### Responses\n\nThe Rubrik REST API server responds to all requests by sending an HTTP response message. The response contains a status code and, when appropriate, a JSON object in the response body.\n\n#### Status codes\n\nThe Rubrik REST API server includes an HTTP status code with every response. The following table describes the status codes supported by the Rubrik REST API server.\n\n| Status code | Description |\n| ----------- | ----------- |\n| 200&nbsp;OK | Request succeeded. Not used for a DELETE request, or for a POST request that creates a resource. |\n| 201&nbsp;Created | POST request to create a resource object succeeded. |\n| 202&nbsp;Accepted | Request was successfully accepted for further processing. |\n| 204&nbsp;No&nbsp;Content | Request succeeded and the response body is empty. Used for successful DELETE requests and for successful POST requests that do not return content. |\n| 400&nbsp;Bad&nbsp;Request | Request failed because it was malformed. The request may be garbled, or it may be missing required parameters. |\n| 401&nbsp;Unauthorized | The requestor has insufficient authorization to perform the requested action. |\n| 403&nbsp;Forbidden | The requested action is blocked in the current context. |\n| 404&nbsp;Not&nbsp;Found | The request references a resource object that is unknown to the Rubrik REST API server. |\n| 415&nbsp;Unsupported Media Type | The HTTP header of the request specifies a media type that is not supported by the Rubrik REST API server. |\n| 422&nbsp;Unprocessable Entity | The request specifies a correct media type and contains correct syntax but cannot be processed because of semantical errors. |\n| 500&nbsp;Internal Server Error | The Rubrik REST API server encountered an unhandled error. |\n| 503&nbsp;Service Unavailable Error | The Rubrik REST API server is temporarily unavailable. |\n\n#### Response body\n\nThe JSON object included in a response body can contain members (`{string : value}`) and arrays (`[elements]`). Also, members and arrays can be nested within members and arrays.\n\nWhen a response includes a resource object, the object always includes an `id` member in the form `id : $id`. The value of the `id` member is the unique ID of the resource.\n\nWhen a response includes a large array (or list) of elements, the Rubrik REST API server encloses the array in a `ListResponse` structure. The `ListResponse` structure breaks a lengthy array into 'pages' of information to make the information easier to manage. Refer to 'Working with lists' for information about managing arrays with large numbers of values.\n\n#### Status code 400 responses\n\nThe Rubrik REST API server sends a response containing the HTTP status code '400 Bad Request' when the server cannot process the request. This can be caused by malformed request syntax, invalid request message framing, or deceptive request routing.\n\nThe Rubrik REST API server returns a '400 Bad Request' when:\n* Request does not conform with the format specified in OpenAPI definition files. For example, the request is missing required fields.\n* Request is malformed. For example, the request has a malformed `id`.\n* Request contains unsupported `enum` values.\n\n#### Status code 422 responses\n\nThe Rubrik REST API server sends a response containing the HTTP status code '422 Unproccessable entity' when the request is syntactically correct but has semantic errors.\n\nFor example, when a request refers to an archival location that is not available. Although the request is properly formed, the Rubrik REST API server cannot act on the request because of the missing archival location, and the server returns '422 Unproccessable entity'.\n\nThe Rubrik REST API server also returns '422 Unproccessable entity' when invalid credentials are submitted during login. In that situation, the request may be correctly formed but the action cannot be completed by using the supplied values.\n\nThe following table describes the members of a '422 Unproccessable entity' response object.\n\n| Member | Optional | Description |\n| ------ | --- | ----------- |\n| `type` | No | Error category. Possible values include: vcenter_error, oracle_error, rubrik_error |\n| `message` | No | Plain text explanation of the cause of the error. |\n| `code` | Yes | A short text string representing the cause of the error. |\n| `param` | Yes | The request member that is the source of the error, such as `backup_window`. |\n\n## Working with lists\n\nWhen a request returns a large list of elements, the response array can be encapsulated within a `ListResponse` object. The `ListResponse` object is a pagination structure for the elements in the response array. The `ListResponse` object allows the response array to be addressed through smaller subsets of the array, or 'pages'.\n\nTo work with a `ListResponse` object, form a request that calls for a specific page of the results by specifying an offset value and a limit. The response includes the elements from the list starting at the offset value and continuing to the limit. When the limit is very large, or unspecified, the Rubrik REST API server returns as many elements as can be handled by the available memory.\n\nThe `ListResponse` object consists of the members described in the following table.\n\n| Member | Optional | Description |\n| ------ | --- | ----------- |\n| `hasMore` | No | Indicates whether the array contains elements that are not provided by the current response. `true` if more elements are available for the original request and `false` if the last element is in the current response. |\n| `data` | No | An array of the requested elements. Can be all or some of the elements requested. The elements can be members, arrays, or objects. |\n| `total` | Yes | Total number of elements. |\n| `links` | Yes | When `hasMore` is true, provides a request URL for the next page of results. When appropriate, also provides a request URL for the previous page of results. The request URLs provided by `links` retain the query parameters from the original request. For example, a request URL would retain a value specified by `limit` and a value specified by `search`. The exception to this is the value specified by `offset`, which the Rubrik REST API server uses to specify next and previous pages. |\n\nControl the contents of a `ListResponse` object by including the following optional query parameters with the original request:\n* `limit`\nDefines the maximum number of a elements to include in the `data` array of the response. Available memory may prevent the return of all elements for very large `limit` values. When that occurs, the response includes `\"hasMore\": true`.\n* `offset`\nIndex reference point to use when determining the elements to include in a response. Include the next element after the index number specified by `offset`. The default value is `0`, which means the list page that is provided in the response starts with first element in the list.\n\nFor example, if the total number of elements in response to a query are 100, and the request includes the following query parameters: `limit=10` and `offset=30`, then the response will include a list page with elements 31-40.\n\nWhen the `ListResponse` object provides `next` and `prev`, use the URL specified by `next` to request the next page of elements or use the URL specified by `prev` to request the previous page of elements.\n\n**Example:** Request for all snapshots from a Rubrik cluster\n\nThe initial request uses the query parameter `limit=1`.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/vm/snapshot?limit=1\"\n```\n\nThe response returns the first element and `\"hasMore\": true` indicates that more than one snapshot meets the request.\n\n```bash\n{\n  \"hasMore\": true,\n  \"status\": \"RUNNING\",\n  \"data\": [\n    {\n      \"id\": \"1\",\n      \"name\": \"Windows2012\"\n    }\n  ],\n  \"links\": {\n    \"next\": {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vm/snapshot?limit=1&offset=1\"\n    }\n  }\n}\n\n```\n\nTo obtain the next element, the request is reissued with the query parameters set to: `limit=1&offset=1`. This could also be achieved by using the URL specified by `next` to request the next page.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/vm/snapshot?limit=1&offset=1\"\n```\n\nThe response returns the second element in the array. Since there are elements before and after the element in the response, the `links` member contains both a `next` request URL and a `prev` request URL.\n\n```bash\n{\n  \"hasMore\": false,\n  \"status\": \"RUNNING\",\n  \"data\": [\n    {\n      \"id\": \"2\",\n      \"name\": \"Windows2016\"\n    }\n  ],\n  \"links\": {\n    \"prev\": {\n       \"href\": \"https://$cluster_address/api/v1/vmware/vm/snapshot?limit=1&offset=0\",\n      \"rel\": \"prev\"\n    },\n    \"next\": {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vm/snapshot?limit=1&offset=2\",\n      \"rel\": \"next\"\n    }\n  }\n}\n```\n\n## Asynchronous requests\n\nThe Rubrik REST API server uses asynchronous (async) API requests for tasks that take longer to run. By using async requests the Rubrik REST API server avoids blocking the requestor from performing other tasks while the async tasks run.\n\nThe response to an async request includes a task object in the response body. The following table describes the members of a task object.\n\n| Member | Optional | Description |\n| ------ | --- | ----------- |\n| `id` | No |  ID assigned to the task.  |\n| `status` | No |  Status of the task: 'RUNNING', 'SUCCEEDED', 'CANCELED', or 'FAILED'.   |\n| `error` | No | Message describing reason for canceled or failed task, or 'None'. |\n| `startTime` | Yes | Timestamp when the Rubrik cluster schedules the task. |\n| `endTime` | Yes | Timestamp when the task ends. |\n| `progress` | Yes | Percentage of the task that is complete. |\n| `links` | No | Polling request array that provides information about how to poll the task. |\n\nThe following table describes the polling request array in the `links` member.\n\n| Member | Optional | Description |\n| ------ | --- | ----------- |\n| `href` | No | URL to send requests to when polling the task. |\n| `rel` | No | Provides a value of 'self' to indicate that the array refers to the resource represented by the parent JSON object. |\n\nWhen an async task is completed the Rubrik REST API server adds a second array to the `links` member in the response that is sent. The second array provides information about how to request the result of the async task.\n\nThe following table describes the results array in the `links` member.\n\n| Member | Optional | Description |\n| ------ | --- | ----------- |\n| `href` | No | URL to send a request to for the result of the task. |\n| `rel` | No | Provides a value of 'result' to indicate that the array refers to the resource represented by the parent JSON object. |\n\n**Example:** Starting a mount task and polling the task status\n\nTo initiate a mount operation, send a POST request to the mount endpoint. Include an object containing the details of the snapshot.\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/mount\"\n```\n\nThe Rubrik REST API server returns a task object for the mount operation. The task object describes the task status as 'RUNNING' and provides the `links` member which contains the polling request array.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"status\": \"RUNNING\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\nUsing the information provided in the task object, send a GET request to poll the task status.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\"\n```\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"status\": \"RUNNING\",\n  \"error\": \"None\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\nContinue to poll the task object until the status changes to 'SUCCEEDED'.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\"\n```\n\nWhen the task object status changes to 'SUCCEEDED', the `links` member of the request includes a results array that provides a URL for the task results.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"status\": \"SUCCEEDED\",\n  \"error\": \"None\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",\n      \"rel\": \"self\"\n    },\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vm/$mounted_vm_id\",\n      \"rel\": \"result\"\n    }\n  ]\n}\n```\n\n# OpenAPI\nThe Rubrik REST API specification conforms to the OpenAPI 2.0 Specification. Tools that work with the OpenAPI 2.0 Specification can be used with the Rubrik REST API specification.\n\nDevelopment releases (pre-1.0) of the Rubrik REST API specification made reference to 'swagger'. The previous release of the OpenAPI 2.0 Specification was named the Swagger 1.2 Specification.\n\nDownload the Rubrik REST API specification for your tools. [Download](./api-docs)\n\n## Rubrik REST API Explorer\nThe Rubrik REST API Explorer is a browser-based API client hosted by the Rubrik cluster. The Explorer has the Rubrik REST API specification built in. You can use the Explorer to try out Rubrik REST API calls and view the responses.\n\n**IMPORTANT:** The Explorer interacts with the Rubrik cluster through the API calls you make. Use care when making calls that modify or delete configurations and data.\n\nTo access the Rubrik REST API Explorer, click: [Rubrik REST API Explorer](./playground/)\n\n# Authentication\n\nThe Rubrik REST API server requires that all API calls use the HTTPS protocol.\nTo meet the security requirements of that protocol, the Rubrik REST API server\nuses a self-signed certificate. A Certificate Authority cannot validate a\nself-signed certificate. Configure client tools to ignore the certificate\nvalidation error.\n\nThe Rubrik REST API server requires authentication and authorization for each\nAPI call, except calls made to the following endpoints:\n\n* [/cluster/me/version](#operation/getClusterVersion)\n* [/cluster/me/api_version](#operation/getClusterApiVersion)\n\n## Authentication session\nRubrik REST API server authenticates a session using either of the following\nmethods:\n\n* BasicAuth\n* Token\n\nThe Rubrik REST API server requires that you use an authorized username and\npassword for the Rubrik cluster. Usernames are managed by either the Rubrik\ncluster or by your LDAP service.\n\n### BasicAuth authentication\n\nBasicAuth authentication uses the HTTP Basic Authentication method and requires\nyou to include the user credentials with each API call. Since each API call\nmade using the BasicAuth method is separately authenticated, you do not need\nto manage the session state. You also do not need to log out of a session,\nsince this method does not create a session.\n\nTo use the BasicAuth method, provide the user credentials in the\n'Authorization' header of an API call.\n\nUse the string `Basic` followed by the Base64 encoding of `<username:password>`\nas the user credentials, where `<username:password>` is the username for an\nAdmin account on the host Rubrik cluster, a colon, and the account password.\n\n**Example:** Using curl to retrieve a session ID\n\nThis example uses the local Admin username 'admin' and the password 'pass' to\nretrieve: a session ID, the Rubrik server software version, and the API\nversion.\n\nThe curl command shown here takes `<username:password>`, adds 'Basic ' to the\nstring, and Base64 encodes the result.\n\n The command includes the following arguments:\n * `-k` to bypass an alert about the self-signed certificate\n * `-u` to flag the `<username:password>` string\n * `-X` to flag the HTTP method `GET`\n\n```bash\ncurl -k -u admin:pass -X GET \"https://$cluster_address/api/v1/cluster/me\"\n```\nThe Rubrik REST API server returns the following response body.\n```bash\n{\n  \"id\": \"$cluster_id\",\n  \"version\": \"3.1.0\",\n  \"apiVersion\": \"1.0\"\n}\n```\n\n### Token authentication\n\nToken authentication creates a token at the beginning of a session and then\nuses that token to authenticate the API calls that are made during the session.\nThe token remains valid for the session - normally 30 minutes after the last\nactivity. You can close a session and invalidate the session token at any time\nby making a DELETE call to `/session/{id}` where `{id}` is the session ID or\n`me` for the current session ID.\n\n**Example:** Token authentication in a session\n\nThis example uses the local Admin username 'admin' and the password 'pass'. To\nopen a session, first use the [BasicAuth](#section/BasicAuth) method to\nauthenticate a POST call to [/session](#operation/createSession).\n\n```bash\ncurl -k -u admin:pass -X POST \"https://$cluster_address/api/v1/session\"\n```\n\nThe response body includes an array with the session token.\n\n```bash\n{\n  \"id\": \"$session_id\",\n  \"token\": \"$token_id\",\n  \"userId\": \"$user_id\"\n}\n```\nFor all subsequent calls during the session, include the token in the\nAuthorization header using the form: `Authorization: Bearer $token_id` where\n`$token_id` is the value of the `token` member from the response array.\n\nIn this curl command, the GET request to\n[/cluster](#operation/getPublicClusterInfo) uses `-H` to provide the\n`Authorization: Bearer $token_id` value.\n\n```bash\ncurl -k -H \"Authorization: Bearer $token_id\" -X GET\n  \"https://$cluster_address/api/v1/cluster/me\"\n```\n\nThe response body contains an array with the session ID, the Rubrik\ncluster software version, and the API version.\n\n```bash\n{\n  \"id\": \"$cluster_id\",\n  \"version\": \"3.1.0\",\n  \"apiVersion\": \"1.0\"\n}\n```\n\nTo close the session and invalidate the session token, make a DELETE call to\n[/session](#operation/deleteSession) using the value of the `id` key or use\n`me`. The alias `me` represents the session specified in the Authorization\nheader.\n\n```bash\ncurl -k -H \"Authorization: Bearer $token_id\" -X DELETE\n  \"https://$cluster_address/api/v1/session/me\"\n```\n\n## LDAP Authentication\n\nThe Rubrik cluster can be integrated with an LDAP service for\nauthentication. The API endpoints provide support for adding, updating and\ndeleting a specific LDAP service as well as list all of the\nconfigured LDAP services.\n\n### Add a new LDAP service\nYou can add a new LDAP service by making a POST call to\n[/ldap_service](#operation/createLdapService). Adding a new LDAP\nservice requires information about the dynamic DNS name of the service, an\nadministrative user who is authorized to create a computer user account as\nwell as search for all the LDAP objects needed for use by the\nRubrik cluster. The Rubrik cluster resolves the dynamic DNS name using DNS\nSRV records while honoring the advertised priority values.\n\n**Example:** Adds a new LDAP service for use by the Rubrik cluster\n\nThis example adds an LDAP service that uses a dynamic DNS name\nof *example.com*, with a bind administrator user of *Administrator* with a\npassword of *VerySafe*.\n\n```bash\ncurl -k -u admin:pass -X POST -d '{\"dynamicDnsName\": \"example.com\",\n  \"bindUserName\": \"Administrator\", \"bindUserPassword\": \"VerySafe\"}'\n  'https://$cluster_address/api/v1/ldap_service'\n```\n\nThe response body includes the ID associated with this LDAP service.\n\n```bash\n{\n  \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",\n  \"domainType\": \"AD\",\n  \"name\": \"example.com\",\n  \"serviceAccount\": \"cluster10-c8D7A54$\",\n  \"initialRefreshStatus\": \"ongoing\"\n}\n```\n\nThe parameters associated with the LDAP service can be updated by\nmaking a PATCH request to [/ldap_service/{id}](#operation/patchLdapService)\nor a PUT request to [/ldap_service/{id}](#operation/putLdapService).\n\nFor example, you could add a prioritized list of authentication servers that\nsupercede the LDAP servers advertised for the dynamic DNS name. These\nauthentication servers can even be proxies that connect to the actual\nLDAP servers.\n\n**Example:** Add two new LDAP services\n\nThis example adds two LDAP servers called ad-proxy1.example.com\nand ad-proxy2.cloud.example.com.\n\n```bash\ncurl -k -u admin:pass -X PATCH -d '{ \"authServers\":\n[\"ldap://ad-proxy1.example.com:389\", \"ldap://ad-proxy2.example.com:389\"]}'\nhttps://$cluster_address/api/v1/ldap_service/499aeb71-f114-45a5-8456-91b9f6c45ddd\n```\n\nThe response body confirms a successful update.\n\n```bash\n{\n  \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",\n  \"domainType\": \"AD\",\n  \"name\": \"example.com\",\n  \"initialRefreshStatus\": \"success\"\n}\n```\n\n### List configured LDAP services\nYou can get a listing of all the configured authentication domains using\na GET request to [/ldap_service](#operation/queryLdapService).\n\n**Example:** Get the list of LDAP services.\n\n```bash\ncurl -k -u admin:pass -X GET 'https://$cluster_address/api/v1/ldap_service'\n```\n\nThe response body will contain the ID of all the authentication realms.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",\n      \"domainType\": \"AD\",\n      \"name\": \"example.com\",\n      \"serviceAccount\": \"cluster10-c8D7A54$\",\n      \"initialRefreshStatus\": \"success\"\n    },\n    {\n      \"id\": \"9fef084b-75f8-4c03-9efa-c73b55be5da8\",\n      \"domainType\": \"LOCAL\",\n      \"name\": \"local\",\n      \"initialRefreshStatus\": \"success\"\n    }\n  ],\n  \"total\": 2\n}\n\n```\n\n### Get information about a specific LDAP service\n\nYou can also get information about a specific LDAP service using\na GET request to [/ldap_service/{id}](#operation/getLdapService).\n\n**Example:** Get information about a configured LDAP service.\n\n```bash\ncurl -k -u admin:pass -X GET\n  'https://$cluster_address/api/v1/ldap_service/499aeb71-f114-45a5-8456-91b9f6c45ddd'\n```\n\nThe response body will contain information about the specified LDAP service.\n\n```bash\n{\n  \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",\n  \"domainType\": \"AD\",\n  \"name\": \"example.com\",\n  \"serviceAccount\": \"cluster10-c8D7A54$\",\n  \"initialRefreshStatus\": \"success\"\n}\n```\n\n### Delete an LDAP service\nAny LDAP service that is configured to a Rubrik cluster can\nbe removed by issuing a DELETE request to\n[/ldap_service/{id}](#operation/deleteLdapService).\n\n**Example:** Remove an LDAP service\n\n```bash\ncurl -k -u admin:pass -X DELETE\nhttps://$cluster_address/api/v1/ldap_service/499aeb71-f114-45a5-8456-91b9f6c45ddd\n\n```\n\n## LDAP domain authentication\nScripts that automate calls to the Rubrik REST API endpoints must\ninclude one of the available authentication methods: the HTTP Basic\nmethod, the session method, or the API token method.\n\nWhen the HTTP Basic method is used, and authentication is through\nan LDAP domain, issues can arise when the Rubrik cluster is\nconfigured with multiple LDAP domains. With this method, the\nauthentication server first attempts to authenticate through the\nRubrik cluster local domain. If that authentication attempt does not\nsucceed, the authentication server attempts authentication with each\navailable LDAP domain. If there are several LDAP domains configured,\nthen this process can slow down authentication. With many LDAP\ndomains, the authentication can potentially have too many failed\nlogins and result in an account lock-out.\n\nAlthough using the [API token for authentication](#token-authentication) is recommended for\nscripting, using the session authentication method will also avoid\nthese issues. The following python script provides an example of how\nto use session authentication in a script. The method used in this\nexample can be duplicated in other scripting languages to suit your\nscripting requirements.\n\n```\ntry:\n    sessionData = None\n\n    session = requests.Session()\n    session.auth = ($username, $password)\n    session.verify = False\n    session.headers = {'Content-type': 'application/json'}\n    requests.adapters.HTTPAdapter()\n    session.mount('https://', requests.adapters.HTTPAdapter(pool_connections=1))\n\n    # First, login to create a Web Session Token\n    loginData = {\n       \"initParams\": {\n           \"organizationId\": $org_id\n        }\n    }\n    login = session.post(\n    url='https://{}/api/internal/session/realm/{}'.format($RubrikCluster, $domain_display_name),\n    data=json.dumps(loginData),\n    timeout=300)\n    assert login.ok and 'session' in login.json()\n    sessionData = login.json()['session']\n    session.headers.update({'Authorization': 'Bearer {}'.format(sessionData['token'])})\n    session.auth = None\n\n    # Issue the desired request\n    cluster = session.get(url='https://{}/api/v1/cluster/me'.format($RubrikCluster))\n    assert cluster.ok\n    print('Session Auth: {}'.format(cluster.json()['name']))\n\nfinally:\n    if sessionData:\n        # Delete the web sessions explicitly. Rubrik CDM supports a\n        # limited number of sessions per user. Once this limit is exceeded,\n        # a random web session is discarded. This could log out the\n        # user from the UI or cause another script to fail.\n\n       logoutData = {\n           \"tokenIds\": [\n               sessionData['id']\n            ],\n            \"userId\": sessionData['userId']\n        }\n        logout = session.post(\n            url='https://{}/api/internal/session/bulk_delete'.format($RubrikCluster),\n            data=json.dumps(logoutData),\n            timeout=300)\n        assert logout.ok\n```\nWhere:\n    * `$username` is the name of the user account to be authenticated.\n    * `$password` is the password associated with the username.\n    * `$org_id` is the ID of the organization representing the tenant.\n    * `$RubrikCluster` is the IPv4 address or resolvable hostname of\n       the Rubrik cluster.\n    * `$domain_display_name` is the name of the LDAP domain.\n\n## SAML ID Provider Authentication\n\nThe Rubrik cluster can be integrated with a SAML ID Provider authentication\ndomain for authentication. The Rubrik REST API provides API endpoints for\nmanaging and configuring the ID Provider authentication domain with\nthe Rubrik cluster. The Rubrik REST API also provides API endpoints for\ncreating the SAML authentication request\nand handling the SAML authentication response.\n\n### Add a new SAML ID Provider Authentication Domain\nYou can add a new ID Provider by making a POST call to\n[/idp_auth_domain](#operation/createIdProviderAuthDomain).\nAdding a new ID Provider requires the ID Provider metadata XML file\nin base64 encoding, and a human-friendly name for the ID Provider.\n\n**Example:** Adds a new ID Provider for use by the Rubrik cluster\n\n```bash\ncurl -k -u admin:pass -X POST -d '{\"name\": \"new-idp\",\n  \"metadataXmlBase64\": \"1VZbj6LYFn438T9UPI+mi7slpqsnm2sBQgm...\"}'\n  'https://$cluster_address/api/v1/idp_auth_domain'\n```\n\nThe response body includes the ID associated with this Active Directory.\n\n```bash\n{\n  \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",\n  \"name\": \"new-idp\",\n  \"entityId\": \"http://www.example.com/idp1\",\n  \"ssoUrl\": \"https://www.example.com/idp1/sso\",\n  \"signCert\": \"-----BEGIN CERTIFICATE-----\\nMIIDrDCCApSg...\\n-----END CERTIFICATE-----\"\n}\n```\n\n### Update an existing SAML ID Provider Authentication Domain\nThe name and metadata associated with the ID Provider can be updated by\nmaking a PATCH request to\n[/idp_auth_domain/{id}](#operation/updateIdProviderAuthDomain).\nThis API call can update either of the two parameters.\n\n**Example:** Update name of the ID Provider\n\nThis example update the name of ID Provider \"new-idp\" as \"updated-idp\",\nand update metadata with new ID Provider \"http://www.example.com/idp2\"\n\n```bash\ncurl -k -u admin:pass -X PATCH -d '{ \"name\": \"updated-idp\",\n  \"metadataXmlBase64\": \"1VZbj6AQwTIr4deKspU/zyR9fxqPPebgQ...\"}'\n  'https://$cluster_address/api/v1/idp_auth_domain/499aeb71-f114-45a5-8456-91b9f6c45ddd'\n```\n\nThe response body confirms a successful update.\n\n```bash\n{\n  \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",\n  \"name\": \"updated-idp\",\n  \"entityId\": \"http://www.example.com/idp2\",\n  \"ssoUrl\": \"https://www.example.com/idp2/sso\",\n  \"signCert\": \"-----BEGIN CERTIFICATE-----\\nMIIDrDCCtchA...\\n-----END CERTIFICATE-----\"\n}\n```\n\n### List configured ID Provider Authentication Domains\nYou can get a listing of all the configured ID Providers using\na GET request to [/idp_auth_domain](#operation/queryIdProviderAuthDomain).\n\n**Example:** Get the list of ID Provider authentication domains.\n\n```bash\ncurl -k -u admin:pass -X GET 'https://$cluster_address/api/v1/idp_auth_domain'\n```\n\nThe response body contains the ID of all the ID provider\nauthentication domains.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",\n      \"name\": \"new-idp\",\n      \"entityId\": \"http://www.example.com/idp1\",\n      \"ssoUrl\": \"https://www.example.com/idp1/sso\",\n      \"signCert\": \"-----BEGIN CERTIFICATE-----\\nMIIDrDCCApSg...\\n-----END CERTIFICATE-----\"\n    },\n    {\n      \"id\": \"9fef084b-75f8-4c03-9efa-c73b55be5da8\",\n      \"name\": \"another-idp\",\n      \"entityId\": \"http://www.example.com/idp2\",\n      \"ssoUrl\": \"https://www.example.com/idp2/sso\",\n      \"signCert\": \"-----BEGIN CERTIFICATE-----\\nMIIDrDCCtchA...\\n-----END CERTIFICATE-----\"\n    }\n  ],\n  \"total\": 2\n}\n\n```\n\n### Get information about a specific SAML ID Provider Authentication Domain\nYou can also get information about a specific ID Provider using\na GET request to [/idp_auth_domain/{id}](#operation/getIdProviderAuthDomain).\n\n**Example:** Get information about a configured ID Provider.\n\n```bash\ncurl -k -u admin:pass -X GET\n  'https://$cluster_address/api/v1/idp_auth_domain/499aeb71-f114-45a5-8456-91b9f6c45ddd'\n```\n\nThe response body contains information about this ID provider\nauthentication domain.\n\n```bash\n{\n  \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",\n  \"name\": \"new-idp\",\n  \"entityId\": \"http://www.example.com/idp1\",\n  \"ssoUrl\": \"https://www.example.com/idp1/sso\",\n  \"signCert\": \"-----BEGIN CERTIFICATE-----\\nMIIDrDCCApSg...\\n-----END CERTIFICATE-----\"\n}\n```\n\n### Delete an ID Provider Authentication Domain\nAny ID Provider authentication domain that is configured\nto a Rubrik cluster can be removed by issuing a DELETE request to\n[/idp_auth_domain/{id}](#operation/deleteIdProviderAuthDomain).\n\n**Example:** Remove the ID Provider authentication domain\n\n```bash\ncurl -k -u admin:pass -X DELETE\nhttps://$cluster_address/api/v1/idp_auth_domain/499aeb71-f114-45a5-8456-91b9f6c45ddd\n```\n\n### Download Rubrik SAML Metadata\nGenerate the Rubrik SAML service provider metadata file and\nget the URL of the file by issuing a GET request to\n[/saml/rubrik_metadata](#operation/configRubrikSamlMetadata).\n\n**Example:**  Generate the Rubrik SAML metadata file without providing\nan address for the host at the endpoint. The cluster chooses\na floating IP as the host address.\n\n```bash\ncurl -k -u admin:pass -X POST -d '{}'\n  'https://$cluster_address/api/v1/saml/rubrik_metadata'\n```\n\n**Example:** Generate the Rubrik SAML metadata file and specify\nan address for the host at the endpoint.\n\n```bash\ncurl -k -u admin:pass -X POST -d '{\"hostAddress\": \"my.rubrik.saml.sp.com\"}'\n  'https://$cluster_address/api/v1/saml/rubrik_metadata'\n```\n\n### Check SAML SSO Status ###\nSend a GET request to unauthenticated endpoint\n[/saml/sso_status](#operation/getSamlSsoStatus) to check SAML SSO status.\nThe status is represented by an object that contains 1) a Boolean value that\ndetermines whether or not SSO is enabled. 2) an optional String value that\nindicates the name of the default IdP authentication domain for SSO login.\nThe default IdP will be configured when there is only one IdP configured in\nthe cluster. 3) a Boolean value, isGpsLoginEnabled, that determines whether\nfederated login is enabled.\n\n**Example:** Check SAML SSO status\n\n```bash\ncurl -k -X GET 'https://$cluster_address/api/v1/saml/sso_status'\n```\n\n### Make SAML Authentication Request\nSend a POST request to [/saml/authn_request](#operation/makeSamlAuthnRequest)\nto generate a signed SAML authentication request for the authentication domain\nof a specified ID Provider. The request can include optional parameters to\nspecify a redirection resource path  and to specify that the request\nis a test of the configuration for the ID Provider. The response provides\nthe data that is required for a SAML SSO authentication request for\nthe ID Provider. This is an unauthenticated API.\n\n**Example:** Make the SAML authentication request for ID Provider my-idp-1\n\n```bash\ncurl -k -X POST https://$cluster_address/api/v1/saml/authn_request/my-idp-1\n  -d '{\"redirectPath\": \"/web/bin/index.html#/welcome\", \"isForIdpTest\": false}'\n```\n\n# Principal Management\n\n## Searching for principals\n\nTo search for principals, send a GET request to the\n[`/principal`](#operation/searchPrincipalsV1) endpoint.\n\nThis endpoint only returns principals from the organization to which the\ncurrently logged-in user belongs.\n\nAll query parameters are optional. Each specified query parameters (besides the\nsorting parameters) will further restrict the set of results.\n\n**Example:**\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/principal?\nname=$name&\nauth_domain_id=$auth_domain_id&\norganization_id=$organization_id&\nrole_id=$role_id&\nis_assigned_roles_or_is_local=$is_assigned_roles_or_is_local&\nsort_by=$sort_by&\nsort_order=$sort_order&\nlimit=$limit&\noffset=$offset\"\n```\n\n## Assigning roles to principals\n\nTo get a list of roles assigned to principals, send a GET request to the\n[`/principal/role`](#operation/getRolesForPrincipals) endpoint.\n\n**Example:**\n```bash\ncurl -X GET -d \"https://$cluster_address/api/v1/principal/role?\nprincipals=$principal_ids\"\n```\n\nTo assign roles to a set of principals, send a POST request to the\n[`/principal/role`](#operation/assignRolesToPrincipals)\nendpoint.\n\n**Example:**\n```bash\ncurl -X POST -d '{\n  \"principals\": \"[$principal_id]\",\n  \"roles\": \"[$role_id]\"\n}' \"https://$cluster_address/api/v1/principal/role\"\n```\n\nTo revoke roles from a set of principals, send a POST request to the\n[`/principal/role/bulk_revoke`](#operation/revokeRolesFromPrincipals)\nendpoint.\n\n**Example:**\n```bash\ncurl -X POST -d '{\n  \"principals\": \"[$principal_id]\",\n  \"roles\": \"[$role_id]\"\n}' \"https://$cluster_address/api/v1/principal/role/bulk_revoke\"\n```\n\n# Role Management\n\nThis section provides details on role management on CDM.\n\n## Role Lifecycle Management\n\nTo create a new role, send a POST request to the\n[`/role`](#operation/createRole) endpoint.\n\n**Example:**\n```bash\ncurl -X POST -d '{\n  \"name\": \"$role_name\",\n  \"description\": \"$description\"\n}' \"https://$cluster_address/api/v1/role\"\n```\n\nTo update a new role, send a PATCH request to the\n[`/role/$role_id`](#operation/updateRole) endpoint.\n\n**Example:**\n```bash\ncurl -X PATCH -d '{\n  \"name\": \"$role_name\",\n  \"description\": \"$description\"\n}' \"https://$cluster_address/api/v1/role/$role_id\"\n```\n\nTo delete a role, send a DELETE request to the\n[`/role/$role_id`](#operation/deleteRole) endpoint.\n\n**Example:**\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/role/$role_id\"\n```\n\nTo get role metadata for all roles in an organization,\nsend a GET request to the [`/role`](#operation/getRoles) endpoint.\n\nAll query parameters are optional. The getRoles endpoint uses the\norganization ID of the current user session when the API call does\nnot specify an organization ID.\n\n**Example:**\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/role?\norganization_id=$organization_id&\nname=$role_name\"\n```\n\nTo get role metadata for a specific role, send a GET request to the\n[`/role/$role_id`](#operation/getRole) endpoint.\n\n**Example:**\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/role/$role_id\"\n```\n\n\n# Authorization\n\nThis section provides details on authorizing calls to the Rubrik CDM REST API.\n\n## Clearing the authorization cache\nStale authorization information cached on the Rubrik CDM API server can cause\nAPI call failures. Clearing the cache on the node targeted by an API call can\nprevent this error.\n\nTo clear the cache, send a DELETE request to the\n[`/authorization/cache`](#operation/deleteAuthzCache) endpoint.\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/authorization/cache\"\n```\n\n# Rubrik certificate management\n\nThis section explains how to manage certificates.\n\n## Retrieving all imported certificates\n\nTo retrieve all imported certificates from the cluster, send a GET request to\nthe [`/certificate`](#operation/queryCertificates) endpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/certificate\"\n```\n\nThe Rubrik REST API server returns an array of objects with the certId,\nthe name, the description, the certificate, whether the certificate has\na private key, the expiration time, and what objects are using the certificate.\n\n```bash\n{\n  \"certId\": \"$certId\",\n  \"name\": \"$certName\",\n  \"hasKey\": true,\n  \"expiration\": \"$certExpiration\",\n  \"usedBy\": {}\n}\n```\n\n## Importing a certificate\n\nTo import a certificate, send a POST request to the\n[`/certificates`](#operation/importCertificate) endpoint.\n\n```bash\ncurl -X POST -d '{\n  \"name\": \"certName\",\n  \"pemFile\": \"$pemFile\",\n  \"privateKey\": \"$privateKey\",\n  \"description\": \"$description\"\n}' \"https://$cluster_address/api/v1/certificate\"\n```\n\nThe Rubrik REST API server returns an object with the certId, the name,\nthe description, the certificate, whether the certificate has a private key,\nthe expiration time, and what objects are using the certificate.\n\n```bash\n{\n  \"certId\": \"$certId\",\n  \"name\": \"$certName\",\n  \"hasKey\": true,\n  \"expiration\": \"$certExpiration\",\n  \"usedBy\": {}\n}\n```\n\n## Retrieving a certificate\n\nTo retrieve a certificate, send a GET request to the\n[`/certificate/{id}`](#operation/exportCertificate) endpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/certificate/$cert_id\"\n```\n\nThe Rubrik REST API server returns an object with the certId, the name,\nthe description, the certificate, whether the certificate has a private key,\nthe expiration time, and what objects are using the certificate.\n\n## Updating a certificate\n\nTo update a certificate, send a PATCH request to the\n[`/certificate/{id}`](#operation/updateCertificate) endpoint.\n\n```bash\ncurl -X POST -d '{\n  \"name\": \"certName\",\n  \"pemFile\": \"$pemFile\",\n  \"description\": \"$description\"\n}' \"https://$cluster_address/api/v1/certificate/$cert_id\"\n```\n\nThe Rubrik REST API server returns an object with the certId, the name,\nthe description, the certificate, whether the certificate has a private key,\nthe expiration time, and what objects are using the certificate.\n\n## Deleting a Certificate\n\nTo delete a certificate, send a DELETE request to the\n[`/certificate/{id}`](#operation/deleteCertificate) endpoint.\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/certificate/$cert_id\"\n```\n\n## Generating a Certificate Signing Request (CSR)\n\nTo generate a CSR, send a POST request to the\n[`/csr`](#operation/generateCsr) endpoint.\n\n```bash\ncurl -X POST -d '{\n  \"hostnames\": \"$hostnames\",\n  \"name\": \"$name\",\n  \"organizations\": \"$organization\",\n  \"organizationUnit\": \"$organizationUnit\",\n  \"country\": \"$country\",\n  \"state\": \"$state\",\n  \"city\": \"$city\"\n}' \"https://$cluster_address/api/v1/csr\"\n```\nHostnames and name are required. The Rubrik REST API server will respond with\nthe information provided in the POST request, in addition to the CSR to be\nsigned.\n\n## Retrieving all outstanding Certificate Signing Requests\n\nTo retrieve all outstanding CSRs, send a GET request to the\n[`/csr`](#operation/getAllCsrs) endpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/csr\"\n```\nThe Rubrik REST API server returns an array of objects with the csrId,\nthe name, the CSR, and all information provided to generate the CSR.\n\n## Deleting a Certificate Signing Request (CSR)\n\nTo delete a CSR, send a DELETE request to the\n[`/csr/{id}`](#operation/deleteCsr) endpoint.\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/csr/$csr_id\"\n```\n\n## Managing Rubrik Backup Service secondary cluster certificates\n\nThe Rubrik Backup Service can be setup to allow registering with multiple Rubrik\nclusters. See the Multicluster Rubrik Backup Service section of the Rubrik CDM\nUser Guide for details. Certificates for replication source or replication\ntarget clusters are automatically added without calling the API in this section.\nTo mark a certificate to be added to agents, send a POST request to\n[`/certificate/agent`](#operation/markAgentSecondaryCertificate).\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"cert_id\": \"$certId\"\n  }' \\\n  \"https://$cluster_address/api/v1/certificate/agent\"\n```\n\nTo list all qualified certificates that have been\n[imported to the cluster](#section/Rubrik-certificate-management/Importing-a-certificate),\nsend a GET request to\n[`/certificate/agent`](#operation/queryAgentSecondaryCertificate).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/certificate/agent\"\n```\n\nTo unmark a certificate so that is is no longer added to agents, send a DELETE\nrequest to\n[`/certificate/agent/{id}`](#operation/unmarkAgentSecondaryCertificate).\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/certificate/agent/$certId\"\n```\n\n# Cluster configuration history\nRubrik REST API provides the `/config/history` endpoints for\nadministrators to audit the changes made to the configuration\nparameters on a Rubrik cluster.\n\nThe ability to audit the configuration changes allows administrators to\ntrack the information related to the configuration changes, such as the\nold and new values of the configuration parameters, the user account\nthat made the changes, the time of each change, and the name of the\ncluster or node where the changes were made.\n\nThe `/config/history` endpoints apply to the following\nconfiguration parameters:\n* Global or cluster wide configuration\n* Local or node specific configuration\n\n## Retrieving a summary of configuration changes\nTo retrieve a list of configuration updates based on specific parameters,\nsend a GET request to [`/config/history/list_updates`]\n(#operation/queryConfigurationHistoryUpdates).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/config/history/list_updates\"\n```\n\nTo retrieve information for a specific configuration parameter\ninclude the name of the parameter in the request. To retrieve\ninformation for all configuration parameters that fit within the specified\nfilters, do not specify a parameter name.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/config/history/list_updates?name=$config_name\"\n```\nThe *Rubrik CDM User Guide* describes the parameters that can be\nconfigured to filter the results of the `GET /config/history/list_updates`\nendpoint.\n\nThe Rubrik REST API server responds with a list of JSON objects for the\nconfiguration updates that meet all specified filters.\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"nodeId\": \"string\",\n      \"namespace\": \"string\",\n      \"name\": \"string\",\n      \"oldValue\": \"string\",\n      \"newValue\": \"string\",\n      \"apiUser\": \"string\",\n      \"modifiedDateTime\": \"2021-02-26T17:21:54.520Z\",\n      \"source\": \"string\",\n      \"configChangeMetadata\": \"string\"\n    }\n  ],\n  \"total\": 0\n}\n```\n\n## Retrieving a summary of configuration changes on a given date\nTo retrieve the values of configuration parameters on a specific date,\nsend a GET request to [`/config/history/ondate`]\n(#operation/retrieveConfigurationValues).\n\nSpecify values for the `namespace` and `on_date` query parameters\nthat are required to send the GET request.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/config/history/ondate?namespace=$namespace&on_date=$timestamp\"\n```\n\nTo retrieve information for a specific configuration parameter\ninclude the name of the parameter in the request, along with the\nnamespace and on_date parameters. To retrieve information for all\nconfiguration parameters that fit within the specified filters, do not\nspecify a configuration parameter name.\n\nThe *Rubrik CDM User Guide* describes the parameters that can be\nconfigured to filter the results of the `GET /config/history/ondate`\nendpoint.\n\nThe Rubrik REST API server responds with a list of JSON objects for the\nconfiguration updates that meet all specified filters.\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"namespace\": \"string\",\n      \"name\": \"string\",\n      \"defaultValue\": \"string\",\n      \"onDate\": \"2021-02-26T17:21:54.526Z\",\n      \"valueOnDate\": \"string\",\n      \"currentValue\": \"string\",\n      \"nodeId\": \"string\"\n    }\n  ],\n  \"total\": 0\n}\n```\n\n# Rubrik cluster management\n\nThis section explains how to retrieve basic information about a Rubrik cluster, as well as how to update the name of a cluster.\n\n## Discovering Nodes\n**Example:** Discovering unbootstrapped nodes on a network\nThe discover endpoint cannot function without multicast DNS. When multicast DNS is not available, manually specify hostname and IPv6 information about the Rubrik cluster to enable node discovery.\nTo input information about unbootstrapped nodes located on this network, send a POST request to the [`/cluster/{id}/$manual_discover`](#operation/manualDiscover) endpoint.\n\n```bash\ncurl -X POST \\\n  -d '{\"nodeInfo\": [ {\"hostname\": \"string\", \"ipv6\": \"string\" } ] }' \\\n  \"https://$cluster_address/api/v1/cluster/$manual_discover\"\n```\n\nThe [`/cluster/{id}/$manual_discover_ipv4`](#operation/manualDiscoverIpv4) endpoint also discovers nodes over an IPv4 network.\n\n```bash\ncurl -X POST \\\n  -d '{\"nodeInfo\": [ {\"hostname\": \"string\", \"ipv4\": \"string\" } ] }' \\\n  \"https://$cluster_address/api/v1/cluster/$manual_discover_ipv4\"\n```\n\n## Retrieving Rubrik Cluster Information\n\n\n**Example:** Retrieving publicly available information about a Rubrik cluster\n\nTo retrieve information about a Rubrik cluster, send a GET request to the [`/cluster/$cluster_id`](#operation/getPublicClusterInfo) endpoint. The Rubrik REST API server responds with the publicly available information for the specified Rubrik cluster.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id\"\n```\n\nThe Rubrik REST API server returns an array with the session ID, the Rubrik cluster software version, the API version, the Rubrik cluster name, and the Rubrik cluster time zone.\n\n```bash\n{\n  \"id\": \"$cluster_id\",\n  \"version\": \"4.1.0\",\n  \"apiVersion\": \"1.0\",\n  \"name\": \"$cluster_name\",\n  \"timezone\": {\n    \"timezone\": \"$cluster_timezone\"\n  }\n}\n```\nTo retrieve the cluster certificate, send a GET request to the\n[`/cluster/{id}/certificate`](#operation/getClusterCertificate) endpoint.\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/certificate\"\n```\nTo request only the current software version of the Rubrik cluster, send a GET request to the [`/cluster/$cluster_id/version`](#operation/getClusterVersion) endpoint.\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/version\"\n```\n\nTo request only the current REST API version running on the cluster, send a GET request to [`/cluster/$cluster_id/api_version`](#operation/getClusterApiVersion)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/api_version\"\n```\n\nTo get the download link for Rubrik SNMP MIB file, send a GET request to [`/cluster/$cluster_id/snmp_mib_link`](#operation/getRubrikSnmpMibDownloadLink)\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/snmp_mib_link\"\n```\n\nTo get the download link for the SYSLOG-MSG-MIB file, send a GET request to [`/cluster/$cluster_id/syslog_msg_mib_link`](#operation/getSyslogMsgSnmpMibDownloadLink)\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/syslog_msg_mib_link\"\n```\n\nTo get the download link for the SYSLOG-TC-MIB file, send a GET request to [`/cluster/$cluster_id/syslog_tc_mib_link`](#operation/getSyslogTcSnmpMibDownloadLink)\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/syslog_tc_mib_link\"\n```\n\nTo retrieve the encryption at rest status of the cluster, send a GET request to the [`/cluster/$cluster_id/encryption`](#operation/getEncryptionStatus) endpoint.\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/security/encryption\"\n```\n\nTo retrieve the IDs of the nodes in the cluster, send a GET request to the ['/cluster/$cluster_id/node_id'](#operation/getClusterNodeIds) endpoint.\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/node_id\"\n```\n\n## Hostnames for nodes in a Rubrik cluster\n\n### Retrieving hostnames for nodes in a Rubrik cluster\n\nTo retrieve the hostnames of the nodes in a Rubrik cluster, send a GET request to the ['/cluster/$cluster_id/node_hostname'](#operation/getClusterNodeHostnames) endpoint.\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/node_hostname\"\n```\nThe Rubrik REST API server responds with an array of node ID to hostname mappings for all the nodes in the specified Rubrik cluster.\n```bash\n[\n  {\n    \"id\": \"RVM000000000001\",\n    \"hostname\": \"myhost01\"\n  },\n  {\n    \"id\": \"RVM000000000002\",\n    \"hostname\": \"myhost02\"\n  }\n]\n```\n\n### Updating hostnames for nodes in a Rubrik cluster\n\nTo update the hostnames of the nodes in the Rubrik cluster, send a POST request to the ['/cluster/$cluster_id/node_hostname'](#operation/changeClusterNodeHostnames) endpoint.\n```bash\ncurl -X POST \\\n  -d '[{ \"id\": \"$id\", \"hostname\":\" \"$hostname\" }]' \\\n  \"https://$cluster_address/api/v1/cluster/$cluster_id/node_hostname\"\n```\nThe Rubrik REST API server responds with an appropriate message.\n\n## Changing the Rubrik cluster name or time zone\n\nTo change the name or the current time zone of a Rubrik cluster, send a PATCH request to the [`/cluster/$cluster_id`](#operation/updateCluster) endpoint.  Specify the new name as the value of `$cluster_name`, and specify the new time zone as the value of `$cluster_timezone`.\n\n**Example:** Changing the name and the time zone of a Rubrik cluster\n\n```bash\ncurl -X PATCH \\\n  -d '{ \"clusterName\": $cluster_name, \"timezone\": { \"timezone\": $cluster_timezone } }' \\\n  \"https://$cluster_address/api/v1/cluster/$cluster_id\"\n```\n\nThe response provides the attributes of the specified Rubrik cluster object, including the new name, and the new time zone.\n\n```bash\n{\n  \"id\": \"$cluster_id\",\n  \"version\": \"4.1.0\",\n  \"apiVersion\": \"1.0\",\n  \"name\": \"$cluster_name\",\n  \"timezone\": {\n      \"timezone\": \"$cluster_timezone\"\n  }\n}\n```\n\n## Stage CDM software to the cluster.\n\nSend a POST request to the [`/cluster/{id}/upgrade/stage_cdm_software`](#operation/stageCdmSoftware) endpoint.\n\n```bash\ncurl -X POST \\\n  -d '{\"version\": \"$version\", \"packageUrl\": \"$packageUrl\", \"md5sum\": \"$md5sum\", \"size\": $size, \"skipDownload\": $skipDownload }' \\\n  \"https://$cluster_address/api/v1/cluster/$cluster_id/upgrade/stage_cdm_software\"\n```\n\n## Query asynchronous job status for upgrade related job\n\nTo query the job status details of an asynchronous job that is related to upgrades, issue a GET to [`/cluster/{id}/upgrade/request/{request_id}`](#operation/getAsyncRequestStatusForUpgrade).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/upgrade/request/$request_id\"\n```\n\n## Retrieve CDM version available for upgrade\n\nSend a GET request to the [`/cluster/{id}/upgrade/available_version`](#operation/availableVersion) endpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/cluster/upgrade/available_version\"\n```\n\n## Retrieving Rubrik cluster prechecks status.\nTo start an on demand run of the periodic upgrade prechecks,\n send a POST request to the [`/cluster/{id}/upgrade/precheck_status`](#operation/runPeriodicUpgradePrechecks) endpoint.\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/cluster/$cluster_id/upgrade/\nprecheck_status\"\n```\n\nTo retrieve the result of the latest run of periodic upgrade prechecks,\n send a GET request to the [`/cluster/{id}/upgrade/precheck_status`](#operation/getPeriodicUpgradePrechecksStatus) endpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/upgrade/\nprecheck_status\"\n```\n\nThe Rubrik REST API server returns a response which provides the list of\n failures along with start time and end time.\n```bash\n{\n  \"endTime\": 1580385970715,\n  \"isOnDemand\": false,\n  \"failureResults\": [\n    {\n      \"isUserRemediable\": false,\n      \"errorMessage\": \"Sample error message\",\n      \"precheckName\": \"Sample precheck name\",\n      \"userRemediableAction\": \"\",\n      \"userRemediableActionMessage\": \"\"\n    }\n  ],\n  \"startTime\": 1580385904457\n}\n```\n\n## Checking if a Rubrik cluster has an existing set of Rubrik support portal credentials\n\nSend a GET request to the [`/cluster/{id}/rubrik_support_portal_credentials`](#operation/hasRubrikSupportPortalCredentials) endpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/rubrik_support_portal_credentials\"\n```\n\n## Updating Rubrik support portal credentials on a Rubrik cluster\n\nSend a POST request to the [`/cluster/{id}/rubrik_support_portal_credentials`](#operation/updateRubrikSupportPortalCredentials) endpoint.\n\n```bash\ncurl -X POST \\\n  -d '{\"username\" : \"$username\", \"password\": \"$password\"}' \\\n  \"https://$cluster_address/api/v1/cluster/$cluster_id/rubrik_support_portal_credentials\"\n```\n\n## Monitoring events on CDM\n\nSend a GET request to the [`/cluster/me/upgrade/monitor_events`]\n(#operation/monitorEvents) endpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/cluster/me/upgrade/monitor_events\"\n```\n\n# Passwords\n\n## Setting password requirements\n\nTo set cluster-wide password requirements, send a PATCH request to\n[`/cluster/{id}/security/password_requirements`]\n(#operation/patchPasswordRequirements).\nThe following parameters are optional:\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"id\": \"$cluster_id\",\n    \"minLength\": \"$min_length\",\n    \"minUpperCase\": \"$min_upper_case\",\n    \"minLowerCase\": \"$min_lower_case\",\n    \"minNumerics\": \"$min_numerics\",\n    \"minSpecial\": \"$min_special\",\n    \"useZxcvbn\": \"$use_zxcvbn\" }' \\\n  \"https://$cluster_address/api/v1/cluster/{id}/security/password_requirements\"\n```\n\nThe Rubrik REST API server responds with a summary of the password requirements:\n```bash\n{\n  \"id\": \"$cluster_id\",\n  \"minLength\": \"$min_length\",\n  \"maxLength\": \"$max_length\",\n  \"minUpperCase\": \"$min_upper_case\",\n  \"minLowerCase\": \"$min_lower_case\",\n  \"minNumerics\": \"$min_numerics\",\n  \"minSpecial\": \"$min_special\",\n  \"useZxcvbn\": \"$use_zxcvbn\"\n}\n```\n\n## Getting current password requirements\n\nTo retrieve the existing cluster-wide password requirments,\nsend a GET request to\n[`/cluster/{id}/security/password_requirements`]\n(#operation/queryPasswordRequirements)\n\n```bash\ncurl -X GET \\\n  -d '{\n    \"id\": \"$cluster_id\" }' \\\n  \"https://$cluster_address/api/v1/cluster/{id}/security/password_requirements\"\n\n```\n\nThe Rubrik REST API server responds with a summary of the password requirements:\n```bash\n{\n  \"id\": \"$cluster_id\",\n  \"minLength\": \"$min_length\",\n  \"maxLength\": \"$max_length\",\n  \"minUpperCase\": \"$min_upper_case\",\n  \"minLowerCase\": \"$min_lower_case\",\n  \"minNumerics\": \"$min_numerics\",\n  \"minSpecial\": \"$min_special\",\n  \"useZxcvbn\": \"$use_zxcvbn\"\n}\n```\n\n## Managing the Web Server Certificate\n\nTo retrieve the existing web server certificate signed by a CA, send\na GET request to:\n[`/cluster/{id}/security/web_signed_cert`]\n(#operation/getWebSignedCertificate)\n\n```bash\ncurl -X GET \\\n  -d '{\n    \"id\": \"$cluster_id\" }' \\\n  \"https://$cluster_address/api/v1/cluster/{id}/security/web_signed_cert\"\n```\n```bash\n{\n  \"webServerConfiguredWithCASignedCertificate\": true,\n  \"cert\": {\n    \"certId\": \"string\",\n    \"name\": \"string\",\n    \"pemFile\": \"string\",\n    \"hasKey\": true,\n    \"expiration\": \"2020-03-30T19:32:08.221Z\",\n    \"usedBy\": \"string\",\n    \"description\": \"string\"\n  }\n}\n```\n\nSet the web server certificate used by Rubrik for REST API\ncommunications by sending a PUT request to the\n[`/cluster/{id}/security/web_signed_cert`](#operation/setWebSignedCertificate)\nendpoint:\n\n```bash\ncurl -X PUT \\\n  -d '{\n    \"certificateId\": \"string\"}' \\\n  \"https://$cluster_address/api/v1/cluster/{id}/security/web_signed_cert\"\n```\n```bash\n{\n  \"id\": \"string\",\n  \"status\": \"string\",\n  \"progress\": 0,\n  \"startTime\": \"2020-03-30T19:09:13.400Z\",\n  \"endTime\": \"2020-03-30T19:09:13.400Z\",\n  \"nodeId\": \"string\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"string\",\n      \"rel\": \"string\"\n    }\n  ]\n}\n```\n\nTo use the default, self-signed certificate, send a DELETE request to the\n[`/cluster/{id}/security/web_signed_cert`](#operation/resetWebSignedCertificate)\nendpoint.\n\n```bash\ncurl -X DELETE \\\n  -d '{\n    \"id\": \"$cluster_id\" }' \\\n  \"https://$cluster_address/api/v1/cluster/{id}/security/web_signed_cert\"\n```\n```bash\n{\n  \"id\": \"string\",\n  \"status\": \"string\",\n  \"progress\": 0,\n  \"startTime\": \"2020-03-30T19:31:13.024Z\",\n  \"endTime\": \"2020-03-30T19:31:13.025Z\",\n  \"nodeId\": \"string\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"string\",\n      \"rel\": \"string\"\n    }\n  ]\n}\n```\n\n## Managing Truststores\n\nTo retrieve the existing truststore configuration, send\na GET request to:\n[`/cluster/{id}/security/truststore`]\n(#operation/getTruststores)\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/cluster/{id}/security/truststore\"\n```\n```bash\n{\n  \"hasMore\": false\n  \"data\": [\n    {\n      \"truststoreType\": \"TruststoreType\",\n      \"certificates\": [\n        {\n          \"certId\": \"string\",\n          \"name\": \"string\",\n          \"pemFile\": \"string\",\n          \"hasKey\": true,\n          \"expiration\": \"2020-03-30T19:32:08.221Z\",\n          \"usedBy\": \"string\",\n          \"description\": \"string\"\n        }\n      ]\n    }\n  ]\n}\n```\n\nTo set the certificates for one or more of the truststores used by Rubrik,\nsend a PATCH request to the\n[`/cluster/{id}/security/truststore`](#operation/setTruststoreCertificate)\nendpoint:\n\n```bash\ncurl -X PATCH \\\n  -d '{\n      \"truststorePayload\": [ \\\n        {\"truststoreType\": \"TruststoreType\", certIds: [\"string\", \"string\"]} \\\n      ]}' \\\n  \"https://$cluster_address/api/v1/cluster/{id}/security/truststore\"\n```\n```bash\nOK\n```\n\nTo clear the certificates for one or more of the truststores used by Rubrik,\nsend a DELETE request to the\n[`/cluster/{id}/security/truststore`](#operation/unsetTruststoreCertificate)\nendpoint:\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/cluster/{id}/security/truststore?truststores=$truststore1,$truststore2\"\n```\n```bash\nOK\n```\n\n## Updating CORS support configuration\n\nTo update the CORS support configuration for a web server, send a PATCH request\nto [`/cluster/{id}/security/cors`](#operation/updateCorsConfiguration).\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"isEnabled\": \"$is_enabled\",\n    \"allowedOrigins\": \"$allowed_origins\",\n    \"allowedHEaders\": \"$allowed_headers\" }' \\\n  \"https://$cluster_address/api/v1/cluster/{id}/security/cors\"\n```\n\n## Getting CORS support configuration\n\nRetrieve the current CORS support configuration with a GET request to:\n[`/cluster/{id}/security/cors`](#operation/getCorsConfiguration).\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/cluster/{id}/security/cors\"\n```\n\n## Getting FIPS enablement status\n\nRetrieve the current FIPS enablement status with a GET request to:\n[`/cluster/{id}/security/fips`](#operation/getFips).\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/cluster/{id}/security/fips\"\n```\n\n## Updating FIPS enablement\n\nTo update the FIPS enablement for a cluster, send a PATCH request\nto [`/cluster/{id}/security/fips`](#operation/updateFips).\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"isEnabledInFlight\": \"$is_enabled_in_flight\" }' \\\n  \"https://$cluster_address/api/v1/cluster/{id}/security/fips\"\n```\n\n## Managing KMIP Servers\nTo configure a new KMIP server integration, send a PUT request to the\n[`/cluster/{id}/security/kmip/server`](#operation/addKmipServer) endpoint.\n```bash\ncurl -X PUT \\\n  -d '{\n    \"serverAddress\": \"string\",\n    \"serverCertificateId\": \"string\",\n    \"serverPort\": 0}' \\\n  \"https://$cluster_address/api/v1/cluster/{id}/security/kmip/server\"\n\n```\n```bash\n{\n  \"id\": \"string\",\n  \"status\": \"string\",\n  \"progress\": 0,\n  \"startTime\": \"2020-03-31T22:10:40.912Z\",\n  \"endTime\": \"2020-03-31T22:10:40.912Z\",\n  \"nodeId\": \"string\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"string\",\n      \"rel\": \"string\"\n    }\n  ]\n}\n```\n\nFor information about a configured KMIP server, send a GET request to the\n[`/cluster/{id}/security/kmip/server`](#operation/getKmipServer) endpoint:\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/cluster/{id}/security/kmip/server?server_address=$address\"\n```\n```bash\n[\n  {\n    \"serverAddress\": \"string\",\n    \"serverCertificateId\": \"string\",\n    \"serverPort\": 0\n  }\n]\n```\nTo delete an existing KMIP server integration, send a DELETE\nrequest to [`/cluster/{id}/security/kmip/server`](#operation/deleteKmipServer):\n```bash\ncurl -X DELETE \\\n\"https://$cluster_address/api/v1/cluster/{id}/security/kmip/server?server_address=$address\"\n```\n```bash\n{\n  \"id\": \"string\",\n  \"status\": \"string\",\n  \"progress\": 0,\n  \"startTime\": \"2020-03-31T22:15:26.693Z\",\n  \"endTime\": \"2020-03-31T22:15:26.693Z\",\n  \"nodeId\": \"string\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"string\",\n      \"rel\": \"string\"\n    }\n  ]\n}\n\n```\n\n## Managing the KMIP Client\nTo configure the KMIP client, send a PUT request to\n[`/cluster/{id}/security/kmip/client`](#operation/setKmipClient)\n```bash\ncurl -X PUT \\\n  -d '{\n    \"username\": \"string\",\n    \"password\": \"string\",\n    \"clientCertificateId\": \"string\"\n    }' \\\n  \"https://$cluster_address/api/v1/cluster/{id}/security/kmip/client\"\n```\n```bash\n\n```\nTo retrieve information about the confiugred KMIP client, send a GET request to\n[`/cluster/{id}/security/kmip/client`](#operation/getKmipClient)\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/cluster/{id}/security/kmip/client\"\n```\n```bash\n{\n  \"username\": \"string\",\n  \"clientCertificateId\": \"string\",\n  \"isPasswordSet\": true\n}\n```\n\n## Manage the 2-Step Verification Global Setting\n### Retrieving the 2-Step Verification global setting\nTo retrieve the 2-Step Verification global setting for\na specific Rubrik cluster, send a GET request to\n[`/cluster/{id}/security/totp/setting`](#operation/getTotpGlobalSetting).\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/cluster/{id}/security/totp/setting\"\n```\nThe Rubrik REST API server responds with the 2-Step Verification setting for\nthe specified Rubrik cluster.\n```bash\n{\n  \"isEnforced\": true\n}\n```\n\n### Updating the 2-Step Verification global setting\nTo update the 2-Step Verification global setting for\na specific Rubrik cluster, send a PUT request to\n[`/cluster/{id}/security/totp/setting`](#operation/updateTotpGlobalSetting).\n```bash\ncurl -X PUT \\\n  -d '{\"isEnforced\": true}'\n  \"https://$cluster_address/api/v1/cluster/{id}/security/totp/setting\"\n```\nThe Rubrik REST API server responds with the updated 2-Step Verification \nsetting for the specified Rubrik cluster.\n```bash\n{\n  \"isEnforced\": true\n}\n```\n\n# Event\n\n## Get latest events and event series info for event series\nSend a GET request to [`/event/latest`](#operation/queryLatestEventsV1)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/event/latest\"\n```\n\n## Get information for all events\nSend a GET request to [`/event`](#operation/queryEventV1)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/event\"\n```\n\n## Get all events and relevant information associated with an event series\nSend a GET request to [`/event_series/{id}`](#operation/queryEventSeriesByIdV1)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/event_series/{id}\"\n```\n\n## Get download link of CSV file containing summary of events\nSend a GET request to\n[`/event/csv_download_link`](#operation/getEventsCsvDownloadLink)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1//event/csv_download_link\"\n```\n\n# SLA Domains\n\nRubrik clusters provide automated data management and protection through SLA Domains.\nAn SLA Domain defines the data management and protection policies for their assigned snappables (virtual machines, file systems, and applications).\n\nTo provide policy based management and protection of a snappable, add the snappable to an SLA Domain, or to multiple SLA Domains.\n\n## Retrieving SLA Domains\n\nBefore assigning snappables to SLA Domains, get a list of the SLA Domains that exist on a Rubrik cluster. For a new Rubrik cluster, the list shows only the default SLA Domains. When custom SLA Domains are added to the Rubrik cluster, the list is modified to include those SLA Domains.\n\n**Example:** Retrieving SLA Domains from a Rubrik cluster\n\nSend a GET request to [`/sla_domain`](#operation/querySlaDomain).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/sla_domain\"\n```\n\nThe Rubrik REST API server returns a `ListResponse` object of all SLA Domains.\nAt a minimum, the `ListResponse` object includes the default SLA Domains: Gold, Silver, and Bronze.\n\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"$gold_sla_id\",\n      \"name\": \"Gold\"\n    },\n    {\n      \"id\": \"$silver_sla_id\",\n      \"name\": \"Silver\"\n    },\n    {\n      \"id\": \"$bronze_sla_id\",\n      \"name\": \"Bronze\"\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 3\n}\n```\n\nTo obtain more details about a specific SLA domain send a GET request with the `id` of one of the SLA Domains to the `/sla_domain/{id}` endpoint:  [`/sla_domain/{id}`](#operation/getSlaDomain)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/sla_domain/$bronze_sla_id\"\n```\nThe Rubrik REST API server responds with the details of the specified SLA Domain.\n\n```bash\n{\n  \"id\": \"$bronze_sla_id\",\n  \"primaryClusterId\": \"$cluster_id\",\n  \"name\": \"Bronze\",\n  \"frequencies\": [\n    {\n      \"timeUnit\": \"Daily\",\n      \"frequency\": 1,\n      \"retention\": 32\n    },\n    {\n      \"timeUnit\": \"Monthly\",\n      \"frequency\": 1,\n      \"retention\": 12\n    },\n    {\n      \"timeUnit\": \"Yearly\",\n      \"frequency\": 1,\n      \"retention\": 2\n    }\n  ],\n  \"allowedBackupWindows\": [],\n  \"firstFullAllowedBackupWindows\": [],\n  \"archivalSpecs\": [],\n  \"replicationSpecs\": [\n    {\n      \"locationId\": \"$repl_location_id\",\n      \"retentionLimit\": 0\n    }\n  ],\n  \"numDbs\": 0,\n  \"numFilesets\": 7,\n  \"numLinuxHosts\": 3,\n  \"numWindowsHosts\": 2,\n  \"numVms\": 1,\n  \"isDefault\": false,\n  \"uiColor\": \"#cc8366\"\n}\n```\n\n## Working with SLA Domains\n\nTo work with an SLA Domain, obtain the `id` of that SLA Domain. As described in [Retrieving SLA Domains](#section/SLA-Domains/Retrieving-SLA-Domains), start by sending a GET request to [`/sla_domain`](#operation/querySlaDomain).\n\nThe Rubrik REST API server responds with a `ListResponse` object that contains all of the SLA Domains on the specfied Rubrik cluster. From that list object, find the data array element that has the `name` value of the selected SLA Domain. In the same array element as the `name` value, note the value of the `id` string.\n\n## Creating SLA Domains\n\nTo create an SLA domain send a POST request to [`/sla_domain`](#operation/createSlaDomain). Include the attributes for the SLA Domain in the request body.\n\nThe following table describes the required and optional attributes to include in the request body when creating an SLA Domain.\n\n| Attribute | Req'd | JSON Type | Description |\n| ------ | --- | ----- | ----------- |\n| `name` | Yes | String | Name of the SLA Domain.  |\n| `frequencies` | Yes | Array | Each member defines a policy by specifying: `timeUnit`, `frequency`, and `retention`. Requires at least one member in the array.  |\n| `allowedBackupWindows` | Yes | Array | Each member defines a backup window using values for `startTimeAttributes` and `durationInHours`. The time specified in `startTimeAttributes` uses the Rubrik cluster time zone. To specify multiple backup windows, add an array member for each window. To create an SLA Domain without a backup window, specify a null array value: `[]`.  |\n| `firstFullAllowedBackupWindows` | Yes | Array | Each member defines a period when first full backups are allowed by specifying: `startTimeAttributes` and `durationInHours`. Several first full backup windows can be specified by adding an array member for each one. Create an SLA Domain without a first full backup window by specifying a null array value: `[]`.  |\n| `localRetentionLimit` | No | String | Specify an integer value to set the number of days to retain a local copy of a snapshot. When an archival location is specified, specify `0` to enable Instant Archiving. |\n| `archivalSpecs` | No | Array | Defines the archival location for the SLA Domain by specifying: `locationId` and `archivalThreshold`. Currently limited to one array member. |\n| `replicationSpecs` | No | Array | Defines the replication location for the SLA Domain by specifying: `locationId` and `retentionLimit`. Currently limited to one array member. |\n\n**Example:** Creating an SLA Domain for daily backups\n\nCreate an SLA Domain that takes a backup once a day and retains the backup for seven days. Do not set a backup window or a first full backup window. Do not include archival or replication.\n\n```bash\ncurl -X POST \\\n  -d '{\n  \"name\": \"Daily SLA\",\n  \"frequencies\": [\n    {\n      \"timeUnit\": \"Day\",\n      \"frequency\": 1,\n      \"retention\": 7\n    }\n  ],\n  \"allowedBackupWindows\": [],\n  \"firstFullAllowedBackupWindows\": [] }' \\\n  \"https://$cluster_address/api/v1/sla_domain\"\n```\nThe response confirms the attributes of the SLA Domain and provides the `id` of the new SLA Domain.\n\n```bash\n{\n  \"id\": \"$sla_id\",\n  \"name\": \"Daily SLA\",\n  \"frequencies\": [\n    {\n      \"timeUnit\": \"Day\",\n      \"frequency\": 1,\n      \"retention\": 7\n    }\n  ],\n  \"allowedBackupWindows\": [],\n  \"firstFullAllowedBackupWindows\": []\n}\n```\n## Modifying SLA Domains\n\nTo modify the attributes of an SLA domain send a PUT request to [`/sla_domain/{id}`](#operation/updateSlaDomain). Include in the request body the new attributes.\n\n**Example:** Modifying the daily backup SLA Domain\n\nChange the SLA Domain that was created in [Creating SLA Domains](#section/SLA-Domains/Creating-SLA-Domains) to increase the retention to 14 days.\n\n```bash\ncurl -X PUT \\\n  -d '{\n  \"name\": \"Daily SLA\",\n  \"frequencies\": [\n    {\n      \"timeUnit\": \"Day\",\n      \"frequency\": 1,\n      \"retention\": 14\n    }\n  ],\n  \"allowedBackupWindows\": [],\n  \"firstFullAllowedBackupWindows\": [] }' \\\n  \"https://$cluster_address/api/v1/sla_domain/$sla_id\"\n```\nThe response confirms the new attribute.\n\n```bash\n{\n  \"id\": \"$sla_id\",\n  \"name\": \"Daily SLA\",\n  \"frequencies\": [\n    {\n      \"timeUnit\": \"Day\",\n      \"frequency\": 1,\n      \"retention\": 14\n    }\n  ],\n  \"allowedBackupWindows\": [],\n  \"firstFullAllowedBackupWindows\": []\n}\n```\n## Patching SLA Domains\n\nTo patch the attributes of an SLA domain, send a PATCH request to\n[`/sla_domain/{id}`](#operation/patchSlaDomain). Include in the request body\nonly the attributes that needs to be patched.\n\n**Example:** Patching the daily backup SLA Domain\n\nPatch the SLA Domain that was created in [Creating SLA Domains]\n(#section/SLA-Domains/Creating-SLA-Domains) to change the archival\nspecifications.\n\n```bash\ncurl -X PATCH \\\n  -d '{\n  \"archivalSpecs\": [\n    {\n        \"locationId\": \"some-valid-archived-location-id\",\n        \"archivalThreshold\": 14\n    }\n  ]}' \\\n  \"https://$cluster_address/api/v1/sla_domain/$sla_id\"\n```\nThe response confirms the new attribute and also includes the other\nattributes that were not changed.\n\n```bash\n{\n  \"id\": \"$sla_id\",\n  \"name\": \"Daily SLA\",\n  \"frequencies\": [\n    {\n      \"timeUnit\": \"Day\",\n      \"frequency\": 1,\n      \"retention\": 7\n    }\n  ],\n  \"archivalSpecs\": [\n    {\n      \"locationId\": \"some-valid-archived-location-id\",\n      \"archivalThreshold\": 14\n    }\n  ],\n  \"allowedBackupWindows\": [],\n  \"firstFullAllowedBackupWindows\": []\n}\n```\n## Deleting SLA Domains\n\nTo delete an SLA domain send a DELETE request to [`/sla_domain/{id}`](#operation/deleteSlaDomain).\n\n**Example:** Deleting an SLA Domain\n\nDelete an SLA Domain with the `id` of `$sla_id`.\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/sla_domain/$sla_id\"\n```\nThe Rubrik REST API server responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.\n\n## Inherited protection\n\nThe Rubrik REST API uses the reserved value `INHERIT` with the `configuredSlaDomainId` string to identify a snappable that derives its protection policy from a parent object. Examples of this:\n* VMware virtual machine inherits from vCenter Server\n* SQL Server database inherits from SQL Server instance\n\nEvery snappable that can be protected through an SLA Domain is represented by an object that has a `configuredSlaDomainId` attribute and an `effectiveSlaDomainId` attribute. The `configuredSlaDomainId` attribute contains either the value of a direct SLA Domain assignment or the reserved value `INHERIT`.\n\nThe `effectiveSlaDomainId` attribute contains the value of the SLA Domain setting that the Rubrik cluster actually applies to the snappable. When the value of the `configuredSlaDomainId` attribute is `INHERIT`, the value of the `effectiveSlaDomainId` attribute is derived from a parent object of the snappable. In all other cases, the value of the `effectiveSlaDomainId` attribute is the same as the value of the `configuredSlaDomainId` attribute.\n\n\n## SLA Domain assignments\n\nTo assign a snappable to an SLA Domain, use the endpoint that is provided for that type of snappable.\n* VMware virtual machines  \nSend a PATCH request to  [`/vmware/vm/{id}`](#operation/updateVm). [VMware virtual machines](#section/VMware-virtual-machines) provides more information about this.\n* Linux or Windows filesets  \nSend a PATCH request to  [`/fileset/{id}`](#operation/updateFileset). [Filesets](#section/Filesets) provides more information about this.\n* SQL Server databases  \nSend a PATCH request to  [`/mssql/db/{id}`](#operation/updateMssqlDb). [SQL Server databases](#section/SQL-Server-databases) provides more information about this.\n\n## Assigning SLA Domain to downloaded snapshots\n\nTo assign an SLA Domain to a list of snapshots at their downloaded locations,\nsend a POST request to the [`/sla_domain/assign_to_downloaded_snapshots`]\n(#operation/assignSlaToDownloadedSnapshots) endpoint.\n\n**Example:** Assigning an SLA Domain with ID $slaId to list of snapshots -\n             $s1Id, $s2Id of object $snappableId\n\n```bash\ncurl -X POST \\\n  -d '{\n   \"slaDomainId\": $slaId\n   \"objectId\": $snappableId\n   \"snapshotIds\": [$s1Id, $s2Id]}' \\\n   \"https://$cluster_address/api/v1/sla_domain/assign_to_downloaded_snapshots\"\n```\n\n```bash\n{\n  \"responses\": [\n    {\n      \"id\": \"string\",\n      \"status\": \"string\",\n      \"progress\": 0,\n      \"startTime\": \"2019-10-29T22:11:35.256Z\",\n      \"endTime\": \"2019-10-29T22:11:35.256Z\",\n      \"nodeId\": \"string\",\n      \"error\": {\n        \"message\": \"string\"\n      },\n      \"links\": [\n        {\n          \"href\": \"string\",\n          \"rel\": \"string\"\n        }\n      ]\n    }\n  ]\n}\n```\n\nThe Rubrik REST API server responds with HTTP response code 200 and the\nresponse body containing the details of the async request.\n\n# Virtual machines\n\nThe Rubrik cluster protects virtual machines running in a VMware vSphere\nenvironment through the VADP APIs. The Rubrik cluster also works with\nthe Rubrik Backup Service running on the virtual machine to provide:\n\n* Optimal performance when restoring files and folders to the virtual machine\n* Application consistent snapshots of a Windows virtual machine\n\n\n## vCenter servers\n\nA Rubrik cluster normally protects and manages virtual machines through the vCenter Server that administers those virtual machines. After a vCenter server is added to a Rubrik cluster, the Rubrik cluster automatically discovers the virtual machines that are administered by that vCenter server.\n\n### Retrieving vCenter Servers\n\nRequest a list of the vCenter servers that are registered with a Rubrik cluster by sending a GET request to  [`/vmware/vcenter`](#operation/queryVcenter).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/vcenter\"\n```\n\nThe Rubrik REST API server responds with the first page of a `ListResponse` object.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"id\": \"$vcenter_id0\",\n      \"hostname\": \"$vcenter_address0\",\n      \"username\": \"$vcenter_admin0\",\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"primaryClusterId\": \"$cluster_id\",\n      \"caCerts\": \"$ca_certs0\"\n    },\n    {\n      \"id\": \"$vcenter_id1\",\n      \"hostname\": \"$vcenter_address1\",\n      \"username\": \"$vcenter_admin1\",\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"primaryClusterId\": \"$cluster_id\",\n      \"caCerts\": \"$ca_certs1\"\n    }\n  ],\n  \"total\": 2\n}\n```\nDepending on the number of registered vCenter Servers, all of the entries on the list may not be included on the first page. [Working with lists](#section/Overview/Working-with-lists) describes how to work with a ListResponse object to obtain additional pages of the list.\n\n\n### Adding a vCenter server\n\nTo add a vCenter server, send a POST request to [`/vmware/vcenter`](#operation/createVcenter).\nInclude in the body of the request the address of the vCenter server and credentials for a user account (`username`) that has the required permissions. The Rubrik User Guide provides details about creating an account with the required permissions.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"hostname\": \"$vcenter_address\",\n    \"username\": \"$vcenter_admin\",\n    \"password\": \"$vcenter_password\" }' \\\n  \"https://$cluster_address/api/v1/vmware/vcenter\"\n```\n\nThe Rubrik REST API server initiates the asynchronous request task and responds with a task object.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"status\": \"RUNNING\",\n  \"error\": \"None\",\n  \"progress\": \"$request_progress\"\n  \"links\": [\n    {\n      href: \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",\n      rel: \"self\"\n    }\n  ]\n}\n```\n\nUsing the information provided in the task object, send a GET request to the [`/vmware/vcenter/request/{id}`](#operation/getVcenterAsyncRequestStatus) endpoint to poll the task status. When the value of `status` in the task object is `SUCCEEDED`, the task finished successfully.\n\n### Retrieve vCenter Server details\nGet the details for a vCenter Server that is registered with a Rubrik cluster by sending a GET request to [`/vmware/vcenter/{id}`](#operation/getVcenter).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/vcenter/{id}\"\n```\n\nThe Rubrik REST API server responds with the details of the specified vCenter Server object.\n\n```bash\n{\n  \"id\": \"$id\",\n  \"hostname\": \"$vcenter_address0\",\n  \"username\": \"$vcenter_admin0\",\n  \"configuredSlaDomainId\": \"INHERIT\",\n  \"primaryClusterId\": \"$cluster_id\"\n}\n```\n\n### Modifying a vCenter Server entry\n\nTo change the information that a Rubrik cluster stores for a vCenter Server, send a PUT request to [`/vmware/vcenter/{id}`](#operation/updateVcenter). All of the members of the `VcenterConfig` object must be in the PUT request. Using the new values, include in the body of the PUT request each member (`{string : value}`) of the `VcenterConfig` object:\n* `\"hostname\": \"$vcenter_address\"`\n* `\"username\": \"$vcenter_admin\"`\n* `\"password\": \"$vcenter_password\"`\n\nTo change the configured SLA that is configured for a vCenter Server or to change CA certificates for the vCenter, send a PATCH request to[`/vmware/vcenter/{id}`](#operation/patchVcenter).\n\n```bash\ncurl -X PUT \\\n  -d '{\n    \"hostname\": \"$vcenter_address\",\n    \"username\": \"$vcenter_admin\",\n    \"password\": \"$vcenter_password\" }' \\\n  \"https://$cluster_address/api/v1/vmware/vcenter/$vcenter_id\"\n```\n\nThe Rubrik REST API server sends a response, with the updated details of the vCenter Server entry in the response body.\n\n```bash\n{\n  \"id\": \"$vcenter_id\",\n  \"hostname\": \"$vcenter_address\",\n  \"username\": \"$vcenter_admin\",\n  \"configuredSlaDomainId\": \"INHERIT\",\n  \"primaryClusterId\": \"$cluster_id\",\n  \"caCerts\": \"$ca_certs\"\n}\n```\n### Removing a vCenter Server entry\n\nTo remove a vCenter Server entry from a Rubrik cluster, first unmount any Live Mount and Instant Recovery virtual machines for the vCenter Server. Then send a DELETE request to [`/vmware/vcenter/{id}`](#operation/deleteVcenter).\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/vmware/vcenter/$vcenter_id\"\n```\nThe Rubrik REST API server initiates the asynchronous delete task and responds with a task object.\n\n```bash\n{\n    \"id\": \"$request_id\",\n    \"status\": \"RUNNING\",\n    \"error\": \"None\",\n    \"progress\": 0,\n    \"startTime\": \"$start_timestamp\",\n    \"endTime\": \"$end_timestamp\",\n    \"links\": [\n      {\n        \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",\n        \"rel\": \"self\"\n      }\n    ]\n  }\n```\nUsing the information provided in the task object, send a GET request to poll the task status. When the value of `status` in the task object is `SUCCEEDED`, the removal of the vCenter Server object finished successfully.\n\n### Force refresh of virtual machine on a vCenter\nForce a refresh of the metadata for a single virtual machine by sending a POST\nrequest to [`/vmware/vcenter/{id}`](#operation/createRefreshVmV1).\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"vmMoid\": \"$vm_moid\" }' \\\n  \"https://$cluster_address/api/v1/vmware/vcenter/{id}/refresh_vm\"\n```\n\nThe Rubrik REST API server responds with a 204 response.\n\n\n\n### Metadata refresh\n\nThe Rubrik cluster regularly refreshes the metadata of the registered vCenter Servers. As part of a refresh operation, the Rubrik cluster discovers any changes or additions to the virtual machines that are administered by the vCenter Servers. Instead of waiting for a regular refresh, a metadata refresh can be manually initiated by sending a POST request to [`/vmware/vm/refresh`](#operation/createRefresh), using the Rubrik cluster ID (`$cluster_address`) and the vCenter Server ID (`$vcenter_id`).\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/vmware/vcenter/$vcenter_id/refresh\"\n```\n\nThe Rubrik REST API server initiates the asynchronous request task and responds with a task object.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"status\": \"RUNNING\",\n  \"error\": \"None\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\nUsing the information provided in the task object, send a GET request to poll the task status. When the value of `status` in the task object is `SUCCEEDED`, the metadata refresh completed successfully.\n\n## ESXi hypervisors\n\nRetrieve a list of all available ESXi hypervisors in the vSphere environment by sending a GET request to [`/vmware/host`](#operation/queryVmwareHost).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/host?primary_cluster_id=$cluster_id\"\n```\nThe value of `primary_cluster_id` is the `id` of a Rubrik cluster. Use `local` to retrieve a list for the Rubrik cluster that is hosting the current session.\n\nThe Rubrik REST API server responds with the first page of a `ListResponse` object.\n\n**Note:** To shorten the example, the response uses ellipsis to replace some members.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"id\": \"$esxi_id\",\n      \"name\": \"$esxi_name\",\n      \"datacenterId\": \"$datacenter_id\",\n      \"computeClusterId\": \"$compute_cluster_id\",\n      \"datastores\": [\n      ...\n      ],\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"primaryClusterId\": \"$cluster_id\"\n    }\n    ],\n  \"total\": 1\n}\n```\n\nRetrieve more details for an ESXi hypervisor by sending a GET request to [`/vmware/host/{id}`](#operation/getVmwareHost)\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/vmware/host/$esxi_id\"\n```\n\nThe Rubrik REST API server responds with the details for the specified ESXi hypervisor.\n\n**Note:** To shorten the example, the response uses ellipsis to replace some members.\n\n```bash\n{\n  \"id\": \"$esxi_id\",\n  \"moid\": \"$moid\",\n  \"name\": \"$esxi_name\",\n  \"computeClusterId\": \"$compute_cluster_id\",\n  \"datacenter\": {\n    \"id\": \"$datacenter_id\",\n    \"name\": \"$datacenter_name\",\n    \"vcenterId\": \"$vcenter_id\",\n    \"configuredSlaDomainId\": \"INHERIT\",\n    \"primaryClusterId\": \"$cluster_id\"\n  },\n  \"datastores\": [\n    ...\n  ],\n  \"virtualMachines\": [\n    ...\n  ],\n  \"configuredSlaDomainId\": \"INHERIT\",\n  \"primaryClusterId\": \"$cluster_id\"\n}\n```\n\nAdditionally, To change the SLA Domain that is configured for an ESXi hypervisor, send a PATCH request on [`/vmware/host`](#operation/updateVmwareHost)\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/vmware/host/$snapshot_id\"\n```\n\nRetrieve datastore details for an ESXi hypervisor by sending a GET request to [`/vmware/host/{id}/datastore`](#operation/getVmwareHostDatastore)\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/host/$esxi_id/datastore\"\n```\n\n\n## Virtual machine protection\n\nAfter a vCenter Server is registered, the Rubrik cluster acquires metadata for the virtual machines that are administered through that vCenter Server. Using the metadata, assign Rubrik cluster protection to the virtual machines.\n\nThe typical protection workflow involves the following tasks:\n1. Find the virtual machine resource object.\n2. (Optional) Enable scripts on the virtual machine.\n3. (Optional) Exclude specified vmdk files for the virtual machine.\n4. Assign the virtual machine to an SLA Domain.\n5. (Optional) Get the configuration used to force a full snapshot of the\n   virtual machine.\n6. (Optional) Request a forced full snapshot for the virtual machine.\n\n### Finding virtual machines\nGet a list of the virtual machine objects known to the Rubrik cluster by sending a GET request to [`/vmware/vm`](#operation/queryVm). The Rubrik REST API server returns a response that includes a `ListResponse` object. Use query parameters as part of the GET request, to filter the list and to work with the `ListResponse` object.\n\nA GET request that is sent to the [`/vmware/vm`](#operation/queryVm) endpoint accepts the query parameters that are described in the following table.\n| Parameter | Description |\n| --------- | ----------- |\n| `effective_sla_domain_id` | SLA Domain applied to the virtual machine, either directly or derived. Use `UNPROTECTED` for virtual machines that do not have a derived or direct SLA Domain. |\n| `primary_cluster_id` | The `id` of the primary Rubrik cluster for the virtual machine. Use `local` for the Rubrik cluster that is hosting the Rubrik REST API session. |\n| `limit` | Maximum number of a elements to include in the `data` array of the response. |\n| `offset` | Index reference point to use when determining the elements to include in the response. |\n| `is_relic` | Relic status of the virtual machine. `true` to specify only relic virtual machines. `false` to exclude relic virtual machines. Do not include the parameter to include both relic and non-relic virtual machines. |\n| `name` | String value to match in any part of the name of a virtual machine.  |\n| `moid` | String value to match in any part of the MOID of a virtual machine.  |\n| `sla_assignment` | SLA Domain assignment status of the virtual machine. Use `derived` for virtual machines that derive protection status from another resource object. Use `direct` for virtual machines that have a directly assigned SLA Domain. Use `unassigned` for virtual machines that do not have a direct or derived SLA Domain. |\n| `guest_os_name` | Filter by vm guest os name using infix search. |\n| `sort_by` | Perform an ASCII sort of the elements in the `ListResponse` object data array by a specified object value: `effective_sla_domain_id`, `name`, `moid`, `folderPath`, or `infraPath`. |\n| sort_order | Sort order for the elements in the ListResponse object data array. Use `asc` for ascending sort or `desc` for descending sort. |\n\n\n**Example:** Retrieving a list of virtual machine resource objects\n\nRetrieve a list of unprotected virtual machine resource objects that have 'test' in their name. Limit the first page of the response to the first object.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/vm?effective_sla_domain_id=UNPROTECTED&limit=1&offset=0&name=test\"\n```\nThe Rubrik REST API server responds with a `ListResponse` object. The first page has the first object of the 156 objects that matched the query parameters.\n\n**Note:** To shorten the example, the response uses ellipsis to replace some members.\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"$vm_id\",\n      \"moid\": \"$vm_moid\",\n      \"name\": \"abctest123\",\n      \"vcenterId\": \"$vcenter_id\",\n      \"hostName\": \"$esxi_host_name\",\n      \"hostId\": \"$esxi_host_id\",\n      \"clusterName\": \"$vcenter_cluster_name\",\n      \"powerStatus\": \"poweredOn\",\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"configuredSlaDomainName\": \"Inherit\",\n      \"effectiveSlaDomainId\": \"UNPROTECTED\",\n      \"effectiveSlaDomainName\": \"Unprotected\",\n      \"slaAssignment\": \"Unassigned\",\n      \"ipAddress\": \"$vm_ip\",\n      \"toolsInstalled\": true,\n      \"primaryClusterId\": \"$cluster_id\",\n      \"isReplicationEnabled\": false,\n      \"folderPath\": [\n        ...\n      ],\n      \"infraPath\": [\n        ...\n      ],\n      \"vmwareToolsInstalled\": true,\n      \"isRelic\": false,\n      \"maxNestedVsphereSnapshots\": -1,\n      \"snapshotConsistencyMandate\": \"UNKNOWN\",\n      \"physicalStorage\": 0,\n      \"guestCredentialAuthorizationStatus\": \"PENDING\"\n    }\n  ],\n  \"total\": 156\n}\n```\n\n### Retrieving more details for a virtual machine\nTo get detailed information for a specified virtual machine object, send a GET request to [`/vmware/vm/{id}`](#operation/getVm).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/vm/$vm_id\"\n```\nThe Rubrik REST API server responds with the details for the virtual machine object.\n\n**Note:** To shorten the example, the response uses ellipsis to replace some members.\n\n```bash\n{\n  \"id\": \"$vm_id\",\n  \"moid\": \"$vm_moid\",\n  \"name\": \"abctest123\",\n  \"powerStatus\": \"poweredOn\",\n  \"configuredSlaDomainId\": \"INHERIT\",\n  \"effectiveSlaDomain\": {\n    ...\n  },\n  \"slaAssignment\": \"Unassigned\",\n  \"blackoutWindowStatus\": {\n    \"isGlobalBlackoutActive\": false,\n    \"isSnappableBlackoutActive\": false\n  },\n  \"blackoutWindows\": {\n    ...\n    ],\n    \"snappableBlackoutWindows\": []\n  },\n  \"currentHost\": {\n    ...\n  },\n  \"virtualDiskIds\": [\n    ...\n  ],\n  \"snapshots\": [],\n  \"ipAddress\": \"$vm_ip\",\n  \"toolsInstalled\": true,\n  \"snapshotCount\": 0,\n  \"snapshotConsistencyMandate\": \"\",\n  \"maxNestedVsphereSnapshots\": -1,\n  \"primaryClusterId\": \"$cluster_id\",\n  \"isReplicationEnabled\": false,\n  \"isRelic\": false,\n  \"physicalStorage\": 0,\n  \"guestOsName\": \"$guest_os\",\n  \"guestCredentialAuthorizationStatus\": \"PENDING\",\n  \"isArrayIntegrationPossible\": false,\n  \"isArrayIntegrationEnabled\": false\n}\n```\n\n### Register Rubrik Backup Service\n\nTo register Rubrik Backup Service running on a specified virtual machine,\nsend a POST request to\n[`/vmware/vm/{id}/register_agent`](#operation/vmRegisterAgent).\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/vmware/vm/$vm_id/register_agent\"\n```\nThe Rubrik REST API server responds with an HTTP 204 response when the\nregistration is successful.\n\n\n### Enabling scripts\n\nA virtual machine object can be configured to start scripts on the guest operating system. A script can be started before the backup (`preBackupScript`), after the snapshot completes (`postSnapScript`), and after the backup task completes (`postBackupScript`). The *Rubrik User Guide* provides information about script requirements.\n\nTo configure a virtual machine object to start scripts, send a PATCH request to [`/vmware/vm/{id}`](#operation/updateVm). Since this is a PATCH request, only the elements of the virtual machine object that are modified or added should be included in the request body. All three script members are shown in the request body in this model, but all are optional.\n\n```bash\ncurl -X PATCH \\\n -d '{\n      \"preBackupScript\": {\n        \"scriptPath\": \"$pre_script_path\",\n        \"timeoutMs\": 10000,\n        \"failureHandling\": \"abort\"\n      },\n      \"postSnapScript\": {\n        \"scriptPath\": \"$postsnap_script_path\",\n        \"timeoutMs\": 10000,\n        \"failureHandling\": \"abort\"\n      },\n      \"postBackupScript\": {\n        \"scriptPath\": \"$postbackup_script_path\",\n        \"timeoutMs\": 10000,\n        \"failureHandling\": \"abort\"\n      }\n    }' \\\n  \"https://$cluster_address/api/v1/vmware/vm/$vm_id\"\n```\n\nThe Rubrik REST API server sends an HTTP 200 response that includes the modified or added members in the response body.\n\n#### Manually starting a virtual machine script\n\nFor testing or to run a script before running a backup, manually trigger the script by sending a POST request to [`/vmware/vm/{id}/guest_script/run`](#operation/runGuestOsScript). To manually start a script, the script must first be a part of the configuration of the virtual machine object. Use the value of the `phase` member to identify the script, as follows:\n* Use `PreBackup` for the script identified by the `preBackupScript` member.\n* Use `PostSnap` for the script identified by the `postSnapScript` member.\n* Use `PostBackup` for the script identified by the `postBackupScript` member.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"phase\": \"PreBackup\" }' \\\n  \"https://$cluster_address/api/v1/vmware/vm/$vm_id/guest_script/run\"\n```\nThe Rubrik REST API server responds with an HTTP 204 response when the script finishes with a 0 exit code.\n\n\n### Excluding a VMDK file\n\nThe Rubrik cluster can be configured to ignore some of the VMDK files of a virtual machine while protecting the other VMDK files of that virtual machine. To exclude a VMDK file, send a GET request to [`/vmware/vm/virtual_disk/{id}`](#operation/getVirtualDisk) using the `$disk_id` of the VMDK file.\n\nTo get the `$disk_id` values, send a GET request to [`/vmware/vm/{id}`](#operation/getVm). The response body has the `disk_id` values for the virtual machine in the `virtualDiskIds` array.\n\nAfter identifying the `$disk_id` for a VMDK file, obtain the current state of the VMDK file.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/vm/virtual_disk/$disk_id\"\n```\nThe Rubrik REST API server responds with the value of `excludeFromSnapshots`.\n\n```bash\n{\n  \"id\": \"$disk_id\",\n  \"excludeFromSnapshots\": false\n}\n```\nWhen the value is `false` the Rubrik cluster is not configured to exclude the VMDK file. Change this value to `true` to instruct the Rubrik cluster to exclude the VMDK file from all subsequent snapshots of the virtual machine.\n\nSend a PATCH request to [`/vmware/vm/virtual_disk/{id}`](#operation/updateVirtualDisk) to change the value of `excludeFromSnapshots` to `true` and exclude the VMDK file.\n\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"excludeFromSnapshots\": true }' \\\n  \"https://$cluster_address/api/v1/vmware/vm/virtual_disk/$disk_id\"\n```\n\nThe Rubrik REST API server responds with the updated `excludeFromSnapshots` value for the VMDK file.\n\n```bash\n{\n  \"id\": \"$disk_id\",\n  \"excludeFromSnapshots\": true\n}\n```\n\n### Assigning a virtual machine to an SLA Domain\nTo protect a virtual machine through the rules and policies of an SLA Domain send a PATCH request to [`/vmware/vm/{id}`](#operation/updateVm) with the value of `configuredSlaDomainId` set to the `$sla_domain_id`.\n\n**Note:** [Retrieving SLA Domains](#section/SLA-Domains/Retrieving-SLA-Domains) describes how to retrieve the SLA Domain objects on a Rubrik cluster.\n\n```bash\ncurl -X PATCH -d \\\n  '{\n    \"configuredSlaDomainId\": \"$sla_domain_id\"\n  }' \\\n  \"https://$cluster_address/api/v1/vmware/vm/$vm_id\"\n```\nThe Rubrik REST API server responds with confirmation of the assignment.\n\n```bash\n{\n  \"id\": \"$vm_id\",\n  \"configuredSlaDomainId\": \"$sla_domain_id\"\n}\n```\n### Getting the configuration used to force a full snapshot of a virtual machine\n\nTo retrieve the configuration of a virtual machine that is used to force a full\nsnapshot of the virtual machine, send a GET request to\n[`/vmware/vm/{id}/request/force_full_snapshot`](#operation/getVmForceFullSpec).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/vm/{id}/request/force_full_snapshot\"\n```\n\nThe Rubrik REST API server responds with the force full snapshot object\nwhich contains the latest configuration of the virtual machine.\n\n```bash\n{\n  \"vmId\": \"$vm_id\",\n  \"virtualDiskInfos\": [\n    {\n      \"virtualDiskId\": \"$disk_id\",\n      \"shouldDedupe\": false\n    },\n    {\n      \"virtualDiskId\": \"$disk_id\",\n      \"shouldDedupe\": true\n    }\n  ]\n}\n```\n### Requesting a forced full snapshot for a virtual machine\n\nTo force a full snapshot of a virtual machine, send a POST request to\n[`/vmware/vm/{id}/request/force_full_snapshot`](#operation/requestVmForceFullSnapshot).\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/vmware/vm/{id}/request/force_full_snapshot\"\n```\n\nThe Rubrik REST API server persists the configuration for forcing a\nfull snapshot until the next backup job, which takes a full snapshot\nand clears the configuration.\n\n```bash\n{\n  \"vmId\": \"$vm_id\",\n  \"virtualDiskInfos\": [\n    {\n      \"virtualDiskId\": \"$disk_id\",\n      \"shouldDedupe\": false\n    },\n    {\n      \"virtualDiskId\": \"$disk_id\",\n      \"shouldDedupe\": true\n    }\n  ]\n}\n```\n## Snapshot management\n\nManaging snapshots includes the following possible actions:\n* Retrieving snapshot information\n* Retrieving snapshot information for multiple virtual machines\n* Retrieving snapshot details\n* Retrieving missed snapshot information\n* Creating on-demand snapshots\n* Expiring individual snapshots\n* Expiring all snapshots for a virtual machine\n\n### Retrieving snapshot information\n\nTo retrieve a list of the snapshots for a virtual machine, send a GET request to [`/vmware/vm/{id}/snapshot`](#operation/querySnapshot).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/vm/$vm_id/snapshot\"\n```\nThe Rubrik REST API server responds with a `ListResponse` object.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"date\": \"$timestamp0\",\n      \"indexState\": 0,\n      \"cloudState\": 0,\n      \"vmName\": \"$vm_name\",\n      \"replicationLocationIds\": [],\n      \"id\": \"$snapshot_id0\",\n      \"consistencyLevel\": \"$consistency_level0\",\n      \"archivalLocationIds\": [],\n      \"isOnDemandSnapshot\": false\n    },\n    {\n      \"date\": \"$timestamp1\",\n      \"indexState\": 0,\n      \"cloudState\": 0,\n      \"vmName\": \"$vm_name\",\n      \"replicationLocationIds\": [],\n      \"id\": \"$snapshot_id1\",\n      \"consistencyLevel\": \"$consistency_level1\",\n      \"archivalLocationIds\": [],\n      \"isOnDemandSnapshot\": true\n    }\n ],\n \"total\": 2\n}\n```\nEach member of the data array includes the `id` of a snapshot. Use this value (`$snapshot_id`) to perform tasks with the snapshot, such as:\n* Browsing for data in the snapshot\n* Downloading data from the snapshot\n* Restoring data from the snapshot\n* Exporting data from the snapshot\n* Mounting a virtual machine from the snapshot\n\n### Retrieving snapshot information for a batch of virtual machines\n\nTo retrieve lists of snapshots for a batch of virtual machines, send a POST request to [`/vmware/vm/snapshots`](#operation/querySnapshotsForVms).\nThis reuqest taks a list of virtual mahine IDs.\n\n```bash\ncurl -X POST \\\n  -d '{\n     \"vm_ids\": [\"vmId_1\", \"vmId_2\"]\n     }'\\\n      \"https://$cluster_address/api/v1/vmware/vm/snapshots\"\n```\n\nThe Rubrik REST API server responds with a `BatchVmSnapshotSummaries`\nobject.\n\n```bash\n{\n  \"responses\":\n  [\n    {\n      \"vmId\": \"vmId_1\",\n      \"VmSnapshotSummaries\":\n      [\n        {\n          \"date\": \"$timestamp0\",\n          \"indexState\": 0,\n          \"cloudState\": 0,\n          \"vmName\": \"$vm_name\",\n          \"replicationLocationIds\": [],\n          \"id\": \"$snapshot_id0\",\n          \"consistencyLevel\": \"$consistency_level0\",\n          \"archivalLocationIds\": [],\n          \"isOnDemandSnapshot\": false\n        }\n      ]\n    },\n    {\n      \"vmId\": \"vmId_2\",\n      \"VmSnapshotSummaries\":\n      [\n        {\n          \"date\": \"$timestamp0\",\n          \"indexState\": 0,\n          \"cloudState\": 0,\n          \"vmName\": \"$vm_name\",\n          \"replicationLocationIds\": [],\n          \"id\": \"$snapshot_id0\",\n          \"consistencyLevel\": \"$consistency_level0\",\n          \"archivalLocationIds\": [],\n          \"isOnDemandSnapshot\": false\n        }\n      ]\n    }\n  ]\n}\n```\n\n### Retrieving snapshot details\n\nTo retrieve details for a specified snapshot send a GET request to [`/vmware/vm/snapshot/{id}`](#operation/getSnapshot).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id\"\n```\nThe Rubrik REST API server responds with the details of the specified snapshot.\n\n**Note:** To shorten the example, the response uses ellipsis to replace some members.\n\n```bash\n{\n  \"date\": \"$timestamp\",\n  \"indexState\": 0,\n  \"virtualMachine\": {\n   ...\n  },\n  \"vmName\": \"$vm_name\",\n  \"isCorrupt\": false,\n  \"replicationLocationIds\": [],\n  \"archivalLocationIds\": [],\n  \"snapshotDiskIds\": [\n    \"$vmdk_id\"\n  ],\n  \"isOnDemandSnapshot\": false,\n  \"cloudState\": 0,\n  \"id\": \"$snapshot_id\",\n  \"consistencyLevel\": \"1\",\n  \"config\": \"[]\"\n}\n```\n\n### Retrieving missed snapshot information\n\nThe Rubrik cluster stores information for missed snapshots. *Missed snapshots* are snapshot tasks that are not completed as required by the rules and policies of an SLA Domain.  Retrieve missed snapshot information for a virtual machine by sending  a GET request to [`/vmware/vm/{id}/missed_snapshot`](#operation/missedSnapshots).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/vm/$vm_id/missed_snapshot\"\n```\nThe Rubrik REST API server responds with a `ListResponse` object.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"archivalLocationType\": [\n        \"missed\"\n      ],\n      \"missedSnapshotTime\": \"$timestamp0\"\n    },\n    {\n      \"archivalLocationType\": [\n        \"missed\"\n      ],\n      \"missedSnapshotTime\": \"$timestamp1\"\n    }\n  ],\n  \"total\": 2\n}\n```\n\n### Creating on-demand snapshots\n\nOn-demand snapshots can be created for both protected and unprotected virtual machines. To create an on-demand snapshot of a virtual machine send a POST request to [`/vmware/vm/{id}/snapshot`](#operation/createOnDemandBackup).\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/vmware/vm/$vm_id/snapshot\"\n```\nThe Rubrik REST API server initiates the asynchronous snapshot task and responds with a task object.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"status\": \"ACQUIRING\",\n  \"progress\": 0,\n  \"startTime\": \"$timestamp\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\nUsing the information provided in the task object, send a GET request to poll the task status. When the value of `status` in the task object is `SUCCEEDED`, the on-demand snapshot finished successfully.\n\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\"\n```\nThe Rubrik REST API server sends a task object with `status=\"SUCCEEDED\"`.  The task object for a successful snapshot includes the URI for the snapshot: `https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id`.\n\n```bash\n{\n  \"id\":\"$request_id\",\n  \"status\":\"SUCCEEDED\",\n  \"startTime\":\"$timestamp0\",\n  \"endTime\":\"$timestamp1\",\n  \"links\":[\n    {\n      \"href\":\"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id\",\n      \"rel\":\"result\"\n    },\n   {\n      \"href\":\"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",\n      \"rel\":\"self\"\n   }\n  ]\n}\n```\n\n### Expiring individual snapshots\n\nOn-demand snapshots and snapshots for unprotected virtual machines can be expired by using the snapshot `id`. To expire an individual snapshot, send a DELETE request to [`/vmware/vm/snapshot/{id}`](#operation/deleteVmwareSnapshot). Include the query parameter `location` to specify whether to expire all copies of the snapshot, or only the local copy. Use `location=local` to expire only the copy of the snapshot on the specified Rubrik cluster. Use `location=all` to expire all copies of the snapshot, including replicas and archival copies.\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id?location=$snapshot_location\"\n```\nThe Rubrik REST API server expires the specified snapshot and responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.\n\nThe Rubrik REST API server responds with HTTP response code 422 'Unprocessable Entity', when the specified snapshot is not one of the following:\n* On-demand snapshot\n* Snapshot for an unprotected virtual machine\n\n### Expiring all snapshots for a virtual machine\n\nAll snapshots for an unprotected virtual machine can be expired by using the virtual machine `id`. To expire all snapshots for an unprotected virtual machine, send a DELETE request to [`/vmware/vm/{id}/snapshot`](#operation/deleteVmwareSnapshots). The Rubrik cluster expires all snapshots, replicas, and archival snapshots for the specified virtual machine.\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/vmware/vm/$vm_id/snapshot\"\n```\nThe Rubrik REST API server expires all snapshots for the specified virtual machine in all locations and responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.\n\nThe Rubrik REST API server responds with HTTP response code 422 'Unprocessable Entity', when the specified virtual machine is protected through an SLA Domain assignment.\n\n\n\n\n## Data recovery\nTo recover a file or folder from a snapshot, retrieve the `id` of the file or folder using either search or browse. Then use the `id` with one of the recovery methods:\n* Download the file or folder\n* Restore the file or folder to the source location\n* Export the file or folder to another host\n\n### Searching for data in snapshots\n\nSearch for files and folders across all indexed snapshots of a virtual machine by using the virtual machine `id`. Send a GET request to [`/vmware/vm/{id}/search`](#operation/searchVm) with the `path` query parameter. Use a path segment string or a name segment string for the value of `path`.\n\n**IMPORTANT:** The snapshot used in this task must be indexed. Indexing makes the file system structure of the data available to the Rubrik cluster. To determine whether a snapshot has been successfully indexed, send a GET request to [`/vmware/vm/snapshot/{id}`](#operation/getSnapshot) as described in the 'Retrieving snapshot information' section of [Snapshot management](#section/Virtual-machines/Snapshot-management). Look at the value of `indexState`. A value of `1` means the snapshot has been indexed. A value of `0` means the snapshot has not been indexed.\n\nThe Rubrik REST API server uses the rules described in the following table when matching the value of `path` with folders and files in the indexed snapshots.\n| Type | Rule | Description |\n| ---- | ---- | ----------- |\n| Path delimiter | Forward slashes and backslashes are equally recognized as path delimiters. | In the value of path, `/` matches both `/` and `\\`, and `\\` matches both `/` and `\\`. |\n| Path segments | Path segments match all files and folders that begin with the same path segment. | For example, '/abc/x' matches files and folders at '/abc/' or '\\abc\\\\' with a filename or folder name that starts with 'x'. |\n| Name segments | Name segments match all files and folders that begin with the same name segment. | For example, 'xyz' matches files and folders with a filename or folder name that starts with 'xyz', in all path locations. |\n| Characters | Any character that the guest operating system accepts in a file path can be used.  | For example, the greater than symbol `>` and the lesser than symbol `<` are not allowed. |\n| Windows drive | To specify a full path on a Windows guest follow the Windows file system requirement. | For example, to specify the 'temp' folder on the 'D' drive of a Windows virtual machine, use: `D:\\temp`. |\n\n**Example:** Searching for files and folders\n\nSearch for all files and folders in '/usr/local/' with a name that starts with the later 'g'.\n\nSend a GET request to [`/vmware/vm/{id}/search`](#operation/searchVm) with `path=/usr/local/g`.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/vm/$vm_id/search?path=%2Fusr%2Flocal%2Fg\"\n```\nThe Rubrik REST API server responds with a `ListResponse` object. The data array has two members, a directory at: `/usr/local/games` and a file at: `/usr/local/gamehints`.\n\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"path\": \"/usr/local/games\",\n      \"filename\": \"games\",\n      \"fileVersions\": [\n        {\n          \"lastModified\": \"$timestamp0\",\n          \"size\": 4096,\n          \"snapshotId\": \"$snapshot_id0\",\n          \"fileMode\": \"directory\",\n          \"source\": \"cloud\"\n        }\n      ]\n    },\n    {\n    \"path\": \"/usr/local/gamehints\",\n    \"filename\": \"gamehints\",\n    \"fileVersions\": [\n      {\n        \"lastModified\": \"$timestamp1\",\n        \"size\": 14480,\n        \"snapshotId\": \"$snapshot_id1\",\n        \"fileMode\": \"file\",\n        \"source\": \"cloud\"\n      },\n      {\n        \"lastModified\": \"$timestamp2\",\n        \"size\": 14480,\n        \"snapshotId\": \"$snapshot_id2\",\n        \"fileMode\": \"file\",\n        \"source\": \"cloud\"\n      }\n    ]\n   }\n  ],\n  \"total\": 2\n}\n```\n\n### Browsing for data in snapshots\n\nBrowse for files and folders with an indexed snapshot by using the snapshot `id`. Send a GET request to  [`/vmware/vm/snapshot/{id}/browse`](#operation/browseVmwareSnapshot) with the `path` query parameter.  Use a path segment string for the value of `path`. The response provides a ListResponse object that includes all of the files and folders in the directory that is specified by the value of `path`.\n\n**IMPORTANT:** The snapshot used in this task must be indexed. Indexing makes the file system structure of the data available to the Rubrik cluster. To determine whether a snapshot has been successfully indexed, send a GET request to [`/vmware/vm/snapshot/{id}`](#operation/getSnapshot) as described in the 'Retrieving snapshot information' section of [Snapshot management](#section/Virtual-machines/Snapshot-management). Look at the value of `indexState`. A value of `1` means the snapshot has been indexed. A value of `0` means the snapshot has not been indexed.\n\nThe Rubrik REST API server uses the rules described in the following table when matching the value of `path` with the path in the specified snapshot.\n| Type | Rule | Description |\n| ---- | ---- | ----------- |\n| Path delimiter | Forward slashes and backslashes are equally recognized as path delimiters. | In the value of path, `/` matches both `/` and `\\`, and `\\` matches both `/` and `\\`. |\n| Path description | The path description must end in a directory name, without an ending slash. | For example, '/abc/x' returns all files and folders in the directory at '/abc/x', but '/abc/x/' returns an HTTP 422 response. |\n| Characters | Any character that the guest operating system accepts in a file path can be used.  | For example, the greater than symbol `>` and the lesser than symbol `<` are not allowed. |\n| Windows drive | To specify a full path on a Windows guest follow the Windows file system requirement. | For example, to specify the 'temp' folder on the 'D' drive of a Windows virtual machine, use: `D:\\temp`. |\n\n**Example:** Browsing for files and folders\n\nRetrieve a ListResponse object with all of the files and folders in '/home'.\n\nSend a GET request to  [`/vmware/vm/snapshot/{id}/browse`](#operation/browseVmwareSnapshot) with `path=/home`.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/browse?path=%2Fhome&offset=0\"\n```\nThe Rubrik REST API server responds with a `ListResponse` object. The data array has two members, the directory: `ubuntu` and the file: `ubuntu.tar`.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"filename\": \"ubuntu\",\n      \"path\": \"ubuntu\",\n      \"lastModified\": \"$timestamp0\",\n      \"size\": 31892819777,\n      \"fileMode\": \"directory\",\n      \"statusMessage\": \"\"\n    },\n    {\n      \"filename\": \"ubuntu.tar\",\n      \"path\": \"ubuntu.tar\",\n      \"lastModified\": \"$timestamp1\",\n      \"size\": 4746675383,\n      \"fileMode\": \"file\",\n      \"statusMessage\": \"\"\n    }\n  ],\n  \"total\": 2\n}\n```\n### Downloading data from a snapshot\n\nData can be retrieved from a snapshot by creating a download link for an individual file and folder from the snapshot. To have the Rubrik cluster create a download link, send a POST request to [`/vmware/vm/snapshot/{id}/download`](#operation/createDownloadFileJob). Include in the request body the string/value pair: `\"path\":\"$path\"`, where `$path` is the full path to the file or folder. When `$path` refers to a folder, the Rubrik cluster creates a ZIP file of the folder and all that it contains.\n\nThe basic download work flow is:\n1. Send a POST request to start the asynchronous download task.\n2. Send a GET request to poll the task status.\n3. When the task succeeds, use the download link provided in the response body to retrieve the file or folder.\n\n**IMPORTANT:** The snapshot used in this task must be indexed. Indexing makes the file system structure of the data available to the Rubrik cluster. To determine whether a snapshot has been successfully indexed, send a GET request to [`/vmware/vm/snapshot/{id}`](#operation/getSnapshot) as described in the 'Retrieving snapshot information' section of [Snapshot management](#section/Virtual-machines/Snapshot-management). Look at the value of `indexState`. A value of `1` means the snapshot has been indexed. A value of `0` means the snapshot has not been indexed.\n\n```bash\ncurl -X POST -d \\\n'{\n   \"path\": \"$full_source_path\"\n }' \\\n 'https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/download_file'\n```\nThe Rubrik REST API server initiates the asynchronous request task and responds with a task object.\n\n```bash\n{\n  \"id\": \"$download_task_id\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$timestamp\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Restoring data from a snapshot\n\nTo restore a file or folder to the source virtual machine send a POST request to [`/vmware/vm/snapshot/{id}/restore_file`](#operation/createRestoreFileJob). With the request, include a request body. The following table describes the members of the request body.\n\n| Name | Description |\n| ---- | ----------- |\n| `path` | Full path of the file or folder. |\n| `domainName` | Authentication domain for the credentials being used to authenticate and authorize the action. |\n| `username` | Username of account to authenticate and authorize the action. |\n| `password` | Password for the account to authenticate and authorize the action. |\n| `restorePath` | Full path location for the restore of the file or folder. The action can create a directory at the end of the specified path, but cannot create directories that are specified within the path. |\n| `shouldUseAgent` | Instruct the Rubrik cluster to restore the file using Rubrik Backup Service running on virtual machine. Use `true` to restore using RBS and `false` to restore using `VMware tools`. |\n| `shouldSaveCredentials` | Instruct the Rubrik cluster to save the credentials included in the request. Use `true` to save the credentials and `false` to use the credentials only for the current request. |\n| `shouldRestoreXAttrs` | Instruct the Rubrik cluster to restore the\nextended attributes of all files and folders included in the `path`.\nWhen restoring to a Linux host, extended attributes are restored.\nWhen restoring to a Windows host, alternate data streams (ADS) are\nrestored. Use `true` to restore this metadata and `false` otherwise. |\n\n```bash\ncurl -X POST -d \\\n'{\n   \"path\": \"$full_source_path\",\n   \"domainName\": \"$auth_domain\",\n   \"username\": \"$username\",\n   \"password\": \"$password\",\n   \"restorePath\": \"$full_restore_path\",\n   \"shouldUseAgent\" : true,\n   \"shouldSaveCredentials\": true,\n   \"shouldRestoreXAttrs\": true\n }' \\\n \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/restore_file\"\n```\n\nThe Rubrik REST API server initiates the asynchronous request task and responds with a task object.\n\n```bash\n{\n  \"id\": \"$restore_task_id\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$timestamp\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n\n## Snapshot mount operations\nSnapshot mount operations include the following possible actions:\n* Retrieving a snapshot from an archival location\n* Mounting a snapshot by using Instant Recovery\n* Mounting a snapshot by using Live Mount\n* Mounting a snapshot for a batch of virtual machines using Live Mount\n* Exporting a snapshot\n* Downloading a snapshot from an archival location and then exporting it\n* Changing the properties of a mounted virtual machine\n* Removing a virtual machine mount\n* Migrating a datastore for a virtual machine from Live Mount or Instant Recovery\n\n### Retrieving a snapshot from an archival location\n\nTo work with a snapshot that is stored only at an archival location, first download the snapshot to the Rubrik cluster by sending a POST request to [`/vmware/vm/snapshot/{id}/download`](#operation/createDownloadSnapshotFromCloud).\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/download\"\n```\nThe Rubrik REST API server initiates the asynchronous request task and responds with a task object.\n\n```bash\n{\n  \"id\": \"$snap_download_task_id\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$timestamp\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Mounting a snapshot by using Instant Recovery\n\nReplace a source virtual machine from a snapshot by using the Instant Recovery feature. To use Instant Recovery, send a POST request to [`/vmware/vm/snapshot/{id}/instant_recover`](#operation/createInstantRecovery). This request requires a snapshot `id` and can optionally include the parameters that are described in the following table.\n\n| Name | Description |\n| ---- | ----------- |\n| `hostId` | The `id` of an ESXi hypervisor. When not specified, the Rubrik cluster uses the original hypervisor. |\n| `vmName` | Assigns a specified name to the virtual machine. |\n| `removeNetworkDevices` | Determines whether the virtual machine has network devices. Use `true` to remove network devices from the virtual machine. Use `false` to keep the existing network devices. |\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"vmName\": \"$vm_name\",\n    \"hostId\": \"$esxi_id\",\n    \"removeNetworkDevices\": true\n   }' \\\n   \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/instant_recover\"\n```\nThe Rubrik REST API server initiates the asynchronous request task and responds with a task object.\n\n```bash\n{\n  \"id\": \"$instant_recovery_task_id\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$timestamp\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Mounting a snapshot by using Live Mount\n\nMount a new virtual machine from a snapshot by using the Live Mount feature. To use Live Mount, send a POST request to [`/vmware/vm/snapshot/{id}/mount`](#operation/createMountV1). This request requires a snapshot `id` and can optionally include the parameters that are described in the following table.\n\n| Name | Description |\n| ---- | ----------- |\n| `hostId` | The `id` of an ESXi hypervisor. When not specified, the Rubrik cluster uses the original hypervisor. |\n| `vmName` | Assigns a specified name to the virtual machine. |\n| `dataStoreName` | Obsolete paraemeter. |\n| `disableNetwork` | Determines whether the virtual machine has access to the network. Use `true` to Mount the snapshot with network access disabled. Use `false` to allow the virtual machine to access the network. |\n| `removeNetworkDevices` | Determines whether the virtual machine has network devices. Use `true` to remove network devices from the virtual machine. Use `false` to keep the existing network devices. |\n| `powerOn` | Determines whether the virtual machine is powered on after mounting. Use `true` to power on the virtual machine. Use `false` to leave the virtual machine powered off after mounting. |\n\n\n```bash\ncurl -X POST \\\n  -d '{\n     \"hostId\": \"$esxi_id\",\n     \"vmName\": \"$vm_name\",\n     \"dataStoreName\": \"$datastore_name\",\n     \"disableNetwork\": $network_state,\n     \"removeNetworkDevices\": $network_devices_state,\n     \"powerOn\": $power_state\n   }'\\\n    \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/mount\"\n```\n\nThe Rubrik REST API server initiates the asynchronous request task and responds with a task object.\n\n```bash\n{\n  \"id\": \"$live_mount_task_id\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$timestamp\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Mounting a snapshot for a batch of virtual machines using Live Mount\n\nMount a snapshot each for a batch of virtual machines. Send a POST request to\n[`/vmware/vm/batch_mount`](#operation/batchMountSnapshot). This request\nrequires a snapshots parameter to identify the virtual machine and the snapshot\nof the virtual machine to mount.\nThe following parameters are available to identify the snapshot: `snapshotId`,\n`snapshotBeforeDate`, and `snapshotAfterDate`. One of the parameters must be configured\nto identify the snapshot to be mounted.\n\n| Name | Required | Type | Description |\n| ---- | -------- | ---- | ----------- |\n| `vmId` | Required | String | The `id` of the virtual machine. |\n| `snapshotId` | Optional | String | The `id` of the snapshot to mount. |\n| `snapshotBeforeDate` | Optional | Date | If the snapshotId is not specified, mount the newest snapshot before the date specified for this parameter. |\n| `snapshotAfterDate` | Optional | Date | If the snapshotId and the snapshotBeforeDate are not specified, mount the oldest snapshot after the date specified for this parameter. |\n| `config` | Required | Object | [Properties of the /vmware/vm/snapshot/{id}/mount endpoint.](#mounting-a-snapshot-by-using-live-mount) |\n\n```bash\ncurl -X POST \\\n  -d '{\n     \"snapshots\": [\n       {\n         \"vmId\": \"$vm_id\",\n         \"snapshotBeforeDate\": \"$timestamp\",\n         \"config\": {\n           \"hostId\": \"$esxi_id\",\n           \"vmName\": \"$vm_name\",\n           \"dataStoreName\": \"$datastore_name\",\n           \"disableNetwork\": $network_state,\n           \"removeNetworkDevices\": $network_devices_state,\n           \"powerOn\": $power_state\n         }\n       }\n     ]\n     }'\\\n      \"https://$cluster_address/api/v1/vmware/vm/batch_mount\"\n```\n\nThe Rubrik REST API server initiates a batch of mount jobs and\nresonds with objects tracking the job status.\n\n```bash\n{\n  \"responses\": [\n    {\n      \"id\": \"$live_mount_task_id\",\n      \"status\": \"QUEUED\",\n      \"progress\": 0,\n      \"startTime\": \"$timestamp\",\n      \"links\": [\n        {\n          \"href\": \"https://$cluster_address/api/v1/vmware/request/$request_id\",\n          \"rel\": \"self\"\n        }\n      ]\n    }\n  ]\n}\n```\n### Retrieving the ID of the mount\n\nAfter a mount task successfully completes, the `id` of the mount object can be retrieved by sending a GET request to [`/vmware/vm/request/{id}`](#operation/getAsyncRequestStatus) and using the `$request_id` value from the original request object for the Live Mount.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\"\n```\nThe Rubrik REST API server responds with a request object that includes the `id` of the mount object.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vm/snapshot/mount/$mount_id\",\n      \"rel\": \"result\"\n    },\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"SUCCEEDED\"\n}\n```\n### Retrieving active mounts\n\nTo retrieve a list of all of the active mounts for a Rubrik cluster, send a GET request to [`/vmware/vm/snapshot/mount`](#operation/queryMountV1).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/vm/snapshot/mount\"\n```\nThe Rubrik REST API server responds with a ListResponse object.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"id\": \"$mount_id\",\n      \"snapshotDate\": \"$snapshot_timestamp\",\n      \"vmId\": \"$source_vm_id\",\n      \"mountedVmId\": \"$mounted_vm_id\",\n      \"hostId\": \"$esxi_id\",\n      \"isReady\": true\n    }\n  ],\n  \"total\": 1\n}\n```\n### Retrieving the details for a mount\n\nTo retrieve details about a specific mount, send a GET request to [`/vmware/vm/snapshot/mount/{id}`](#operation/getMountV1).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/vm/snapshot/mount/$mount_id\"\n```\nThe Rubrik REST API server responds with the details.\n\n```bash\n{\n  \"snapshotDate\": \"$timestamp\",\n  \"vmId\": \"$source_vm_id\",\n  \"isReady\": true,\n  \"hostId\": \"$esxi_id\",\n  \"id\": \"$mount_id\",\n  \"mountedVmId\": \"$mounted_vm_id\"\n}\n```\n\n### Exporting a snapshot\n\nTo export a snapshot send a POST request to\n[`/vmware/vm/snapshot/{id}/export`](#operation/createExportV1). This request\nrequires a snapshot `id` and the parameters that are described in the\nfollowing table.\n\n| Name | Description |\n| ---- | ----------- |\n| `datastoreId` | The `id` of a datastore for the specified ESXi hypervisor. |\n| `vmName` | Assigns a specified name to the virtual machine. |\n| `hostId` | The `id` of an ESXi hypervisor. |\n| `disableNetwork` | Determines whether the virtual machine has access to the network. Use `true` to Mount the snapshot with network access disabled. Use `false` to allow the virtual machine to access the network. |\n| `removeNetworkDevices` | Determines whether the virtual machine has network devices. Use `true` to remove network devices from the virtual machine. Use `false` to keep the existing network devices. |\n| `powerOn` | Determines whether the virtual machine is powered on after mounting. Use `true` to power on the virtual machine. Use `false` to leave the virtual machine powered off after mounting. |\n| `unregisterVm` | Determines whether to add the exported virtual machine to the vCenter Server inventory. Use `true` to remove the exported virtual machine from the associated vCenter Server inventory. Use `false` to add the exported virtual machine to the associated vCenter Server inventory. |\n\n\n```bash\ncurl -X  -d \\\n '{\n   \"datastoreId\": \"string\",\n   \"vmName\": \"string\",\n   \"hostId\": \"string\",\n   \"disableNetwork\": true,\n   \"removeNetworkDevices\": true,\n   \"powerOn\": true,\n   \"unregisterVm\": true\n }' \\\n \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/export\"\n```\n\nThe Rubrik REST API server initiates the asynchronous request task and responds with a task object.\n\n```bash\n{\n  \"id\": \"$export_task_id\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$timestamp\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Exporting a snapshot from an archival location\n\nTo export a snapshot from an archival location, send a POST\nrequest to [`/vmware/vm/snapshot/{id}/export_with_download`]\n(#operation/createExportWithDownloadFromCloudV1). This request requries\na snapshot `id` and the parameters that are described in the following table.\n\n| Name | Description |\n| ---- | ----------- |\n| `datastoreId` | `id` of a datastore for the specified ESXi hypervisor. |\n| `vmName` | Assigns a name to the virtual machine. |\n| `hostId` | `id` of an ESXi hypervisor. |\n| `disableNetwork` | Determines if the virtual machine has access to the\n                     network. `true` mounts the snapshot with network\n                     access disabled. `false` allows the virtual machine\n                     to access the network. |\n| `removeNetworkDevices` | Determines if the virtual machine includes network\n                           devices. `true` removes network devices from\n                           the virtual machine.`false` keeps the existing\n                           network devices. |\n| `powerOn` | Determines if the virtual machine is powered on after\n              mounting. `true` powers on the virtual machine. `false`\n              leaves the virtual machine powered off after mounting. |\n| `unregisterVm` | Determines if the exported virtual machine is added to\n                   the vCenter Server inventory. `true` removes the exported\n                   virtual machine from the associated vCenter Server\n                   inventory. `false` adds the exported virtual machine\n                   to the associated vCenter Server inventory. |\n\n```bash\ncurl -X  -d \\\n '{\n   \"datastoreId\": \"string\",\n   \"vmName\": \"string\",\n   \"hostId\": \"string\",\n   \"disableNetwork\": true,\n   \"removeNetworkDevices\": true,\n   \"powerOn\": true,\n   \"unregisterVm\": true\n }' \\\n \"https://$cluster_address/api/v1/vmware/vm/snapshot/$id/export_with_download\"\n```\n\nThe Rubrik REST API server initiates the asynchronous request task and responds\nwith a task object.\n\n```bash\n{\n  \"id\": \"$download_task_id\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$timestamp\",\n  \"links\": [\n    {\n      \"href\":\n         \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Changing power status of a mounted virtual machine\n\nTo change the power status of a mounted virtual machine send a PATCH request to [`/vmware/vm/snapshot/mount/{id}`](#operation/updateMount). Include in the request body, the member `\"powerStatus\": $power_state`. For `$power_state`, use `true` to power on the virtual machine, or use `false` to power off the virtual machine.\n\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"powerStatus\": $power_state }' \\\n  \"https://$cluster_address/api/v1/vmware/vm/snapshot/mount/$mount_id\"\n```\n\nThe Rubrik REST API server responds with the mount details.\n\n```bash\n{\n  \"powerStatus\": \"$power_state\",\n  \"id\": \"$mount_id\",\n  \"snapshotDate\": \"$timestamp\",\n  \"vmId\": \"$vm_id\",\n  \"mountedVmId\": \"$mounted_vm_id\",\n  \"hostId\": \"$esxi_id\",\n  \"isReady\": true,\n  \"mountRequestId\": \"$mount_request_id\",\n  \"unmountRequestId\": \"$unmount_request_id\"\n}\n```\n\n### Removing a virtual machine mount\n\nTo remove a Live Mount send a DELETE request to [`/vmware/vm/snapshot/mount/{id}`](#operation/createUnmount). To remove a mount object after live migration of the virtual machine include the query parameter `force=true`.\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/vmware/vm/snapshot/mount/$mount_id\"\n```\nThe Rubrik REST API server initiates the asynchronous request task and responds with a task object.\n\n```bash\n{\n  \"id\": \"$delete_mount_task_id\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$timestamp\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Get recoverable ranges for a CDP-enabled virtual machine\n\nFor a list of time ranges to which a CDP-enabled virtual machine can recover, send a GET request to [`/vmware/vm/{id}/recoverable_range`](#operation/getVmwareRecoverableRanges). The time range start and end timestamps are specified as milliseconds from epoch.\nAny point-in-time recovery operation from version 2 of the API can use the time ranges returned by this API call for any CDP-enabled virtual machine.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/$vm_id/recoverable_range\n```\n\n```bash\n{\n  \"data\": [\n    \"beginTime\": \"2018-01-01T12:34:56.789Z\",\n    \"endTime\": \"2018-01-01T12:34:56.789Z\"\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\n### Get missed recoverable ranges for a CDP-enabled virtual machine\n\nFor a list of time ranges to which a CDP-enabled virtual machine cannot recover to, send a GET request to [`/vmware/vm/{id}/missed_recoverable_range`](#operation/getVmwareMissedRecoverableRanges). The time range start and end timestamps are specified as milliseconds from epoch.\nAny point-in-time recovery operation from version 2 of the API can use the time ranges returned by this API call for any CDP-enabled virtual machine.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/$vm_id/missed_recoverable_range\n```\n\n```bash\n{\n  \"data\": [\n    \"beginTime\": \"2018-01-01T12:34:56.789Z\",\n    \"endTime\": \"2018-01-01T12:34:56.789Z\"\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\n### Migrating a datastore for a virtual machine from Live Mount or Instant Recovery\n\nSend a POST request to [`/vmware/vm/snapshot/mount/{id}/relocate`](#operation/relocateMount) to migrate a datastore for a virtual machine created from Live Mount or Instant Recovery.\n\n\n### Get compute cluster information\n\nVMware compute cluster can be found by a GET on [`/vmware/compute_cluster`](#operation/queryComputeCluster).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/compute_cluster\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"compute_cluster_id\",\n      \"name\": \"compute_cluster_name\",\n      \"configuredSlaDomainId\": \"configured_sla_domain_id\",\n      \"configuredSlaDomainName\": \"configured_sla_domain_name\",\n      \"primaryClusterId\": \"primary_cluster_id\",\n      \"datacenterId\": \"datacenter_id\",\n      \"effectiveSlaDomainId\": \"effective_sla_domain_id\",\n      \"effectiveSlaDomainName\": \"effective_sla_domain_name\",\n      \"effectiveSlaSourceObjectId\": \"effective_sla_source_object_id\",\n      \"effectiveSlaSourceObjectName\": \"effective_sla_source_object_name\"\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\nFurther details are acquired from GET [`/vmware/compute_cluster/{id}`](#operation/getComputeCluster).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/compute_cluster/$compute_clustere_id\"\n```\n\n```bash\n{\n  \"id\": \"compute_cluster_id\",\n  \"name\": \"compute_cluster_name\",\n  \"configuredSlaDomainId\": \"configured_sla_domain_id\",\n  \"configuredSlaDomainName\": \"configured_sla_domain_name\",\n  \"primaryClusterId\": \"primary_cluster_id\",\n  \"datacenterId\": \"datacenter_id\",\n  \"effectiveSlaDomainId\": \"effective_sla_domain_id\",\n  \"effectiveSlaDomainName\": \"effective_sla_domain_name\",\n  \"effectiveSlaSourceObjectId\": \"effective_sla_source_object_id\",\n  \"effectiveSlaSourceObjectName\": \"effective_sla_source_object_name\"\n  \"moid\": \"compute_cluster_moid\",\n  \"hosts\": [\n    {\n      \"id\": \"string\",\n      \"name\": \"string\",\n      \"configuredSlaDomainId\": \"string\",\n      \"configuredSlaDomainName\": \"string\",\n      \"primaryClusterId\": \"string\",\n      \"datacenterId\": \"string\",\n      \"computeClusterId\": \"string\",\n      \"datastores\": [\n        {\n          \"id\": \"string\",\n          \"name\": \"string\",\n          \"capacity\": 0,\n          \"dataStoreType\": \"string\",\n          \"dataCenterName\": \"string\",\n          \"isLocal\": true\n         }\n      ],\n      \"effectiveSlaDomainId\": \"string\",\n      \"effectiveSlaDomainName\": \"string\",\n      \"effectiveSlaSourceObjectId\": \"string\",\n      \"effectiveSlaSourceObjectName\": \"string\"\n    }\n  ],\n\"virtualMachines\": [\n    {\n      \"id\": \"string\",\n      \"name\": \"string\",\n      \"configuredSlaDomainId\": \"string\",\n      \"configuredSlaDomainName\": \"string\",\n      \"primaryClusterId\": \"string\",\n      \"slaAssignment\": \"Derived\",\n      \"effectiveSlaDomainId\": \"string\",\n      \"effectiveSlaDomainName\": \"string\",\n      \"effectiveSlaSourceObjectId\": \"string\",\n      \"effectiveSlaSourceObjectName\": \"string\",\n      \"moid\": \"string\",\n      \"vcenterId\": \"string\",\n      \"hostName\": \"string\",\n      \"hostId\": \"string\",\n      \"clusterName\": \"string\",\n      \"snapshotConsistencyMandate\": \"UNKNOWN\",\n      \"powerStatus\": \"string\",\n      \"protectionDate\": \"2018-10-02T20:33:03.833Z\",\n      \"ipAddress\": \"string\",\n      \"agentStatus\": {\n        \"agentStatus\": \"string\",\n        \"disconnectReason\": \"string\"\n      },\n      \"toolsInstalled\": true,\n      \"isReplicationEnabled\": true,\n      \"folderPath\": [\n        {\n          \"id\": \"string\",\n          \"managedId\": \"string\",\n          \"name\": \"string\"\n        }\n      ],\n      \"infraPath\": [\n        {\n          \"id\": \"string\",\n          \"managedId\": \"string\",\n          \"name\": \"string\"\n        }\n      ],\n      \"vmwareToolsInstalled\": true,\n      \"isRelic\": true,\n      \"guestCredentialAuthorizationStatus\": \"string\",\n      \"cloudInstantiationSpec\": {\n        \"imageRetentionInSeconds\": 0\n      },\n      \"parentAppInfo\": {\n        \"id\": \"string\",\n        \"isProtectedThruHierarchy\": true\n      }\n    }\n  ]\n}\n```\n\nconfiguredSlaDomainId could be updated by a PATCH [`/vmware/compute_cluster/{id}`](#operation/updateComputeCluster).\n\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"sla_assignable\": $sla_domain }' \\\n  \"https://$cluster_address/api/v1/vmware/compute_cluster/$compute_clustere_id\"\n```\n\n```bash\n{\n  \"id\": \"compute_cluster_id\",\n  \"name\": \"compute_cluster_name\",\n  \"configuredSlaDomainId\": \"configured_sla_domain_id\",\n  \"configuredSlaDomainName\": \"configured_sla_domain_name\",\n  \"primaryClusterId\": \"primary_cluster_id\",\n  \"datacenterId\": \"datacenter_id\",\n  \"effectiveSlaDomainId\": \"effective_sla_domain_id\",\n  \"effectiveSlaDomainName\": \"effective_sla_domain_name\",\n  \"effectiveSlaSourceObjectId\": \"effective_sla_source_object_id\",\n  \"effectiveSlaSourceObjectName\": \"effective_sla_source_object_name\"\n  \"moid\": \"compute_cluster_moid\",\n  \"hosts\": [\n    {\n      \"id\": \"string\",\n      \"name\": \"string\",\n      \"configuredSlaDomainId\": \"string\",\n      \"configuredSlaDomainName\": \"string\",\n      \"primaryClusterId\": \"string\",\n      \"datacenterId\": \"string\",\n      \"computeClusterId\": \"string\",\n      \"datastores\": [\n        {\n          \"id\": \"string\",\n          \"name\": \"string\",\n          \"capacity\": 0,\n          \"dataStoreType\": \"string\",\n          \"dataCenterName\": \"string\",\n          \"isLocal\": true\n         }\n      ],\n      \"effectiveSlaDomainId\": \"string\",\n      \"effectiveSlaDomainName\": \"string\",\n      \"effectiveSlaSourceObjectId\": \"string\",\n      \"effectiveSlaSourceObjectName\": \"string\"\n    }\n  ],\n\"virtualMachines\": [\n    {\n      \"id\": \"string\",\n      \"name\": \"string\",\n      \"configuredSlaDomainId\": \"string\",\n      \"configuredSlaDomainName\": \"string\",\n      \"primaryClusterId\": \"string\",\n      \"slaAssignment\": \"Derived\",\n      \"effectiveSlaDomainId\": \"string\",\n      \"effectiveSlaDomainName\": \"string\",\n      \"effectiveSlaSourceObjectId\": \"string\",\n      \"effectiveSlaSourceObjectName\": \"string\",\n      \"moid\": \"string\",\n      \"vcenterId\": \"string\",\n      \"hostName\": \"string\",\n      \"hostId\": \"string\",\n      \"clusterName\": \"string\",\n      \"snapshotConsistencyMandate\": \"UNKNOWN\",\n      \"powerStatus\": \"string\",\n      \"protectionDate\": \"2018-10-02T20:33:03.833Z\",\n      \"ipAddress\": \"string\",\n      \"agentStatus\": {\n        \"agentStatus\": \"string\",\n        \"disconnectReason\": \"string\"\n      },\n      \"toolsInstalled\": true,\n      \"isReplicationEnabled\": true,\n      \"folderPath\": [\n        {\n          \"id\": \"string\",\n          \"managedId\": \"string\",\n          \"name\": \"string\"\n        }\n      ],\n      \"infraPath\": [\n        {\n          \"id\": \"string\",\n          \"managedId\": \"string\",\n          \"name\": \"string\"\n        }\n      ],\n      \"vmwareToolsInstalled\": true,\n      \"isRelic\": true,\n      \"guestCredentialAuthorizationStatus\": \"string\",\n      \"cloudInstantiationSpec\": {\n        \"imageRetentionInSeconds\": 0\n      },\n      \"parentAppInfo\": {\n        \"id\": \"string\",\n        \"isProtectedThruHierarchy\": true\n      }\n    }\n  ]\n}\n```\n\n### Query asynchronous job status for VMware compute cluster\n\nTo query the job status details of an asynchronous job that is related to an VMware compute cluster with a GET to [`/vmware/compute_cluster/request/{id}`](#operation/getAsyncRequestStatusForComputeCluster).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/compute_cluster/request/$job_id\"\n```\n\n```bash\n{\n  \"id\": \"string\",\n  \"status\": \"string\",\n  \"progress\": 0,\n  \"startTime\": \"2018-10-02T20:33:03.933Z\",\n  \"endTime\": \"2018-10-02T20:33:03.933Z\",\n  \"nodeId\": \"string\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"string\",\n      \"rel\": \"string\"\n    }\n  ]\n}\n```\n\n### VMware IO filters operations\n\nAll IO filters on a specific VMware compute cluster can be found with a GET on [`/vmware/compute_cluster/{id}/io_filter`](#operation/getIoFilters).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/compute_cluster/$compute_cluster_id/io_filter\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"string\",\n      \"name\": \"string\",\n      \"version\": \"string\",\n      \"vendor\": \"string\",\n      \"releaseDate\": \"string\",\n      \"summary\": \"string\"\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\nInstall the latest version of Rubrik IO filter to a specific VMware compute cluster with a POST on [`/vmware/compute_cluster/{id}/install_io_filter`](#operation/installIoFilter).\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/vmware/compute_cluster/$compute_cluster_id/install_io_filter\"\n```\n\n```bash\n{\n  \"id\": \"string\",\n  \"status\": \"string\",\n  \"progress\": 0,\n  \"startTime\": \"2018-10-02T20:33:03.933Z\",\n  \"endTime\": \"2018-10-02T20:33:03.933Z\",\n  \"nodeId\": \"string\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"string\",\n      \"rel\": \"string\"\n    }\n  ]\n}\n```\n\nUninstall the Rubrik IO filter from a specific VMware compute cluster with a POST on [`/vmware/compute_cluster/{id}/uninstall_io_filter`](#operation/uninstallIoFilter).\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/vmware/compute_cluster/$compute_cluster_id/uninstall_io_filter\"\n```\n\n```bash\n{\n  \"id\": \"string\",\n  \"status\": \"string\",\n  \"progress\": 0,\n  \"startTime\": \"2018-10-02T20:33:03.933Z\",\n  \"endTime\": \"2018-10-02T20:33:03.933Z\",\n  \"nodeId\": \"string\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"string\",\n      \"rel\": \"string\"\n    }\n  ]\n}\n```\n\nUpdate the Rubrik IO filter to the latest version for a specific VMware compute cluster with a POST on [`/vmware/compute_cluster/{id}/upgrade_io_filter`](#operation/upgradeIoFilter).\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/vmware/compute_cluster/$compute_cluster_id/upgrade_io_filter\"\n```\n\n```bash\n{\n  \"id\": \"string\",\n  \"status\": \"string\",\n  \"progress\": 0,\n  \"startTime\": \"2018-10-02T20:33:03.933Z\",\n  \"endTime\": \"2018-10-02T20:33:03.933Z\",\n  \"nodeId\": \"string\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"string\",\n      \"rel\": \"string\"\n    }\n  ]\n}\n```\n\n### Getting Live CDP fields for a batch of CDP-enabled virtual machines\n\nSend a POST request to\n[`/vmware/vm/cdp`](#operation/getVmwareCdpLiveInfo).\nThe request takes a list of virtual machine IDs that correspond to CDP-enabled\nvirtual machines as a mandatory parameter named 'ids'.\n\n```bash\ncurl -X POST \\\n  -d '{\n     \"ids\": [\"id_1\", \"id_2\"]\n     }'\\\n      \"https://$cluster_address/api/v1/vmware/vm/cdp\"\n```\n\nThe Rubrik REST API server responds with a `ListResponse` object.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n    \"vmId\": \"id_1\",\n    \"localRecoveryPoint\": \"2018-01-01T12:34:56.789Z\",\n    \"remoteRecoveryPoint\": \"2018-01-01T12:34:56.789Z\"\n    },\n    {\n    \"vmId\": \"id_2\",\n    \"localRecoveryPoint\": \"\",\n    \"remoteRecoveryPoint\": \"\"\n    }\n  ]\n  \"total\": 2\n}\n```\n### Getting CDP State fields for a batch of CDP-enabled virtual machines\n\nSend a POST request to\n[`/vmware/vm/cdp_state`](#operation/getVmwareCdpStateInfo).\nThe request takes a list of virtual machine IDs that correspond to CDP-enabled\nvirtual machines as a mandatory parameter named 'ids'.\n\n```bash\ncurl -X POST \\\n  -d '{\n     \"ids\": [\"id_1\", \"id_2\"]\n     }'\\\n      \"https://$cluster_address/api/v1/vmware/vm/cdp_state\"\n```\n\nThe Rubrik REST API server responds with a `ListResponse` object.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n    \"vmId\": \"id_1\",\n    \"localStatus\": \"Active\",\n    \"replicationStatus\": \"Healthy\",\n    \"healthPercentage\": \"85%\"\n    },\n    {\n    \"vmId\": \"id_2\",\n    \"localStatus\": \"Active\",\n    \"replicationStatus\": \"Healthy\",\n    \"healthPercentage\": \"100%\"\n    }\n  ]\n  \"total\": 2\n}\n```\n\n### Getting recoverable ranges for a batch of CDP-enabled virtual machines\n\nTo get the recoverable time ranges for a batch of CDP-enabled virtual\nmachines, send a POST request to [`/vmware/vm/recoverable_range`]\n(#operation/getVmwareVmRecoverableRangesInBatch). The request takes a list of\nvirtual machine IDs, and optionally a \"before_time\" and \"after_time\" as a filter\nof the time range. The returned recoverable range timestamps are specified as\nmilliseconds from epoch.\n\n```bash\ncurl -X POST \\\n  -d '{\n     \"vmIds\": [\"vmId_1\", \"vmId_2\"]\n     }'\\\n      \"https://$cluster_address/api/v1/vmware/vm/recoverable_range\"\n```\n\nThe Rubrik REST API server responds with a `BatchVmwareVmRecoverableRanges`\nobject.\n\n```bash\n{\n  \"responses\":\n  [\n    {\n      \"vmId\": \"vmId_1\",\n      \"recoverableRanges\":\n      [\n        {\n          \"beginTime\": \"2018-01-01T12:34:56.789Z\",\n          \"endTime\": \"2018-01-01T12:38:56.789Z\"\n        }\n      ]\n    },\n    {\n      \"vmId\": \"vmId_2\",\n      \"recoverableRanges\":\n      [\n        {\n          \"beginTime\": \"2018-01-01T12:34:57.789Z\",\n          \"endTime\": \"2018-01-01T12:38:57.789Z\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### Getting missed recoverable ranges for a batch of CDP-enabled\n### virtual machines\n\nTo get the missed recoverable time ranges for a batch of CDP-enabled virtual\nmachines, send a POST request to [`/vmware/vm/missed_recoverable_range`]\n(#operation/getVmwareVmMissedRecoverableRangesInBatch). The request takes a\nlist of virtual machine IDs, and optionally a \"before_time\" and \"after_time\"\nas a filter of the time range. The returned missed recoverable range timestamps\nare specified as milliseconds from epoch. If no filters being specified, the\nmissed recoverable range will be calculated based on the retention window,\ni.e. from retention time to the current time\n\n```bash\ncurl -X POST \\\n  -d '{\n     \"vmIds\": [\"vmId_1\", \"vmId_2\"]\n     }'\\\n      \"https://$cluster_address/api/v1/vmware/vm/missed_recoverable_range\"\n```\n\nThe Rubrik REST API server responds with a\n`BatchVmwareVmMissedRecoverableRanges` object.\n\n```bash\n{\n  \"responses\":\n  [\n    {\n      \"vmId\": \"vmId_1\",\n      \"missedRecoverableRanges\":\n      [\n        {\n          \"beginTime\": \"2018-01-01T12:34:56.789Z\",\n          \"endTime\": \"2018-01-01T12:38:56.789Z\"\n        }\n      ]\n    },\n    {\n      \"vmId\": \"vmId_2\",\n      \"missedRecoverableRanges\":\n      [\n        {\n          \"beginTime\": \"2018-01-01T12:34:57.789Z\",\n          \"endTime\": \"2018-01-01T12:38:57.789Z\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n## Get VMware Hierarchy Objects\nSend a GET request to\n[`/vmware/hierarchy/export`](#operation/getVmwareHierarchyExport).\nThe request takes an optional root ID for the hierarchy. This endpoint\nis used to retrieve the set of objects that are valid recovery targets\nduring a VMware Virtual Machine Export operations. This is limited to\nVMware Clusters, Hosts, and Resource Pools. The available options for\nthe root ID are None (return top level objects), Clusters (return child\nHosts and Resource Pools), Standalone Hosts (return child Resource\nPools), or Resource Pools (return child Resource Pools).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/hierarchy/export\"\n```\n\nThe Rubrik REST API server responds with a `ListResponse` object.\n```bash\n{\n  \"hasMore\": true,\n    \"data\": [\n      {\n        \"id\": \"string\",\n        \"name\": \"string\",\n        \"objectType\": \"string\",\n        \"location\": \"string\",\n        \"hasChildren\": true,\n        \"datastores\": [\n        ...\n        ],\n        \"recoverableTo\": true,\n      },\n    ]\n}\n```\n\n## Get VMware Hierarchy Object\nSend a GET request to\n[`/vmware/hierarchy/{id}/export`](#operation/getVmwareHierarchyObject).\nThe request takes an ID for the hierarchy object. This endpoint\nis used to retrieve the VMware Hierarchy object that are valid recovery targets\nduring a VMware Virtual Machine Export operations. This is limited to\nVMware Clusters, Hosts, and Resource Pools. The available options for\nthe ID are Compute Cluster ID , Standalone Hosts ID, or Resource Pools ID.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/hierarchy/{id}/export\"\n```\n\nThe Rubrik REST API server responds with a `VmwareHierarchyInfo` object.\n```bash\n{\n  \"responses\":\n  {\n   \"id\": \"string\",\n    \"name\": \"string\",\n    \"objectType\": \"string\",\n    \"location\": \"string\",\n    \"hasChildren\": true,\n    \"datastores\": [\n    ...\n    ],\n    \"recoverableTo\": true,\n  }\n}\n```\n\n## Get VMware User-Configured Network List\nSend a GET request to\n[`/vmware/vcenter/{id}/networks`](#operation/getNetworks).\nThe request takes an ID for the vCenter server for which to retrieve the\nuser-configured networks and returns the networks' names and IDs.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/vcenter/{id}/networks\"\n```\n\nThe Rubrik REST API server responds with a `NetworkInfo` object.\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n    \"id\": \"network_id\",\n    \"name\": \"network_name\"\n    }\n  ]\n  \"total\": 1\n}\n```\n\n## Set Network for HotAdd Backups and Recoveries\nSend a POST request to\n[`/vmware/vcenter/{id}/hotadd/network`](#operation/setHotAddNetwork). The\nrequest takes an ID for the vCenter server and a user-configured network\nID. It can also optionally take the information about static IP configuration.\nThis static IP configuration requires the IP address range and the subnet mask,\noptionally taking in a gateway and list of DNS servers.\n\n```bash\ncurl -X POST \\\n-d '{\n  \"hotadd_network_info\": {\n    \"network_id\":\"string\",\n    \"static_ip_info\": {\n      \"ip_addresses\":[\"list\", \"of\", \"ips\"],\n      \"subnet_mask\":\"string\",\n      \"gateway\":\"string\",\n      \"dns_servers\":[\"list\", \"of\", \"dns\", \"servers\"]\n    }\n  }\n}'\n\\  \"https://$cluster_address/api/v1/vmware/vcenter/{id}/hotadd/network\"\n```\n\nThe Rubrik REST API server responds with an HTTP 204 response when the\nnetwork is set up properly.\n\n## Get Network Information for HotAdd Backups and Recoveries\nSend a GET request to\n[`/vmware/vcenter/{id}/hotadd/network`](#operation/getHotAddNetwork). The\nrequest takes an ID for the vCenter server.\n\n```bash\ncurl -x GET \"https://$cluster_address/api/v1/vmware/vcenter/{id}/hotadd/network\"\n```\n\nThe Rubrik REST API server responds with a `HotAddNetworkConfigWithName` object.\n```bash\n{\n  \"networkName\": \"$networkName\",\n  \"staticIpConfig\": {\n    \"ip_addresses\": [\"list\", \"of\", \"ips\"],\n    \"subnet_mask\": \"$subnet_mask\",\n    \"gateway\": \"$gateway\",\n    \"dns_servers\": [\"list\", \"of\", \"dns\", \"servers\"]\n  }\n}\n```\n\n## Bulk creating on-demand snapshots\nOn-demand snapshots can be created for both protected and unprotected virtual\nmachines. To create an on-demand snapshot of a set of virtual machines, send a\nPOST request to\n[`/vmware/vm/snapshot/bulk`](#operation/bulkCreateOnDemandBackup).\n\n```bash\ncurl -X POST \\\n  -d '{\n     \"vms\": [\n       {\n         \"vmId\": \"$vm_id\"\n       }\n     ],\n     }'\\\n      \"https://$cluster_address/api/v1/vmware/vm/snapshot/bulk\"\n```\n\nThe Rubrik REST API server initiates the asynchronous snapshot tasks and\nresponds with objects tracking the job status.\n```bash\n{\n  \"responses\": [\n    {\n      \"id\": \"$request_id\",\n      \"status\": \"QUEUED\",\n      \"progress\": 0,\n      \"startTime\": \"$timestamp\",\n      \"links\": [\n        {\n          \"href\": \"https://$cluster_address/api/v1/vmware/vm/snapshot/bulk\",\n          \"rel\": \"self\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n## Get VMware HotAdd proxy virtual machine list\nTo retrieve the list of VMware HotAdd proxy virtual machines, send a GET\nrequest to the [`/vmware/vcenter/hotadd/vm`](#operation/queryHotAddProxyVm)\nendpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/vcenter/hotadd/vm\"\n```\n\nThe Rubrik REST API server responds with a `ListResponse` object.\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"string\",\n      \"name\": \"string\",\n      \"vcenterName\": \"string\",\n      \"computeClusterName\": \"string\",\n      \"hostName\": \"string\",\n      \"datastoreName\": \"string\",\n      \"networkInfo\": {\n        \"networkName\":\"string\",\n        \"staticIpConfig\": {\n          \"ip_addresses\":[\"list\", \"of\", \"ips\"],\n          \"subnet_mask\":\"string\",\n          \"gateway\":\"string\",\n          \"dns_server\":\"string\"\n        }\n      },\n      \"status\": \"OK\",\n      \"UsedPortCount\": 0,\n    },\n  ]\n}\n```\n\n## Get Number of HotAdd Proxies Needed for Vcenter\nSend a GET request to\n[`/vmware/vcenter/{id}/hotadd/needed`](#operation/getNumProxiesNeeded).\nThe request takes an ID for the vCenter server for which to return the\nnumber of HotAdd proxies needed.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/vcenter/{id}/hotadd/needed\"\n```\n\nThe Rubrik cluster returns the number of proxies needed.\n```bash\n{\n  \"needed\": 7\n}\n```\n\n## Get Ingest and Export Bandwidth Limits Using HotAdd for Vcenter.\nSend a GET request to\n[`/vmware/vcenter/{id}/hotadd/bandwidth`](#operation/getHotAddBandwidth).\nThe request takes the vCenter server ID and returns the\ningest and export bandwidth limits for that vCenter, when using HotAdd.\n\n```bash\ncurl -X GET \\\n\"https://$cluster_address/api/v1/vmware/vcenter/{id}/hotadd/bandwidth\"\n```\n\nThe Rubrik cluster returns the bandwidth limits in Mbps.\n```bash\n{\n  \"ingestLimit\": 7,\n  \"exportLimit\": 7\n}\n```\n\n## Set Ingest and Export Bandwidth Limits Using HotAdd for Vcenter.\nSend a POST request to\n[`/vmware/vcenter/{id}/hotadd/bandwidth`](#operation/setHotAddBandwidth).\nThe request takes an ID for the vCenter server and the bandwidth limits to\nupdate. Setting a bandwidth limit to 0 clears the limit in that\ndirection.\n\n```bash\ncurl -X POST \\\n-d '{\n  \"hot_add_bandwidth_info\": {\n    \"ingestLimit\": 0,\n    \"exportLimit\": 0\n  }\n}'\n\\ \"https://$cluster_address/api/v1/vmware/vcenter/{id}/hotadd/bandwidth\"\n```\n\nThe Rubrik REST API server responds with an HTTP 204 response when the\nbandwidth limits are set properly.\n\n### Get preferred CDP network protocol\n\nTo retrieve the currently preferred network protocol (IPv4 or IPv6) used for\nCDP data transfer, send a GET request to\n[`/vmware/config/cdp/get_preferred_cdp_network_protocol`](#operation/getPreferredCdpNetworkProtocol).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/config/cdp/get_preferred_cdp_network_protocol\"\n```\n\nThe Rubrik REST API server responds with the preferred CDP\nnetwork protocol.\n\n```bash\n{\n  \"preferredCdpNetworkProtocol\": \"IPv4\"\n}\n```\n\nThe configuration of VMware ESX subnets take priority over this setting.\nWhen a valid IPv6 ESX subnet is defined, CDP uses IPv6 for data transfer\neven when the preferred protocol is IPv4.\n\n### Set preferred CDP network protocol\n\nSet the preferred network protocol (IPv4 or IPv6) used for CDP data\ntransfer by sending a PATCH request to\n[`/vmware/config/cdp/set_preferred_cdp_network_protocol`](#operation/setPreferredCdpNetworkProtocol).\n\n```bash\ncurl -X PATCH \\\n  \"https://$cluster_address/api/v1/vmware/config/cdp/set_preferred_cdp_network_protocol\"\n```\n\nThe Rubrik REST API server responds with the updated preferred CDP\nnetwork protocol.\n\n```bash\n{\n  \"preferredCdpNetworkProtocol\": \"IPv4\"\n}\n```\n\n## Migrate cluster associated with Rubrik Backup Service\n\nSee the\n[host section](#section/Hosts/Migrate-cluster-associated-with-Rubrik-Backup-Service)\nfor more details. To migrate the primary cluster for the Rubrik Backup Service\non a virtual machine, send a POST request to\n[`/vmware/vm/make_primary`](#operation/vmMakePrimary).\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"ids\": [\n      \"$vm_id1\",\n      ...\n    ] }' \\\n  \"https://$cluster_address/api/v1/vmware/vm/make_primary\"\n```\n\nThe Rubrik REST API server initiates the asynchronous request task and responds\nwith a task object.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"status\": \"RUNNING\",\n  \"error\": \"None\",\n  \"progress\": \"$request_progress\"\n  \"links\": [\n    {\n      href: \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",\n      rel: \"self\"\n    }\n  ]\n}\n```\n\n### Get VMware Networks for virtual machine recovery\n\nTo get all the available VMware networks for the specified compute resource,\nsend a GET request to\n[`/vmware/config/recovery/networks`](#operation/getVmwareRecoveryNetworks).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/config/recovery/networks\"\n```\n\nThe Rubrik REST API server returns a collection of all the available\nrecovery networks `VmwareNetworkInfo` for the compute resource specified by\nthe `compute_resource_id` parameter.\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"computeResourceId\": string,\n      \"computeResourceType\": string,\n    },\n  ],\n  \"total\": 1,\n}\n```\n\n# Legal Hold\n\n### Get summary of snapshots which are placed under legal hold\nSend a GET request to [`/legal_hold/snapshot`](#operation/queryLegalHold).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/legal_hold/snapshot\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"objectId\": \"$object_id\",\n      \"objectName\": \"$object_name\",\n      \"objectType\": \"$object_type\",\n      \"snapshotId\": \"$snapshot_id\",\n      \"snapshotTime\": \"2019-11-12T10:35:12.784Z\",\n      \"placeOnHoldTime\": \"2019-11-13T11:11:06.456Z\",\n      \"locationsPresent\": [\n        \"$location1_id\",\n        \"$location2_id\"\n      ],\n      \"isOnDemandSnapshot\": true\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\n### Place a snapshot on legal hold\nTo place a snapshot under legal hold, send a POST request to [`/legal_hold/snapshot`](#operation/applyLegalHold).\n\n```bash\ncurl -X POST \\\n  -d '{ \"snapshotId\": \"$snapshot_id\", \"holdConfig\": {\"isHoldInPlace\": true} }' \\\n   \"https://$cluster_address/api/v1/legal_hold/snapshot\"\n```\n\nThe rubrik REST API server responds with the legal hold summary object if request succeeds.\n\n```bash\n{\n  \"objectId\": \"$object_id\",\n  \"objectName\": \"$object_name\",\n  \"objectType\": \"$object_type\",\n  \"snapshotId\": \"$snapshot_id\",\n  \"snapshotTime\": \"2019-11-12T10:35:12.784Z\",\n  \"placeOnHoldTime\": \"2019-11-13T11:11:06.456Z\",\n  \"locationsPresent\": [\n    \"$location1_id\",\n    \"$location2_id\"\n  ],\n  \"isOnDemandSnapshot\": true\n}\n```\n\n### Get objects which are part of legal hold\nSend a GET request to [`/legal_hold/object`](#operation/getLegalHoldObjects) to retrieve a list of objects with snapshots that are under a legal hold.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/legal_hold/object\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"objectId\": \"$object_id\",\n      \"objectName\": \"$object_name\",\n      \"objectType\": \"$object_type\",\n      \"numberOfSnapshotsHeld\": 1\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\nTo return a list of the snapshots for a specific object that are under legal hold, send a GET request to [`/legal_hold/snapshot`](#operation/queryLegalHold) with the ID of the object in the object_id parameter.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/legal_hold/snapshot?object_id=$object_id\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"objectId\": \"$object_id\",\n      \"objectName\": \"$object_name\",\n      \"objectType\": \"$object_type\",\n      \"snapshotId\": \"$snapshot_id\",\n      \"snapshotTime\": \"2019-11-12T10:35:12.784Z\",\n      \"placeOnHoldTime\": \"2019-11-13T11:11:06.456Z\",\n      \"locationsPresent\": \"\",\n      \"isOnDemandSnapshot\": true\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\n### Dissolve legal hold\nTo remove a legal hold from a collection of object snapshots, send a POST request to [`/legal_hold/object/{id}/dissolve`](#operation/dissolveLegalHoldSnapshots).\n\n```bash\ncurl -X POST \\\n  -d '{ \"snapshotIds\": [\"$snapshot_id\"] }' \\\n  \"https://$cluster_address/api/v1/legal_hold/object/$object_id/dissolve\"\n```\n\nThe Rubrik REST API server responds with the list of snapshots on which legal hold has been dissolved.\n\n```bash\n{\n  \"dissolvedSnapshotIds\": [\n    \"$snapshot_id\"\n  ]\n}\n```\n\n# Cloud Utilization\n\nRubrik clusters can utilize the cloud for storage and compute for\nsnapshot archival and data consolidation on archival locations.\n\n## Forecasting cloud utilization\n\nTo forecast the cloud utilization according to specified SLA domain\nparameters, send a POST request to:\n[`/cloud_utilization/cloud_out_forecast`](#operation/doCloudOutForecast).\n\n**Example:** Forecasting cloud utilization\n\n```bash\ncurl -X POST -d '{\n  \"cloudOutForecastRequest\": {\n    \"slaParameters\": {\n      \"frequencies\": {\n        \"monthly\": {\n          \"frequency\": 1,\n          \"retention\": 12\n        },\n        \"yearly\": {\n          \"frequency\": 1,\n          \"retention\": 2\n        }\n      },\n      \"archivalSpecs\": {\n        \"locationId\": \"75892476-c158-45fb-8ea9-365c634da294\",\n        \"archivalThreshold\": 1\n      }\n    },\n    \"consolidationFilter\": \"ForecastWithConsolidation\",\n    \"granularity\": Year,\n    \"forecastPeriodInGranularityUnit\": 3\n  }\n}' \"https://$cluster_address/api/v1/cloud_utilization/cloud_out_forecast\"\n```\n\nThe response gives the forecast result summary.\n\n```bash\n{\n  \"assumptions\": {\n    \"logicalDataSizeInGB\": 1000.0,\n    \"annualGrowthRateInPercent\": 7.0,\n    \"compressionFactor\": 2.5,\n    \"frequencyChangeRates\": {\n      \"monthlyChangeRateInPercent\": 10.0,\n      \"yearlyChangeRateInPercent\": 30.0\n    }\n  },\n  \"locationForecast\": {\n    \"locationName\": \"S3:s3-location-name\",\n    \"locationType\": \"S3\",\n    \"locationRegion\": \"us-west-2\",\n    \"instanceType\": \"m5.2xlarge\",\n    \"storageForecast\": {\n      \"forecastWithConsolidation\": {\n        \"storageUsedInGB\": [1000, 1100, 1105],\n        \"storageCostInUSD\": [276, 304, 305],\n        \"dataRetrievalCostInUSD\": [0, 0, 0],\n        \"perStorageClassForecast\": [\n          {\n            \"storageClass\": \"STANDARD\",\n            \"storageUsedInGB\": [900, 1150, 1450],\n            \"storageCostInUSD\": [176, 304, 376]\n          }\n        ]\n      }\n    },\n    \"computeForecast\": {\n      \"forecastWithConsolidation\": {\n        \"computeDurationInHrs\": [0, 11, 12],\n        \"computeCostInUSD\": [0, 8, 9]\n      }\n    }\n  }\n}\n```\n\n# User-defined tag\n\nRubrik CDM clusters can manage user-defined tags attached to the compute resources created by CloudOn and CloudOut.\n\nResource tags are associated with a cloud archival location, such as AWS or Azure. Rubrik CDM allows a maximum of 10 resource tags for each archival location. Check with the cloud provider for additional restrictions on resource tags.\n\nIf a compute resource supports tagging during creation by the cloud provider, user-defined resource tags are attached at resource creation time. Otherwise, user-defined resource tags are attached to the compute resource after creation.\n\n* Compute Instances: Bolt, Converter, Transient instances, Converted Instances\n* Disks/Snapshots: EBS Volumes/Snapshots, Managed Disks/Snapshot\n* Images: AMIs, Images\n\n## Query existing user-defined tags on a CDM cluster\n\nTo query existing user-defined tags on a CDM cluster, send a GET request to the\n[`/user_defined_tag`](#operation/queryUserDefinedTag) endpoint.\n\n**Example:** Query existing user-defined tags on a CDM cluster\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/user_defined_tag\"\n```\n\n```json\n{\n        \"resourceTags\": [{\n                \"id\": \"38400000-8cf0-11bd-b23e-10b96e4ef00d\",\n                \"key\": \"department\",\n                \"value\": \"engineering\",\n                \"lastUpdateTime\": \"2021-01-31T11:54:24 UTC\",\n                \"scopeRefId\": \"a0ef0663-7a7c-4027-9972-061780e52fee\"\n        }]\n}\n```\n\n## Create a new user-defined tag on a CDM cluster\n\nTo create a new user-defined tag on a CDM cluster, send a POST request to the\n[`/user_defined_tag`](#operation/createUserDefinedTag) endpoint.\n\n**Example:** Create a new user-defined tags on a CDM cluster\n\n```bash\ncurl -X POST \\\n  -d '{\n          \"key\": \"department\",\n          \"value\": \"engineering\",\n          \"scopeRefId\": \"a0ef0663-7a7c-4027-9972-061780e52fee\"\n    }' \\\n  \"https://$cluster_address/api/v1/user_defined_tag\"\n```\n\n```json\n{\n        \"id\": \"38400000-8cf0-11bd-b23e-10b96e4ef00d\",\n        \"key\": \"department\",\n        \"value\": \"engineering\",\n        \"lastUpdateTime\": \"2021-01-31T11:54:24 UTC\",\n        \"scopeRefId\": \"a0ef0663-7a7c-4027-9972-061780e52fee\"\n}\n```\n\n## Delete existing user-defined tags on a CDM cluster\n\nTo delete existing user-defined tags on a CDM cluster, send a DELETE request to the\n[`/user_defined_tag`](#operation/deleteUserDefinedTagBulk) endpoint.\n\n**Example:** Delete existing user-defined tags on a CDM cluster\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/user_defined_tag?ids=$id\"\n```\n\n```json\n{\n        \"ids\": [\"38400000-8cf0-11bd-b23e-10b96e4ef00d\"]\n}\n```\n\n## Get information about a user-defined tag on a CDM cluster\n\nTo fetch an existing user-defined tag on a CDM cluster, send a GET request to the\n[`/user_defined_tag/{id}`](#operation/getUserDefinedTag) endpoint.\n\n**Example:** To fetch an existing user-defined tag on a CDM cluster\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/user_defined_tag/$id\"\n```\n\n```json\n{\n        \"id\": \"38400000-8cf0-11bd-b23e-10b96e4ef00d\",\n        \"key\": \"department\",\n        \"value\": \"engineering\",\n        \"lastUpdateTime\": \"2021-01-31T11:54:24 UTC\",\n        \"scopeRefId\": \"a0ef0663-7a7c-4027-9972-061780e52fee\"\n}\n```\n\n## Update information about an existing user-defined tag on a CDM cluster\n\nTo update an existing user-defined tag on a CDM cluster, send a PATCH request to the\n[`/user_defined_tag/{id}`](#operation/updateUserDefinedTag) endpoint.\n\n**Example:** To update an existing user-defined tag on a CDM cluster\n\n```bash\ncurl -X PATCH \\\n -d '{\"value\": \"engineering\"}' \\\n \"https://$cluster_address/api/v1/user_defined_tag/$id\"\n```\n```json\n{\n        \"id\": \"38400000-8cf0-11bd-b23e-10b96e4ef00d\",\n        \"key\": \"department\",\n        \"value\": \"engineering\",\n        \"lastUpdateTime\": \"2021-01-31T11:54:24 UTC\",\n        \"scopeRefId\": \"a0ef0663-7a7c-4027-9972-061780e52fee\"\n}\n```\n\n## Delete a existing user-defined tag on a CDM cluster\n\nTo delete an existing user-defined tag on a CDM cluster, send a DELETE request to the\n[`/user_defined_tag/{id}`](#operation/deleteUserDefinedTag) endpoint.\n\n**Example:** To delete an existing user-defined tag on a CDM cluster\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/user_defined_tag/$id\"\n```\n\n\n\n# Hosts\n\nRubrik clusters can protect file system data and application data through direct interaction with a host operating system. This method of protection does not require a virtual environment API. Instead, the Rubrik cluster works with the Rubrik Backup Service software that is running on supported Linux hosts and Windows hosts.\n\nIn some situations, the Rubrik cluster can directly interact with hosts without the Rubrik Backup Service, for example when providing protection of data on a network share.\n\n## Rubrik Backup Service\n\nThe Rubrik Backup Service software must be installed on a host to enable file system level protection and direct protection of supported applications. The Rubrik Backup Service software is signed by a specific Rubrik cluster and can only be used with that Rubrik cluster.\n\nThe following URLs provide access to the Rubrik Backup Service software on a Rubrik cluster:\n* Linux: https://$cluster_address/connector/rubrik-agent.x86_64.rpm\n* Windows: https://$cluster_address/connector/RubrikBackupService.zip\n\n**IMPORTANT:** The Rubrik User Guide describes how to install the Rubrik Backup Service software, and lists the permissions and settings that are required to allow the Rubrik Backup Service to provide support for specific operating systems, applications, and clusters.\n\n## Registering a host\nAfter installing the Rubrik Backup Service on a host, register the host with the Rubrik cluster. Registering initiates secure communication between the Rubrik cluster and the Rubrik Backup Service on the host. After a host is registered, the Rubrik Backup Service on the host sends detailed information about the host to the Rubrik cluster.\n\nThe Rubrik Backup Service scans a registered host for protectable objects, such as: applications, databases, and Windows clusters. The Rubrik Backup Service sends the results of the scan to the Rubrik cluster.\n\nTo register a host, send a POST request to [`/host`](#operation/registerHost) and include `hostname: $hostname`. The `$hostname` value must be the IPv4 address of the host or the resolvable hostname of the host.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"hostname\": \"$hostname\" }' \\\n  \"https://$cluster_address/api/v1/host\"\n```\n\nTo register the host and discover protection points of the host in the background, send a POST request to [`/host/background`](#operation/registerHostAsync) and include `hostname: $hostname`. The`$hostname` value must be the IPv4 address of the host or the resolvable hostname of the host.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"hostname\": \"$hostname\" }' \\\n  \"https://$cluster_address/api/v1/host/background\"\n```\nThe Rubrik REST API server responds with the details for the host, including the connection status.\n\n```bash\n{\n  \"id\": \"$host_id\",\n  \"name\": \"$hostname\",\n  \"hostname\": \"$hostname\", (deprecated)\n  \"primaryClusterId\": \"$cluster_id\",\n  \"agentId\": \"$agent_id\",\n  \"operatingSystem\": \"$os_version\",\n  \"operatingSystemType\": \"$os_type\",\n  \"status\": \"Connected\",\n  \"compressionEnabled\": false\n}\n```\n\nTo register bulk hosts in the background, send a POST request to [`/host/bulk_background`](#operation/bulkRegisterHostAsync) and include `hostname: $hostname`. The`$hostname` value must be the IPv4 address of the host or the resolvable hostname of the host.\n\n```\ncurl -X POST \\\n  -d '{\n    [{\"hostname\": \"$hostname1\"}, {\"hostname\": \"$hostname2\"}] }' \\\n  \"https://$cluster_address/api/v1/host/bulk_background\"\n```\n\nThe `status` field in the response is returned as `Refreshing` until the host has finished discovering all the mssql instances, oracle DBs, etc. After this step, status is returned as `Connected` and all discovery is done for the host\n\nFor background hosts, the connection status is returned as `Refreshing` until the host is fully registered. After this step, that status is returned as `Connected` and all discovery is done for the host\n\n## Retrieving host information\n\nTo retrieve a current list of the hosts that are registered with a Rubrik cluster, send a GET request to [`/host`](#operation/queryHost).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/host\"\n```\n\nThe Rubrik REST API server responds with a ListResponse object that contains the first page of the current list.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"id\": \"$host_id0\",\n      \"name\": \"$hostname0\",\n      \"hostname\": \"$hostname0\", (deprecated)\n      \"primaryClusterId\": \"$cluster_id\",\n      \"operatingSystem\": \"$os_version0\",\n      \"operatingSystemType\": \"$os_type0\",\n      \"status\": \"Connected\"\n    },\n    {\n      \"id\": \"$host_id1\",\n      \"name\": \"$hostname1\",\n      \"hostname\": \"$hostname1\", (deprecated)\n      \"primaryClusterId\": \"$cluster_id\",\n      \"operatingSystem\": \"$os_version1\",\n      \"operatingSystemType\": \"$os_type1\",\n      \"status\": \"Connected\"\n    }\n  ],\n  \"total\": 2\n}\n```\nDepending on the number of registered hosts, the complete list of registered hosts may not be included on the first page. [Working with lists](#section/Overview/Working-with-lists) describes how to work with a ListResponse object to obtain additional pages of the list.\n\n\nTo retrieve the details for a specified host, send a GET request to [`/host/{id}`](#operation/getHost).\n\nAdding a host will cause Rubrik to communicate with the remote Rubrik agent and get detailed information about the host.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/host/$host_id0\"\n```\nThe Rubrik REST API server responds with the details of the specified host.\n\n```bash\n  {\n    \"id\": \"$host_id0\",\n    \"name\": \"$hostname0\",\n    \"hostname\": \"$hostname0\", (deprecated)\n    \"primaryClusterId\": \"$cluster_id\",\n    \"agentId\": \"$agent_id\",\n    \"operatingSystem\": \"$os_version0\",\n    \"operatingSystemType\": \"$os_type0\",\n    \"status\": \"Connected\",\n    \"compressionEnabled\": false\n  }\n```\n\n## Adding a host without the Rubrik Backup Service\n\nA host without the Rubrik Backup Service can be added by setting the `hasAgent` flag to `false`. This can be used to register a host that will be accessed through network shares.\n\n```bash\ncurl -X POST \\\n  -d '{ \\\n    \"hostname\": \"$hostname\",\n    \"hasAgent\": \"false\" }' \\\n  \"https://$cluster_address/api/v1/host\"\n```\n\n## Modifying a registered host\n\nTo change the FQDN or IPv4 address that the Rubrik cluster uses to connect with a registered host, send a PATCH request to [`/host`](#operation/updateHost). Use the value of `hostname` to specify the new FQDN or IPv4 address of the host. Optionally, also use this PATCH request to specify whether to compress the data that is transmitted to and from the host. Set the value of `compressionEnabled` to `true` to enable compression or set the value to `false` to turn compression off.\n\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"hostname\": \"$hostname\",\n    \"compressionEnabled\": true }' \\\n  \"https://$cluster_address/api/v1/host/$host_id\"\n```\n\nThe Rubrik REST API server responds with a confirmation of the new details of the registered host.\n\n```bash\n {\n  \"id\": \"$host_id\",\n  \"name\": \"$hostname\",\n  \"hostname\": \"$hostname\", (deprecated)\n  \"primaryClusterId\": \"$cluster_id\",\n  \"agentId\": \"$agent_id\",\n  \"operatingSystem\": \"$os_version\",\n  \"operatingSystemType\": \"$os_type\",\n  \"status\": \"Connected\",\n  \"compressionEnabled\": true\n }\n```\n## Removing a host\n\nRemove a host from the Rubrik cluster when the host no longer requires protection. The Rubrik cluster moves all of the unexpired backups for the host filesets of the host to Unmanaged Objects.\n\nTo remove a host send a DELETE request to [`/host/{id}`](#operation/deleteHost).\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/host/$host_id\"\n```\n\nThe Rubrik REST API server responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.\n\n## Refreshing a Host\n\nRefresh a host when changes made on the host do not appear in the\nRubrik web UI. The refresh requests updated information from the\nRubrik Backup Service that is running on the host.\n\nTo refresh a host send a POST request to\n[`/host/{id}/refresh`](#operation/refreshHost)\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/host/$host_id/refresh\"\n```\n\nThe Rubrik REST API server responds with HTTP response code 200 and\nincludes the updated properties of the host object in the response body.\n\n## Updating a Host Certificate\n\nWhen a host has a new certificate that is not registered with Rubrik\nthe Rubrik cluster will not communicate with that host until the\ncertificate is updated. In order to do that send a PUT request to\n[`/host/certificate/{id}`](#operation/updateCertificateHost)\n\n```bash\ncurl -X PUT \\\n  \"https://$cluster_address/api/v1/host/certificate/$host_id\"\n```\n\nThe Rubrik REST API server responds with the details of the specified host.\n\n## Migrate cluster associated with Rubrik Backup Service\n\nHosts can register with multiple clusters but can only communicate or back up to\na single cluster. Such a cluster is the primary cluster for that host. See the\nMulticluster Rubrik Backup Service section of the Rubrik CDM User Guide for\ndetails. To change the primary cluster to the current cluster, for Rubrik Backup\nService on a host, send a POST request to\n[`/host/make_primary`](#operation/hostMakePrimary).\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"ids\": [\n      \"$host_id1\",\n      ...\n    ] }' \\\n  \"https://$cluster_address/api/v1/host/make_primary\"\n```\n\nThe Rubrik REST API server initiates the asynchronous request task and responds\nwith a task object.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"status\": \"RUNNING\",\n  \"error\": \"None\",\n  \"progress\": \"$request_progress\"\n  \"links\": [\n    {\n      href: \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",\n      rel: \"self\"\n    }\n  ]\n}\n```\n\nTo migrate the Rubrik Backup Service on a virtual machine, see the\n[corresponding virtual machine API](#section/Virtual-machines/Migrate-cluster-associated-with-Rubrik-Backup-Service).\n\nAlternatively, in a disaster recovery scenario, when migrating the primary\ncluster for all hosts *and* virtual machines from an old cluster to this one,\nsend a POST request to [`/host/make_primary`](#operation/hostMakePrimary) with\noldPrimaryClusterUuid specified. Note that the hosts and virtual machines must\nalready have been registered on this cluster.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"oldPrimaryClusterUuid\": \"12345678-90ab-cdef-1234-567890abcdef\" }' \\\n  \"https://$cluster_address/api/v1/host/make_primary\"\n```\n\n## Windows Server Failover Clustering nodes\n\nTo begin working with Windows Server Failover Clustering (WSFC) clusters, register each WSFC node with the Rubrik cluster as described in [`Registering a host`](#section/Hosts/Registering-a-host). The scan performed by the Rubrik Backup Service on each WSFC node detects the WSFC cluster and provides information about the WSFC cluster to the Rubrik cluster.\n\nTo view WSFC cluster information, send a GET request to [`/windows_cluster`](#operation/queryWindowsCluster).\n\n**Note:** The variable `$cluster_address` refers to the FQDN or IPv4 address of the Rubrik cluster.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/windows_cluster\"\n```\nThe Rubrik REST API server responds with a ListResponse object that contains the first page of the list of WSFC clusters.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"id\": \"$wsfc_id\",\n      \"name\": \"$wsfc_name\",\n      \"fqdn\": \"$wsfc_fqdn\",\n      \"hostIds\": [\n        \"$wsfc_node_id0\",\n        \"$wsfc_node_id1\"\n      ],\n      \"primaryClusterId\": \"$cluster_id\"\n    }\n  ],\n  \"total\": 1\n}\n```\n\nTo retrieve detailed information about a WSFC cluster, send a GET request to: [`/windows_cluster/{id}`](#operation/getWindowsCluster), where `$cluster_id` is the `id` of the WSFC cluster.\n\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/windows_cluster/$cluster_id\"\n```\n\nThe Rubrik REST API server responds with the details for the specified WSFC cluster.\n\n```bash\n{\n  \"name\": \"$wsfc_name\",\n  \"id\": \"$wsfc_id\",\n  \"naturalId\": \"$cluster_natural_id\",\n  \"hostIds\": [\n  \"$wsfc_node_id0\",\n  \"$wsfc_node_id1\"\n  ],\n  \"fqdn\": \"$wsfc_fqdn\",\n  \"primaryClusterId\": \"$cluster_id\"\n}\n```\n\n## Bulk Update Host Shares\n\nTo update a list of Host shares in bulk, send a PATCH request to the [`/host/share/bulk`](#operation/bulkUpdateHostShare) endpoint with a bulk_update_properties to complete an update.\n\n```bash\ncurl -X PATCH \\\n  -d '[\n    {\n      \"shareId\": \"$share_id\",\n      \"updateProperties\": {\n        \"exportPoint\": \"$export_point\",\n        \"username\": \"$username\",\n        \"password\": \"$password\",\n        \"domain\": \"$domain\",\n        \"hostShareParameters\": {\n          \"isNetAppSnapDiffEnabled\": true,\n          \"isIsilonChangelistEnabled\": true\n        }\n      }\n    }\n  ]' \\\n  \"https://$cluster_address/api/v1/host/share/bulk\"\n```\n\nThe Rubrik REST API server responds with the details of the updated Host shares.\n\n## Discover shares on NAS host\n\nTo retrieve a current list of shares (NFS/SMB) on a specific NAS host,\nsend a GET request to [`/host/{id}/nas_share_discover`](#operation/discoverNasShares)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/host/{id}/nas_share_discover\"\n```\n\nThe Rubrik REST API server responds with a List object that contains all\ndiscovered shares on the NAS host.\n\n```bash\n{\n  [\n    {\n      \"shareType\": \"NFS\",\n      \"exportPoint\": \"/ifs/data/dir1\",\n    },\n    {\n      \"shareType\": \"SMB\",\n      \"exportPoint\": \"ifs_data\",\n    }\n  ]\n}\n```\n\n## Bulk add NAS shares\n\nTo add NAS shares in bulk without validating their share credentials, send a\nPOST request to [`/host/share/bulk`](#operation/bulkAddHostShares)\n\n```bash\ncurl -X POST \\\n  -d '{ \\\n    [ \\\n      { \\\n        \"shareType\": \"$share_type\", \\\n        \"exportPoint\": \"$export_point\" \\\n      },\n      { \\\n        \"shareType\": \"$share_type\", \\\n        \"exportPoint\": \"$export_point\" \\\n      }, \\\n    ] \\\n  }' \\\n  \"https://$cluster_address/api/v1/host/share/bulk\"\n```\n\nThe Rubrik REST API server responds with details of added shares.\n\n## Getting a list of volumes on a Volume Group host\n\nTo retrieve a list of all volumes on a Volume Group host, send a GET\nrequest to [`/host/{id}/volume`](#operation/queryHostVolume)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/host/{id}/volume\"\n```\n\nThe Rubrik REST API server responds with summary information for each\nvolume on the specified Volume Group host.\n\n```\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"string\",\n      \"fileSystemType\": \"NTFS\",\n      \"mountPoints\": [\n        \"string\"\n      ],\n      \"size\": 0,\n      \"naturalId\": \"string\",\n      \"volumeGroupId\": \"string\",\n      \"isCurrentlyPresentOnSystem\": true\n    }\n  ],\n  \"total\": 0\n}\n```\n\n## Remote RBS management\nThe Rubrik Backup Service (RBS) management endpoints provide the capability to install/uninstall/upgrade RBS on remote hosts.\n\n### Retrieving the Rubrik Backup Service host information\n\nTo get the Rubrik Backup Service host information, send a GET request to [`/host/rbs`](#operation/getRbsHostInfo).\n\n```bash\ncurl -X GET \\\n  -d '{\n    \"name\": \"$hostname\",\n    \"username\": \"$username\",\n    \"password\": \"$password\",\n    \"operationTimeout\": 600 }' \\\n  \"https://$cluster_address/api/v1/host/rbs\"\n```\n\n\nThe Rubrik REST API server responds with summary information for Rubrik Backup Service host.\n\n```\n{\n  \"name\": \"$hostname\",\n  \"agentId\": \"$rbsAgentId\",\n  \"agentVersion\": \"$rbsVersion\",\n  \"osInfo\": \"$osInfo\",\n  \"osType\": \"$osType\",\n  \"status\": \"Installed\"\n}\n```\n\n### Installing Rubrik Backup Service on a host\n\nTo install Rubrik Backup Service on a host, send a POST request to [`/host/rbs/install`](#operation/rbsInstall).\n\nInstall Rubrik Backup Service on a host with operationMode as Synchronous.\n```bash\ncurl -X POST \\\n  -d '{\n    \"name\": \"$hostname\",\n    \"username\": \"$username\",\n    \"password\": \"$password\",\n    \"operationTimeout\": 600,\n    \"operationMode\": Synchronous }' \\\n  \"https://$cluster_address/api/v1/host/rbs/install\"\n```\n\nThe Rubrik REST API server responds with the summary of Rubrik Backup Service on the host.\n```bash\n{\n  \"rbsHostSummary\": {\n    \"name\": \"$hostname\",\n    \"agentId\": \"$rbsAgentId\",\n    \"agentVersion\": \"$rbsVersion\",\n    \"osInfo\": \"$osInfo\",\n    \"osType\": \"$osType\",\n    \"status\": \"Installed\"\n  }\n}\n```\n\nInstall Rubrik Backup Service on a host with operationMode as Asynchronous.\n```bash\ncurl -X POST \\\n  -d '{\n    \"name\": \"$hostname\",\n    \"username\": \"$username\",\n    \"password\": \"$password\",\n    \"operationTimeout\": 600,\n    \"operationMode\": Asynchronous }' \\\n  \"https://$cluster_address/api/v1/host/rbs/install\"\n```\n\nThe Rubrik REST API server initiates the asynchronous task and responds\nwith a task object.\n\n```bash\n{\n  \"asyncRequestStatus\": {\n    \"id\": \"$id\",\n    \"status\": \"$status\",\n    \"progress\": 0,\n    \"startTime\": \"2021-03-24T23:27:41.493Z\",\n    \"endTime\": \"2021-03-24T23:27:41.493Z\",\n    \"nodeId\": \"$nodeId\",\n    \"error\": {\n      \"message\": \"$message\"\n    },\n    \"links\": [\n      {\n        \"href\": \"$href\",\n        \"rel\": \"$rel\"\n      }\n    ]\n  }\n}\n```\n\n### Uninstalling Rubrik Backup Service from a host\n\nTo uninstall Rubrik Backup Service from a host, send a POST request to [`/host/rbs/uninstall`](#operation/rbsUninstall).\n\nUninstall Rubrik Backup Service from a host with operationMode as Synchronous.\n```bash\ncurl -X POST \\\n  -d '{\n    \"name\": \"$hostname\",\n    \"username\": \"$username\",\n    \"password\": \"$password\",\n    \"operationTimeout\": 600,\n    \"operationMode\": Synchronous }' \\\n  \"https://$cluster_address/api/v1/host/rbs/uninstall\"\n```\n\nThe Rubrik REST API server responds with the summary of Rubrik Backup Service on the host.\n```bash\n{\n  \"rbsHostSummary\": {\n    \"name\": \"$hostname\",\n    \"status\": \"NotInstalled\"\n  }\n}\n```\n\nUninstall Rubrik Backup Service from a host with operationMode as Asynchronous.\n```bash\ncurl -X POST \\\n  -d '{\n    \"name\": \"$hostname\",\n    \"username\": \"$username\",\n    \"password\": \"$password\",\n    \"operationTimeout\": 600,\n    \"operationMode\": Asynchronous }' \\\n  \"https://$cluster_address/api/v1/host/rbs/uninstall\"\n```\n\nThe Rubrik REST API server initiates the asynchronous task and responds\nwith a task object.\n```bash\n{\n  \"asyncRequestStatus\": {\n    \"id\": \"$id\",\n    \"status\": \"$status\",\n    \"progress\": 0,\n    \"startTime\": \"2021-03-24T23:27:41.493Z\",\n    \"endTime\": \"2021-03-24T23:27:41.493Z\",\n    \"nodeId\": \"$nodeId\",\n    \"error\": {\n      \"message\": \"$message\"\n    },\n    \"links\": [\n      {\n        \"href\": \"$href\",\n        \"rel\": \"$rel\"\n      }\n    ]\n  }\n}\n\n### Upgrading Rubrik Backup Service on a host\n\nTo upgrade Rubrik Backup Service on a host, send a POST request to [`/host/rbs/upgrade`](#operation/rbsUpgrade).\n\nUpgrade Rubrik Backup Service on a host with operationMode as Synchronous.\n```bash\ncurl -X POST \\\n  -d '{\n    \"name\": \"$hostname\",\n    \"username\": \"$username\",\n    \"password\": \"$password\",\n    \"operationTimeout\": 600,\n    \"operationMode\": Synchronous }' \\\n  \"https://$cluster_address/api/v1/host/rbs/upgrade\"\n```\n\nThe Rubrik REST API server responds with the summary of Rubrik Backup Service on the host.\n```bash\n{\n  \"rbsHostSummary\": {\n    \"name\": \"$hostname\",\n    \"agentId\": \"$rbsAgentId\",\n    \"agentVersion\": \"$rbsVersion\",\n    \"osInfo\": \"$osInfo\",\n    \"osType\": \"$osType\",\n    \"status\": \"Installed\"\n  }\n}\n```\n\nUpgrade Rubrik Backup Service on a host with operationMode as Asynchronous.\n```bash\ncurl -X POST \\\n  -d '{\n    \"name\": \"$hostname\",\n    \"username\": \"$username\",\n    \"password\": \"$password\",\n    \"operationTimeout\": 600,\n    \"operationMode\": Asynchronous }' \\\n  \"https://$cluster_address/api/v1/host/rbs/upgrade\"\n```\n\nThe Rubrik REST API server initiates the asynchronous task and responds\nwith a task object.\n\n```bash\n{\n  \"asyncRequestStatus\": {\n    \"id\": \"$id\",\n    \"status\": \"$status\",\n    \"progress\": 0,\n    \"startTime\": \"2021-03-24T23:27:41.493Z\",\n    \"endTime\": \"2021-03-24T23:27:41.493Z\",\n    \"nodeId\": \"$nodeId\",\n    \"error\": {\n      \"message\": \"$message\"\n    },\n    \"links\": [\n      {\n        \"href\": \"$href\",\n        \"rel\": \"$rel\"\n      }\n    ]\n  }\n}\n```\n\n# Failover cluster\n\nThis REST API is used to manage failover cluster objects of UnixLike hosts.\n\n### Add a new failover cluster\nAdd a new failover cluster by making a POST call to\n[/failover_cluster](#operation/createFailoverCluster).\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"name\": \"$name\",\n    \"hostIds\": [ \"$hostId\" ],\n    \"configuredSlaDomainId\": \"$configuredSlaDomainId\"}'\\\n  \"https://$cluster_address/api/v1/failover_cluster\"\n```\n\n```bash\n{\n  \"id\": \"$id\",\n  \"name\": \"$name\",\n  \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n  \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n  \"configuredSlaDomainType\": \"ProtectionSla\",\n  \"primaryClusterId\": \"$primaryClusterId\",\n  \"isConfiguredSlaDomainRetentionLocked\": true,\n  \"slaLastUpdateTime\": \"2020-04-20T17:30:30.743Z\",\n  \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",\n  \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",\n  \"isEffectiveSlaDomainRetentionLocked\": true,\n  \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",\n  \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",\n  \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",\n  \"nodes\": [\n    {\n      \"id\": \"$id\",\n      \"name\": \"$name\",\n      \"connectionStatus\": \"Connected\",\n      \"operatingSystem\": \"$operatingSystem\"\n    }\n  ],\n  \"connectionStatus\": \"Connected\",\n  \"slaAssignment\": \"Derived\",\n  \"operatingSystemType\": \"$operatingSystemType\",\n  \"numNodes\": $numNodes,\n  \"numApps\": 0\n}\n\n```\n\n### Get all failover clusters\nGet a listing of all failover clusters using\na GET request to [/failover_cluster](#operation/queryFailoverCluster).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/failover_cluster?sort_order=asc\"\n```\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"id\": \"$id\",\n      \"name\": \"$name\",\n      \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n      \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n      \"configuredSlaDomainType\": \"ProtectionSla\",\n      \"primaryClusterId\": \"$primaryClusterId\",\n      \"isConfiguredSlaDomainRetentionLocked\": false,\n      \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",\n      \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",\n      \"isEffectiveSlaDomainRetentionLocked\": false,\n      \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",\n      \"nodes\": [\n        {\n          \"id\": \"$id\",\n          \"name\": \"$name\",\n          \"connectionStatus\": \"Connected\",\n          \"operatingSystem\": \"$operatingSystem\"\n        },\n        {\n          \"id\": \"$id\",\n          \"name\": \"$name\",\n          \"connectionStatus\": \"Connected\",\n          \"operatingSystem\": \"$operatingSystem\"\n        }\n      ],\n      \"connectionStatus\": \"Connected\",\n      \"slaAssignment\": \"$slaAssignment\",\n      \"operatingSystemType\": \"$operatingSystemType\"\n    }\n  ],\n  \"total\": 1\n}\n```\n\n### Get information about a specific failover cluster\nGet information about a specific failover cluster using\na GET request to\n[/failover_cluster/{id}](#operation/getFailoverCluster).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/failover_cluster/$failover_cluster_id\"\n```\n\n```bash\n{\n  \"id\": \"$id\",\n  \"name\": \"$name\",\n  \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n  \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n  \"configuredSlaDomainType\": \"ProtectionSla\",\n  \"primaryClusterId\": \"$primaryClusterId\",\n  \"isConfiguredSlaDomainRetentionLocked\": false,\n  \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",\n  \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",\n  \"isEffectiveSlaDomainRetentionLocked\": false,\n  \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",\n  \"nodes\": [\n    {\n      \"id\": \"$id\",\n      \"name\": \"$name\",\n      \"connectionStatus\": \"Connected\",\n      \"operatingSystem\": \"$operatingSystem\"\n    },\n    {\n      \"id\": \"$id\",\n      \"name\": \"$name\",\n      \"connectionStatus\": \"Connected\",\n      \"operatingSystem\": \"$operatingSystem\"\n    }\n  ],\n  \"connectionStatus\": \"Connected\",\n  \"slaAssignment\": \"$slaAssignment\",\n  \"operatingSystemType\": \"$operatingSystemType\",\n  \"numNodes\": $numNodes,\n  \"numApps\": $numApps\n}\n```\n\n### Update the parameters of an existing failover cluster\nThe parameters associated with the failover cluster can be updated by\nmaking a PATCH request to\n[/failover_cluster/{id}](#operation/updateFailoverCluster)\n\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"name\": \"$name\",\n    \"hostIds\": [ \"$hostId\" ],\n    \"configuredSlaDomainId\": \"$configuredSlaDomainId\"}'\\\n  \"https://$cluster_address/api/v1/failover_cluster/$failover_cluster_id\"\n```\n\n```bash\n{\n  \"id\": \"$id\",\n  \"name\": \"$name\",\n  \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n  \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n  \"configuredSlaDomainType\": \"ProtectionSla\",\n  \"primaryClusterId\": \"$primaryClusterId\",\n  \"isConfiguredSlaDomainRetentionLocked\": true,\n  \"slaLastUpdateTime\": \"2020-04-20T18:26:56.893Z\",\n  \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",\n  \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",\n  \"isEffectiveSlaDomainRetentionLocked\": true,\n  \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",\n  \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",\n  \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",\n  \"nodes\": [\n    {\n      \"id\": \"$id\",\n      \"name\": \"$name\",\n      \"connectionStatus\": \"Connected\",\n      \"operatingSystem\": \"$operatingSystem\"\n    }\n  ],\n  \"connectionStatus\": \"Connected\",\n  \"slaAssignment\": \"Derived\",\n  \"operatingSystemType\": \"$operatingSystemType\",\n  \"numNodes\": $numNodes,\n  \"numApps\": $numApps\n}\n```\n\n### Delete a specific failover cluster\nAny failover cluster can be removed by issuing a DELETE request to\n[/failover_cluster/{id}](#operation/deleteFailoverCluster).\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/failover_cluster/$failover_cluster_id?preserve_snapshots=false\"\n```\n\n### Bulk delete a failover cluster\nA list of failover clusters can be removed by issuing a DELETE request to\n[/failover_cluster/bulk](#operation/bulkDeleteFailoverCluster).\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/failover_cluster/bulk?ids=$failover_cluster_id1,$failover_cluster_id2&preserve_snapshots=false\"\n```\n\n# Failover cluster App\n\nUse this REST API to manage failover cluster app objects.\n\n### Add a new failover cluster app\nAdd a new failover cluster app by making a POST call to\n[/failover_cluster/failover_cluster_app](#operation/createFailoverClusterApp).\n\nUse either the virtualIps or nodeOrders options in the failoverClusterAppSource request parameter to create a failover cluster app.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"name\": \"$name\",\n    \"failoverClusterType\": \"Windows\",\n    \"failoverClusterId\": \"$failoverClusterId\",\n    \"failoverClusterAppSource\": {\n      \"virtualIps\": [\n        \"$virtualIp\"\n      ],\n      \"nodeOrders\": [\n        {\n          \"nodeId\": \"$nodeId\",\n          \"nodeName\": \"$nodeName\",\n          \"order\": 0\n        }\n      ]\n    },\n    \"configuredSlaDomainId\": \"string\"}'\\\n  \"https://$cluster_address/api/v1/failover_cluster/failover_cluster_app\"\n```\n\nResponse when a failover cluster app is created using the virtualIps option in the failoverClusterAppSource request parameter.\n\n```bash\n{\n  \"id\": \"$id\",\n  \"name\": \"$name\",\n  \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n  \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n  \"configuredSlaDomainType\": \"ProtectionSla\",\n  \"primaryClusterId\": \"$primaryClusterId\",\n  \"isConfiguredSlaDomainRetentionLocked\": true,\n  \"slaLastUpdateTime\": \"2020-04-21T17:32:44.266Z\",\n  \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",\n  \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",\n  \"isEffectiveSlaDomainRetentionLocked\": true,\n  \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",\n  \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",\n  \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",\n  \"failoverClusterType\": \"Windows\",\n  \"failoverClusterId\": \"$failoverClusterId\",\n  \"failoverClusterAppSource\": {\n    \"virtualIps\": [\n      \"$virtualIp\"\n    ]\n  },\n  \"connectionStatus\": \"Connected\",\n  \"slaAssignment\": \"Derived\",\n  \"operatingSystemType\": \"$operatingSystemType\",\n  \"failoverClusterName\": \"$failoverClusterName\"\n}\n```\n\nResponse when a failover cluster app is created using the nodeOrders option in the failoverClusterAppSource request parameter.\n\n```bash\n{\n  \"id\": \"$id\",\n  \"name\": \"$name\",\n  \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n  \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n  \"configuredSlaDomainType\": \"ProtectionSla\",\n  \"primaryClusterId\": \"$primaryClusterId\",\n  \"isConfiguredSlaDomainRetentionLocked\": true,\n  \"slaLastUpdateTime\": \"2020-04-21T17:32:44.266Z\",\n  \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",\n  \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",\n  \"isEffectiveSlaDomainRetentionLocked\": true,\n  \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",\n  \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",\n  \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",\n  \"failoverClusterType\": \"Windows\",\n  \"failoverClusterId\": \"$failoverClusterId\",\n  \"failoverClusterAppSource\": {\n    \"nodeOrders\": [\n      {\n        \"nodeId\": \"$nodeId\",\n        \"nodeName\": \"$nodeName\",\n        \"order\": 0\n      }\n    ]\n  },\n  \"connectionStatus\": \"Connected\",\n  \"slaAssignment\": \"Derived\",\n  \"operatingSystemType\": \"$operatingSystemType\",\n  \"failoverClusterName\": \"$failoverClusterName\"\n}\n```\n\n### Get all failover cluster apps\nGet a listing of all failover cluster apps using\na GET request to\n[/failover_cluster/failover_cluster_app](#operation/queryFailoverClusterApp).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/failover_cluster/failover_cluster_app?sort_order=asc\"\n```\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"id\": \"$id\",\n      \"name\": \"$name\",\n      \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n      \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n      \"configuredSlaDomainType\": \"ProtectionSla\",\n      \"primaryClusterId\": \"$primaryClusterId\",\n      \"isConfiguredSlaDomainRetentionLocked\": false,\n      \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",\n      \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",\n      \"isEffectiveSlaDomainRetentionLocked\": false,\n      \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",\n      \"failoverClusterType\": \"UnixLike\",\n      \"failoverClusterId\": \"$failoverClusterId\",\n      \"failoverClusterAppSource\": {\n        \"virtualIps\": [\n          \"$virtualIp\"\n        ]\n      },\n      \"connectionStatus\": \"Connected\",\n      \"slaAssignment\": \"$slaAssignment\",\n      \"operatingSystemType\": \"Linux\",\n      \"failoverClusterName\": \"$failoverClusterName\"\n    }\n  ],\n  \"total\": 1\n}\n```\n\n\n### Get information about a specific failover cluster app\nGet information about a specific failover cluster app using\na GET request to\n[/failover_cluster/failover_cluster_app/{id}](#operation/getFailoverClusterApp).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/failover_cluster/failover_cluster_app/$failover_cluster_app_id\"\n```\n\n```bash\n{\n  \"id\": \"$id\",\n  \"name\": \"$name\",\n  \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n  \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n  \"configuredSlaDomainType\": \"ProtectionSla\",\n  \"primaryClusterId\": \"$primaryClusterId\",\n  \"isConfiguredSlaDomainRetentionLocked\": true,\n  \"slaLastUpdateTime\": \"2020-04-21T18:00:46.694Z\",\n  \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",\n  \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",\n  \"isEffectiveSlaDomainRetentionLocked\": true,\n  \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",\n  \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",\n  \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",\n  \"failoverClusterType\": \"Windows\",\n  \"failoverClusterId\": \"$failoverClusterId\",\n  \"failoverClusterAppSource\": {\n    \"virtualIps\": [\n      \"$virtualIp\"\n    ],\n  },\n  \"connectionStatus\": \"Connected\",\n  \"slaAssignment\": \"Derived\",\n  \"operatingSystemType\": \"$operatingSystemType\",\n  \"failoverClusterName\": \"$failoverClusterName\",\n  \"filesets\": [\n    {\n      \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n      \"forceFull\": true,\n      \"forceFullPartitionIds\": [\n        0\n      ],\n      \"allowBackupNetworkMounts\": true,\n      \"allowBackupHiddenFoldersInNetworkMounts\": true,\n      \"useWindowsVss\": true,\n      \"id\": \"$id\",\n      \"name\": \"$name\",\n      \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n      \"configuredSlaDomainType\": \"ProtectionSla\",\n      \"primaryClusterId\": \"$primaryClusterId\",\n      \"isConfiguredSlaDomainRetentionLocked\": true,\n      \"slaLastUpdateTime\": \"2020-04-21T18:00:46.694Z\",\n      \"hostName\": \"$hostName\",\n      \"templateId\": \"$templateId\",\n      \"templateName\": \"$templateName\",\n      \"operatingSystemType\": \"$operatingSystemType\",\n      \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",\n      \"isEffectiveSlaDomainRetentionLocked\": true,\n      \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",\n      \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",\n      \"includes\": [\n        \"$includes\"\n      ],\n      \"excludes\": [\n        \"$excludes\"\n      ],\n      \"exceptions\": [\n        \"$exceptions\"\n      ],\n      \"isRelic\": true,\n      \"isPassthrough\": true,\n      \"enableSymlinkResolution\": true,\n      \"enableHardlinkSupport\": true,\n      \"failoverClusterAppId\": \"$failoverClusterAppId\",\n      \"failoverClusterAppName\": \"$failoverClusterAppName\",\n      \"pendingSlaDomain\": {\n        \"objectId\": \"$objectId\",\n        \"pendingSlaDomainId\": \"$pendingSlaDomainId\",\n        \"pendingSlaDomainName\": \"$pendingSlaDomainName\",\n        \"isPendingSlaDomainRetentionLocked\": true\n      },\n      \"protectionDate\": \"2020-04-21T18:00:46.694Z\",\n      \"snapshotCount\": 0,\n      \"archivedSnapshotCount\": 0,\n      \"snapshots\": [\n        {\n          \"id\": \"$id\",\n          \"date\": \"2020-04-21T18:00:46.694Z\",\n          \"expirationDate\": \"2020-04-21T18:00:46.694Z\",\n          \"sourceObjectType\": \"$sourceObjectType\",\n          \"isOnDemandSnapshot\": true,\n          \"isCustomRetentionApplied\": true,\n          \"cloudState\": 0,\n          \"consistencyLevel\": \"$consistencyLevel\",\n          \"indexState\": 0,\n          \"replicationLocationIds\": [\n            \"$replicationLocationIds\"\n          ],\n          \"archivalLocationIds\": [\n            \"$archivalLocationIds\"\n          ],\n          \"slaId\": \"$slaId\",\n          \"slaName\": \"$slaName\",\n          \"isRetainedByRetentionLockSla\": true,\n          \"cloudStorageTier\": \"Hot\",\n          \"isPlacedOnLegalHold\": true,\n          \"snapshotRetentionInfo\": {\n            \"localInfo\": {\n              \"id\": \"$id\",\n              \"name\": \"$name\",\n              \"isSnapshotPresent\": true,\n              \"isExpirationDateCalculated\": true,\n              \"expirationTime\": \"2020-04-21T18:00:46.694Z\",\n              \"snapshotFrequency\": \"$snapshotFrequency\",\n              \"isExpirationInformationUnavailable\": true\n            },\n            \"archivalInfos\": [\n              {\n                \"id\": \"$id\",\n                \"name\": \"$name\",\n                \"isSnapshotPresent\": true,\n                \"isExpirationDateCalculated\": true,\n                \"expirationTime\": \"2020-04-21T18:00:46.694Z\",\n                \"snapshotFrequency\": \"$snapshotFrequency\",\n                \"isExpirationInformationUnavailable\": true\n              }\n            ],\n            \"replicationInfos\": [\n              {\n                \"id\": \"$id\",\n                \"name\": \"$name\",\n                \"isSnapshotPresent\": true,\n                \"isExpirationDateCalculated\": true,\n                \"expirationTime\": \"2020-04-21T18:00:46.694Z\",\n                \"snapshotFrequency\": \"$snapshotFrequency\",\n                \"isExpirationInformationUnavailable\": true\n              }\n            ],\n            \"cloudNativeLocationInfo\": [\n              {\n                \"id\": \"$id\",\n                \"name\": \"$name\",\n                \"isSnapshotPresent\": true,\n                \"isExpirationDateCalculated\": true,\n                \"expirationTime\": \"2020-04-21T18:00:46.694Z\",\n                \"snapshotFrequency\": \"$snapshotFrequency\",\n                \"isExpirationInformationUnavailable\": true\n              }\n            ]\n          },\n          \"filesetName\": \"$filesetName\",\n          \"fileCount\": 0,\n          \"snapdiffUsed\": true\n        }\n      ],\n      \"localStorage\": 0,\n      \"archiveStorage\": 0,\n      \"preBackupScript\": \"$preBackupScript\",\n      \"postBackupScript\": \"$postBackupScript\",\n      \"backupScriptTimeout\": 0,\n      \"backupScriptErrorHandling\": \"$backupScriptErrorHandling\"\n    }\n  ]\n}\n```\n\n### Update the parameters of an existing failover cluster app\nThe parameters associated with the failover cluster app can be updated by\nmaking a PATCH request to\n[/failover_cluster/failover_cluster_app/{id}](#operation/updateFailoverClusterApp)\n\nUse either the virtualIps or nodeOrders options in the failoverClusterAppSource request parameter to update a failover cluster app.\n\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"name\": \"$name\",\n    \"failoverClusterType\": \"Windows\",\n    \"failoverClusterId\": \"$failoverClusterId\",\n    \"failoverClusterAppSource\": {\n      \"virtualIps\": [\n        \"$virtualIp\"\n      ],\n      \"nodeOrders\": [\n        {\n          \"nodeId\": \"$nodeId\",\n          \"nodeName\": \"$nodeName\",\n          \"order\": 0\n        }\n      ]\n    },\n    \"configuredSlaDomainId\": \"string\"}'\\\n  \"https://$cluster_address/api/v1/failover_cluster/failover_cluster_app/$failover_cluster_app_id\"\n```\n\nResponse when a failover cluster app is updated using the virtualIps option in the failoverClusterAppSource request parameter.\n\n```bash\n{\n  \"id\": \"$id\",\n  \"name\": \"$name\",\n  \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n  \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n  \"configuredSlaDomainType\": \"ProtectionSla\",\n  \"primaryClusterId\": \"$primaryClusterId\",\n  \"isConfiguredSlaDomainRetentionLocked\": true,\n  \"slaLastUpdateTime\": \"2020-04-21T18:24:20.126Z\",\n  \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",\n  \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",\n  \"isEffectiveSlaDomainRetentionLocked\": true,\n  \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",\n  \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",\n  \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",\n  \"failoverClusterType\": \"Windows\",\n  \"failoverClusterId\": \"$failoverClusterId\",\n  \"failoverClusterAppSource\": {\n    \"virtualIps\": [\n      \"$virtualIp\"\n    ],\n  },\n  \"connectionStatus\": \"Connected\",\n  \"slaAssignment\": \"Derived\",\n  \"operatingSystemType\": \"$operatingSystemType\",\n  \"failoverClusterName\": \"$failoverClusterName\"\n}\n```\n\nResponse when a failover cluster app is updated using the nodeOrders option in the failoverClusterAppSource request parameter.\n\n```bash\n{\n  \"id\": \"$id\",\n  \"name\": \"$name\",\n  \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n  \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n  \"configuredSlaDomainType\": \"ProtectionSla\",\n  \"primaryClusterId\": \"$primaryClusterId\",\n  \"isConfiguredSlaDomainRetentionLocked\": true,\n  \"slaLastUpdateTime\": \"2020-04-21T18:24:20.126Z\",\n  \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",\n  \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",\n  \"isEffectiveSlaDomainRetentionLocked\": true,\n  \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",\n  \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",\n  \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",\n  \"failoverClusterType\": \"Windows\",\n  \"failoverClusterId\": \"$failoverClusterId\",\n  \"failoverClusterAppSource\": {\n    \"nodeOrders\": [\n      {\n        \"nodeId\": \"$nodeId\",\n        \"nodeName\": \"$nodeName\",\n        \"order\": 0\n      }\n    ]\n  },\n  \"connectionStatus\": \"Connected\",\n  \"slaAssignment\": \"Derived\",\n  \"operatingSystemType\": \"$operatingSystemType\",\n  \"failoverClusterName\": \"$failoverClusterName\"\n}\n```\n\n### Delete a specific failover cluster app\nRemove any failover cluster app by issuing a DELETE request to\n[/failover_cluster/failover_cluster_app/{id}](#operation/deleteFailoverClusterApp).\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/failover_cluster/failover_cluster_app/$failover_cluster_app_id?preserve_snapshots=false\"\n```\n\n### Bulk delete a failover cluster apps\nSpecify a list of failover cluster applications to remove by issuing a DELETE\nrequest to [/failover_cluster/failover_cluster_app//bulk](#operation/bulkDeleteFailoverClusterApp).\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/failover_cluster/failover_cluster_app/bulk?ids=$failover_cluster_app_id1,$failover_cluster_app_id2&preserve_snapshots=false\"\n```\n\n# Failover cluster hierarchy\n\nThis REST API is used to get failover cluster hierarchy objects.\n\n### Get summary of a hierarchy object\nGet a summary of a hierarchy object by making a GET call to\n[/failover_cluster/hierarchy/{id}](#operation/getFailoverClusterHierarchyObject).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/failover_cluster/hierarchy/$failover_cluster_app_id\"\n```\n\n```bash\n{\n  \"id\": \"$id\",\n  \"name\": \"$name\",\n  \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n  \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n  \"configuredSlaDomainType\": \"ProtectionSla\",\n  \"primaryClusterId\": \"$primaryClusterId\",\n  \"isConfiguredSlaDomainRetentionLocked\": false,\n  \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",\n  \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",\n  \"isEffectiveSlaDomainRetentionLocked\": false,\n  \"effectiveSlaSourceObjectId\": \"Global:::All\",\n  \"objectType\": \"FailoverClusterApp\",\n  \"descendentCount\": {\n    \"failoverCluster\": 0,\n    \"failoverClusterApp\": 0,\n    \"fileset\": 1\n  },\n  \"isDeleted\": false,\n  \"numNodes\": 0,\n  \"failoverClusterType\": \"UnixLike\",\n  \"failoverClusterAppConnectionStatus\": \"Connected\",\n  \"failoverClusterAppName\": \"$failoverClusterAppName\",\n  \"failoverClusterAppSource\": {\n    \"virtualIps\": [\n      \"$virtualIp\"\n    ]\n  },\n  \"slaAssignment\": \"$slaAssignment\",\n  \"filesets\": [\n    {\n      \"allowBackupNetworkMounts\": false,\n      \"allowBackupHiddenFoldersInNetworkMounts\": false,\n      \"useWindowsVss\": false,\n      \"id\": \"$id\",\n      \"name\": \"$name\",\n      \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n      \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n      \"configuredSlaDomainType\": \"ProtectionSla\",\n      \"primaryClusterId\": \"$primaryClusterId\",\n      \"isConfiguredSlaDomainRetentionLocked\": false,\n      \"hostName\": \"$hostName\",\n      \"templateId\": \"$templateId\",\n      \"templateName\": \"$templateName\",\n      \"operatingSystemType\": \"UnixLike\",\n      \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",\n      \"isEffectiveSlaDomainRetentionLocked\": false,\n      \"includes\": [\n        \"$includes\"\n      ],\n      \"excludes\": [],\n      \"exceptions\": [],\n      \"isRelic\": false,\n      \"isPassthrough\": false,\n      \"enableSymlinkResolution\": false,\n      \"enableHardlinkSupport\": false,\n      \"failoverClusterAppId\": \"$failoverClusterAppId\",\n      \"failoverClusterAppName\": \"$failoverClusterAppName\"\n    }\n  ]\n}\n```\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/failover_cluster/hierarchy/$failover_cluster_id\"\n```\n\n```bash\n{\n  \"id\": \"$id\",\n  \"name\": \"$name\",\n  \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n  \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n  \"configuredSlaDomainType\": \"ProtectionSla\",\n  \"primaryClusterId\": \"$primaryClusterId\",\n  \"isConfiguredSlaDomainRetentionLocked\": false,\n  \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",\n  \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",\n  \"isEffectiveSlaDomainRetentionLocked\": false,\n  \"effectiveSlaSourceObjectId\": \"Global:::All\",\n  \"objectType\": \"HostFailoverCluster\",\n  \"descendentCount\": {\n    \"failoverCluster\": 0,\n    \"failoverClusterApp\": 1,\n    \"fileset\": 1\n  },\n  \"isDeleted\": false,\n  \"numNodes\": 2,\n  \"nodes\": [\n    {\n      \"id\": \"$id\",\n      \"name\": \"$name\",\n      \"connectionStatus\": \"Connected\",\n      \"operatingSystem\": \"$operatingSystem\"\n    },\n    {\n      \"id\": \"$id\",\n      \"name\": \"$name\",\n      \"connectionStatus\": \"Connected\",\n      \"operatingSystem\": \"$operatingSystem\"\n    }\n  ],\n  \"failoverClusterConnectionStatus\": \"Connected\",\n  \"failoverClusterName\": \"$failoverClusterName\",\n  \"numFailoverClusterApps\": 1,\n  \"slaAssignment\": \"$slaAssignment\",\n  \"operatingSystemType\": \"$operatingSystemType\"\n}\n```\n\n### Get list of immediate descendant objects\nGet a list of immediate descendant objects using a GET request to\n[/failover_cluster/hierarchy/{id}/children](#operation/getFailoverClusterHierarchyChildren).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/failover_cluster/hierarchy/root/children\"\n```\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"id\": \"$id\",\n      \"name\": \"$name\",\n      \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n      \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n      \"configuredSlaDomainType\": \"ProtectionSla\",\n      \"primaryClusterId\": \"$primaryClusterId\",\n      \"isConfiguredSlaDomainRetentionLocked\": false,\n      \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",\n      \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",\n      \"isEffectiveSlaDomainRetentionLocked\": false,\n      \"effectiveSlaSourceObjectId\": \"Global:::All\",\n      \"objectType\": \"HostFailoverCluster\",\n      \"descendentCount\": {\n        \"failoverCluster\": 0,\n        \"failoverClusterApp\": 1,\n        \"fileset\": 1\n      },\n      \"isDeleted\": false,\n      \"numNodes\": 2,\n      \"nodes\": [\n        {\n          \"id\": \"$id\",\n          \"name\": \"$name\",\n          \"connectionStatus\": \"Connected\",\n          \"operatingSystem\": \"$operatingSystem\"\n        },\n        {\n          \"id\": \"$id\",\n          \"name\": \"$name\",\n          \"connectionStatus\": \"Connected\",\n          \"operatingSystem\": \"$operatingSystem\"\n        }\n      ],\n      \"failoverClusterConnectionStatus\": \"Connected\",\n      \"failoverClusterName\": \"$failoverClusterName\",\n      \"numFailoverClusterApps\": $numFailoverClusterApps,\n      \"slaAssignment\": \"$slaAssignment\",\n      \"operatingSystemType\": \"$operatingSystemType\"\n    }\n  ],\n  \"total\": 1\n}\n```\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/failover_cluster/hierarchy/$failover_cluster_id/children\"\n```\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"id\": \"$id\",\n      \"name\": \"$name\",\n      \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n      \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n      \"configuredSlaDomainType\": \"ProtectionSla\",\n      \"primaryClusterId\": \"$primaryClusterId\",\n      \"isConfiguredSlaDomainRetentionLocked\": false,\n      \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",\n      \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",\n      \"isEffectiveSlaDomainRetentionLocked\": false,\n      \"effectiveSlaSourceObjectId\": \"Global:::All\",\n      \"objectType\": \"FailoverClusterApp\",\n      \"descendentCount\": {\n        \"failoverCluster\": 0,\n        \"failoverClusterApp\": 0,\n        \"fileset\": 1\n      },\n      \"isDeleted\": false,\n      \"numNodes\": 0,\n      \"failoverClusterType\": \"UnixLike\",\n      \"failoverClusterAppConnectionStatus\": \"Connected\",\n      \"failoverClusterAppName\": \"$failoverClusterAppName\",\n      \"failoverClusterAppSource\": {\n        \"virtualIps\": [\n          \"$virtualIp\"\n        ]\n      },\n      \"slaAssignment\": \"$slaAssignment\",\n      \"filesets\": [\n        {\n          \"allowBackupNetworkMounts\": false,\n          \"allowBackupHiddenFoldersInNetworkMounts\": false,\n          \"useWindowsVss\": false,\n          \"id\": \"$id\",\n          \"name\": \"$name\",\n          \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n          \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n          \"configuredSlaDomainType\": \"ProtectionSla\",\n          \"primaryClusterId\": \"$primaryClusterId\",\n          \"isConfiguredSlaDomainRetentionLocked\": false,\n          \"hostName\": \"$hostName\",\n          \"templateId\": \"$templateId\",\n          \"templateName\": \"$templateName\",\n          \"operatingSystemType\": \"UnixLike\",\n          \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",\n          \"isEffectiveSlaDomainRetentionLocked\": false,\n          \"includes\": [\n            \"$includes\"\n          ],\n          \"excludes\": [],\n          \"exceptions\": [],\n          \"isRelic\": false,\n          \"isPassthrough\": false,\n          \"enableSymlinkResolution\": false,\n          \"enableHardlinkSupport\": false,\n          \"failoverClusterAppId\": \"$failoverClusterAppId\",\n          \"failoverClusterAppName\": \"$failoverClusterAppName\"\n        }\n      ]\n    }\n  ],\n  \"total\": 1\n}\n```\n\n### Get list of descendant objects\nGet a list of descendant objects using\na GET request to\n[/failover_cluster/hierarchy/{id}/descendants](#operation/getFailoverClusterHierarchyDescendants).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/failover_cluster/hierarchy/$failover_cluster_id/descendants\"\n```\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"id\": \"$id\",\n      \"name\": \"$name\",\n      \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n      \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n      \"configuredSlaDomainType\": \"ProtectionSla\",\n      \"primaryClusterId\": \"$primaryClusterId\",\n      \"isConfiguredSlaDomainRetentionLocked\": false,\n      \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",\n      \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",\n      \"isEffectiveSlaDomainRetentionLocked\": false,\n      \"effectiveSlaSourceObjectId\": \"Global:::All\",\n      \"objectType\": \"FailoverClusterApp\",\n      \"descendentCount\": {\n        \"failoverCluster\": 0,\n        \"failoverClusterApp\": 0,\n        \"fileset\": 1\n      },\n      \"isDeleted\": false,\n      \"numNodes\": 0,\n      \"failoverClusterType\": \"UnixLike\",\n      \"failoverClusterAppConnectionStatus\": \"Connected\",\n      \"failoverClusterAppName\": \"$failoverClusterAppName\",\n      \"failoverClusterAppSource\": {\n        \"virtualIps\": [\n          \"$virtualIp\"\n        ]\n      },\n      \"slaAssignment\": \"$slaAssignment\",\n      \"filesets\": [\n        {\n          \"allowBackupNetworkMounts\": false,\n          \"allowBackupHiddenFoldersInNetworkMounts\": false,\n          \"useWindowsVss\": false,\n          \"id\": \"$id\",\n          \"name\": \"$name\",\n          \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n          \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n          \"configuredSlaDomainType\": \"ProtectionSla\",\n          \"primaryClusterId\": \"$primaryClusterId\",\n          \"isConfiguredSlaDomainRetentionLocked\": false,\n          \"hostName\": \"$hostName\",\n          \"templateId\": \"$templateId\",\n          \"templateName\": \"$templateName\",\n          \"operatingSystemType\": \"UnixLike\",\n          \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",\n          \"isEffectiveSlaDomainRetentionLocked\": false,\n          \"includes\": [\n            \"$includes\"\n          ],\n          \"excludes\": [],\n          \"exceptions\": [],\n          \"isRelic\": false,\n          \"isPassthrough\": false,\n          \"enableSymlinkResolution\": false,\n          \"enableHardlinkSupport\": false,\n          \"failoverClusterAppId\": \"$failoverClusterAppId\",\n          \"failoverClusterAppName\": \"$failoverClusterAppName\"\n        }\n      ]\n    },\n    {\n      \"id\": \"$id\",\n      \"name\": \"$name\",\n      \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n      \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n      \"configuredSlaDomainType\": \"ProtectionSla\",\n      \"primaryClusterId\": \"$primaryClusterId\",\n      \"isConfiguredSlaDomainRetentionLocked\": false,\n      \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",\n      \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",\n      \"isEffectiveSlaDomainRetentionLocked\": false,\n      \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",\n      \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",\n      \"objectType\": \"Fileset\",\n      \"descendentCount\": {\n        \"failoverCluster\": 0,\n        \"failoverClusterApp\": 0,\n        \"fileset\": 0\n      },\n      \"isDeleted\": false,\n      \"numNodes\": 0,\n      \"slaAssignment\": \"$slaAssignment\"\n    }\n  ],\n  \"total\": 2\n}\n```\n\n# Filesets\n\nA fileset defines a set of files and folders on a Linux, Unix, or\nWindows host, or on NAS shares. The Rubrik cluster uses the filesets\nthat are specified for a host or a NAS share to determine the data to\nprotect on that host or share.\n\nThe Rubrik cluster interprets a fileset based on the values provided in\nthe Include, Exclude, and Do Not Exclude arrays of the fileset template\nthat the fileset is based on. The Rubrik cluster uses the values of the\narrays to determine the files and folders in a fileset. The Do Not\nExclude array specifies objects that should not be excluded from the\nfileset by the values in the Exclude array.\n\n## Fileset workflow\nTo protect data through filesets perform the following tasks:\n1. Obtain and install the Rubrik Backup Service software on the host.\nThe *Rubrik CDM User Guide* describes this task.\n2. Add the host to the Rubrik cluster.\nThe [Hosts](#section/Hosts) section describes this task.\n3. Create a fileset template that defines a set of file system data to\nprotect.\nThe [Fileset templates](#fileset-templates) section describes this task.\n4. Use a fileset template to assign a fileset to a host.\n5. Assign the host fileset to an SLA Domain.\n\n## Fileset templates\nA fileset template encompasses a set of file system metadata that is\nneeded to define filesets. The metadata includes the file system\npaths on the host that need protection or paths that do not need\nprotection.\nThe metadata varies with the type of the host or the NAS share to\nwhich the template applies.\n\n### Retrieving fileset templates\nTo retrieve the current list of fileset templates, send a GET request to the\n[`/fileset_template`](#operation/queryFilesetTemplate) endpoint.\n\n```bash\ncurl -X GET \\\n\"https://$cluster_address/api/v1/fileset_template\"\n```\n\nThe Rubrik REST API server responds with a ListResponse object containing the\nfirst page of the current list of fileset templates.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"allowBackupNetworkMounts\": false,\n      \"allowBackupHiddenFoldersInNetworkMounts\": false,\n      \"useWindowsVss\": false,\n      \"name\": \"$fileset_name\",\n      \"includes\": [\n        \"/users\"\n      ],\n      \"excludes\": [],\n      \"exceptions\": [],\n      \"operatingSystemType\": \"$os_type1\",\n      \"isArrayEnabled\": true,\n      \"id\": \"$fileset_template_id0\",\n      \"primaryClusterId\": \"$cluster_id\",\n      \"isArchived\": false,\n      \"hostCount\": 0,\n      \"shareCount\": 0\n    }\n   ],\n   \"total\": 1\n }\n```\n\nTo retrieve the details of a specific fileset template, send a GET request\nto the [`fileset_template/{id}`](#operation/getFilesetTemplate) endpoint.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/fileset_template/$fileset_template_id0\"\n```\n\nThe Rubrik REST API server responds with the details of the fileset template\nidentified by the value of the `{id}` path parameter.\n\n### Creating a fileset template\nCreate a fileset template to simplify creating identical filesets for\nmultiple hosts.\n\nOperations for a fileset object are described in the\n[Fileset](#fileset) section.\n\nTo create a fileset-template, send a POST request to\n[`/fileset_template`](#operation/createFilesetTemplate) with the\nrequired details: `name`, `includes`, and `operatingSystemType`\nor `shareType`.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"name\": \"Users\",\n    \"includes\": [\"C:\\\\Users\"],\n    \"operatingSystemType\": \"$os_type1\"\n    }' \\\n  \"https://$cluster_address/api/v1/fileset_template\"\n```\nTo create a fileset template for a specific type of NAS share, replace\n`operatingSystemType` with `shareType` in the above payload.\nFor example, `\"shareType\":\"NFS\"`.\n\nThe Rubrik REST API server responds with the new fileset template object.\n\n```bash\n{\n  \"allowBackupNetworkMounts\": true,\n  \"allowBackupHiddenFoldersInNetworkMounts\": true,\n  \"useWindowsVss\": true,\n  \"name\": \"Users\",\n  \"includes\": [\n    \"C:\\\\users\"\n  ],\n  \"excludes\": [],\n  \"exceptions\": [],\n  \"operatingSystemType\": \"$os_type1\",\n  \"isArrayEnabled\": false,\n  \"id\": \"$fileset_template_id1\",\n  \"primaryClusterId\": \"$cluster_id\",\n  \"isArchived\": false,\n  \"hostCount\": 0,\n  \"shareCount\": 0\n}\n```\n\n### Updating a fileset template\nTo modify the values of a specific fileset template, send a PATCH request\nto the [`/fileset_template/{id}`](#operation/updateFilesetTemplate)\nendpoint.\n\n```bash\ncurl -X PATCH \\\n  -d '{\n        \"id\": \"$fileset_template_id0\",\n        \"allowBackupNetworkMounts\": true\n     }' \\\n  \"https://$cluster_address/api/v1/fileset_template/$fileset_template_id0\"\n```\n\nThe Rubrik REST API server responds with the details of the updated\nfileset template.\n\n```bash\n{\n      \"allowBackupNetworkMounts\": true,\n      \"allowBackupHiddenFoldersInNetworkMounts\": false,\n      \"useWindowsVss\": false,\n      \"name\": \"$fileset_name\",\n      \"includes\": [\n        \"/users\"\n      ],\n      \"excludes\": [],\n      \"exceptions\": [],\n      \"operatingSystemType\": \"$os_type2\",\n      \"isArrayEnabled\": true,\n      \"id\": \"$fileset_template_id0\",\n      \"primaryClusterId\": \"$cluster_id\",\n      \"isArchived\": false,\n      \"hostCount\": 0,\n      \"shareCount\": 0\n    }\n```\n\n### Deleting a fileset template\nTo delete a specific fileset template and all the associated filesets,\nsend a DELETE request to the\n[`/fileset_template/{id}`](#operation/deleteFilesetTemplate) endpoint.\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/fileset_template/$fileset_template_id0\"\n```\n\n## Fileset\nA fileset is an instance of the fileset template that is assigned to a\nspecific host.\n\n### Retrieving filesets\nTo retrieve the current list of filesets, send a GET request to the\n[`/fileset`](#operation/queryFileset) endpoint.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/fileset\"\n```\nThe Rubrik REST API server responds with a ListResponse object\ncontaining the first page of the current list of filesets.\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"allowBackupNetworkMounts\": true,\n      \"allowBackupHiddenFoldersInNetworkMounts\": true,\n      \"useWindowsVss\": true,\n      \"id\": \"string\",\n      \"name\": \"string\",\n      \"configuredSlaDomainId\": \"string\",\n      \"configuredSlaDomainName\": \"string\",\n      \"configuredSlaDomainType\": \"ProtectionSla\",\n      \"primaryClusterId\": \"string\",\n      \"isConfiguredSlaDomainRetentionLocked\": true,\n      \"slaLastUpdateTime\": \"2021-03-03T18:42:24.766Z\",\n      \"hostId\": \"string\",\n      \"shareId\": \"string\",\n      \"hostName\": \"string\",\n      \"templateId\": \"string\",\n      \"templateName\": \"string\",\n      \"operatingSystemType\": \"string\",\n      \"effectiveSlaDomainId\": \"string\",\n      \"isEffectiveSlaDomainRetentionLocked\": true,\n      \"effectiveSlaDomainName\": \"string\",\n      \"effectiveSlaDomainPolarisManagedId\": \"string\",\n      \"includes\": [\n        \"string\"\n      ],\n      \"excludes\": [\n        \"string\"\n      ],\n      \"exceptions\": [\n        \"string\"\n      ],\n      \"isRelic\": true,\n      \"arraySpec\": {\n        \"proxyHostId\": \"string\"\n      },\n      \"isPassthrough\": true,\n      \"enableSymlinkResolution\": true,\n      \"enableHardlinkSupport\": true,\n      \"failoverClusterAppId\": \"string\",\n      \"failoverClusterAppName\": \"string\",\n      \"pendingSlaDomain\": {\n        \"objectId\": \"string\",\n        \"pendingSlaDomainId\": \"string\",\n        \"pendingSlaDomainName\": \"string\",\n        \"isPendingSlaDomainRetentionLocked\": true\n      },\n      \"snapMirrorLabelForFullBackup\": \"string\",\n      \"snapMirrorLabelForIncrementalBackup\": \"string\"\n    }\n  ],\n  \"total\": 0\n}\n```\n\nTo retrieve the details of a specific fileset, send a GET request to the\n[`/fileset/{id}`](#operation/getFileset) endpoint.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/fileset/$fileset_id\"\n```\n\nThe Rubrik REST API server responds with the details of the fileset\nidentified by the value of the {id} path parameter.\n\n### Creating a fileset\nTo create a fileset, send a POST request to [`/fileset`](#operation/createFileset) with the required details: the `hostId` or `shareId`, and\nthe `templateId`.\nSee [Retrieving fileset templates](#retrieving-fileset-templates) for\ninformation on obtaining a template ID, to create a fileset.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"templateId\": \"$fileset_template_id\",\n    \"hostId\": \"$host_id\" }' \\\n  \"https://$cluster_address/api/v1/fileset\"\n```\nTo create a fileset for a NAS share, replace `hostId` with `shareId` in\nthe above payload.\nFor example, `\"shareId\": \"$share_id\"`.\n\nThe Rubrik REST API server responds with the new fileset object.\n\n```bash\n{\n  \"configuredSlaDomainId\": \"UNPROTECTED\",\n  \"forceFull\": false,\n  \"forceFullPartitionIds\": [],\n  \"allowBackupNetworkMounts\": true,\n  \"allowBackupHiddenFoldersInNetworkMounts\": false,\n  \"useWindowsVss\": false,\n  \"id\": \"$fileset_id\",\n  \"name\": \"$fileset_name\",\n  \"configuredSlaDomainName\": \"Unprotected\",\n  \"configuredSlaDomainType\": \"ProtectionSla\",\n  \"primaryClusterId\": \"$cluster_id\",\n  \"isConfiguredSlaDomainRetentionLocked\": false,\n  \"hostId\": \"$host_id\",\n  \"hostName\": \"$hostname\",\n  \"templateId\": \"$fileset_template_id\",\n  \"templateName\": \"$fileset_template_name\",\n  \"operatingSystemType\": \"UnixLike\",\n  \"effectiveSlaDomainId\": \"UNPROTECTED\",\n  \"isEffectiveSlaDomainRetentionLocked\": false,\n  \"effectiveSlaDomainName\": \"Unprotected\",\n  \"includes\": [\n    \"$location_to_protect\"\n  ],\n  \"excludes\": [],\n  \"exceptions\": [],\n  \"isRelic\": false,\n  \"isPassthrough\": false,\n  \"enableSymlinkResolution\": false,\n  \"enableHardlinkSupport\": false,\n  \"snapshotCount\": 0,\n  \"archivedSnapshotCount\": 0,\n  \"snapshots\": []\n}\n```\n### Updating a fileset\nTo update the values of a specific fileset, send a PATCH request to the\n[`/fileset/{id}`](#operation/updateFileset) endpoint. The request\npayload includes the properties to be updated.\n\n```bash\ncurl -X PATCH \\\n  -d '{\n           \"configuredSlaDomainId\": \"string\",\n           \"forceFull\": true,\n           \"forceFullPartitionIds\": [\n                       0\n            ],\n            \"snapMirrorLabelForFullBackup\": \"string\",\n            \"snapMirrorLabelForIncrementalBackup\": \"string\"\n       }' \\\n  \"https://$cluster_address/api/v1/fileset/$fileset_id\"\n```\n\nThe Rubrik REST API server responds with the details of the updated\nfileset.\n\n### Deleting a fileset\nTo delete a specific fileset, send a DELETE request to the\n[`/fileset/{id}`](#operation/deleteFileset) endpoint. \nBy default, the Rubrik cluster preserves the snapshots of the fileset to\nbe deleted.\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/fileset/$fileset_id\"\n```\nTo delete the snapshots of the fileset along with the fileset, set the\n`preserve_snapshots` query parameter to `false` in the DELETE\nrequest.\n\n```bash\ncurl -X DELETE \\\n\"https://$cluster_address/api/v1/fileset/$fileset_id?preserve_snapshots=false\"\n```\nThe Rubrik REST API server deletes the specified fileset and the\nsnapshots associated with the fileset.\n\n## On-demand backups of host filesets\n### Creating on-demand snapshot\nTo initiate an on-demand snapshot of a fileset, send a POST request to\nthe [`/fileset/{id}/snapshot`](#operation/createFilesetBackupJob)\nendpoint.\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/fileset/$fileset_id/snapshot\"\n```\n\nThe Rubrik REST API responds with the ID for the on-demand snapshot\nrequest along with other details about the request, like the status and\nthe time at which the request was received.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"2021-03-04T20:07:55.169Z\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/fileset/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n### Retrieving snapshot ID\nTo retrieve the snapshot ID, retrieve the status of the on-demand\nsnapshot request by sending a GET request to the\n[`/fileset/request/{id}`](#operation/getFilesetAsyncRequestStatus)\nendpoint.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/fileset/request/$request_id\"\n```\n\nThe Rubrik REST API server responds with the status of the on-demand\nsnapshot request. If the snapshot has completed successfully, the\nresponse includes the ID for the snapshot in the reference link to the\nsnapshot.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"status\": \"SUCCEEDED\",\n  \"startTime\": \"2021-03-04T20:07:55.169Z\",\n  \"endTime\": \"2021-03-04T20:12:54.792Z\",\n  \"nodeId\": \"$node_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/fileset/$snapshot_id/snapshot\",\n      \"rel\": \"result\"\n    },\n    {\n      \"href\": \"https://$cluster_address/api/v1/fileset/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Retrieving snapshot details\nTo retrieve information about a specific snapshot, send a GET request to\nthe [`/fileset/snapshot/{id}`](#operation/getFilesetSnapshot) endpoint.\nBy default, the flag to return verbose information about the fileset is set to `false`. Change the value of the `verbose` flag to `true` to get\ndetailed information about the fileset.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id?verbose=false\"\n```\nThe Rubrik REST API responds with the details of the specified fileset snapshot.\n\n```bash\n{\n  \"id\": \"$snapshot_id\",\n  \"date\": \"2021-03-04T20:08:00.000Z\",\n  \"sourceObjectType\": \"Fileset\",\n  \"isOnDemandSnapshot\": true,\n  \"isCustomRetentionApplied\": false,\n  \"cloudState\": 0,\n  \"indexState\": 1,\n  \"replicationLocationIds\": [],\n  \"archivalLocationIds\": [],\n  \"slaId\": \"UNPROTECTED\",\n  \"slaName\": \"Unprotected\",\n  \"isRetainedByRetentionLockSla\": false,\n  \"isPlacedOnLegalHold\": false,\n  \"snapshotRetentionInfo\": {\n    \"localInfo\": {\n      \"id\": \"$cluster_id\",\n      \"name\": \"LOCAL\",\n      \"isSnapshotPresent\": true,\n      \"isExpirationDateCalculated\": true,\n      \"snapshotFrequency\": \"Forever\"\n    },\n    \"archivalInfos\": [],\n    \"replicationInfos\": [],\n    \"cloudNativeLocationInfo\": []\n  },\n  \"filesetName\": \"$fileset_name\",\n  \"fileCount\": 10,\n  \"lastModified\": \"2021-02-24T14:13:33+0000\",\n  \"size\": 23572\n}\n```\n\n### Deleting fileset snapshots\nTo delete a specific fileset snapshot, send a DELETE request to the\n[`/fileset/snapshot/{id}`](#operation/deleteFilesetSnapshot) endpoint,\nwhere `{id}` is the ID of the snapshot.\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id\"\n```\nThe Rubrik REST API deletes the specified fileset snapshot.\n\nTo delete all the snapshots of a specific fileset, send a DELETE request\nto the [`/fileset/{id}/snapshot`](#operation/deleteFilesetSnapshots)\nendpoint, where `{id}` is the ID of the fileset.\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/fileset/$fileset_id/snapshot\"\n```\nThe Rubrik REST API deletes all the snapshots of the specified fileset.\n\n## SLA Domain protection of host filesets\n\nTo assign an SLA to a fileset, send a PATCH request to the\n[`/fileset/{id}`](#operation/updateFileset) endpoint.\n\n```bash\ncurl -X PATCH \\\n  -d '{ \n    \"configuredSlaDomainId\": \"$sla_domain_id\" }' \\\n  \"https://$cluster_address/api/v1/fileset/$fileset_id\"\n```\nThe Rubrik REST API server responds with the details of the updated\nfileset.\n\n```bash\n{\n  \"id\": \"$fileset_id\",\n  \"excludes\": [],\n  \"operatingSystemType\": \"Windows\",\n  \"includes\": [\n    \"C:\\\\Users\"\n  ],\n  \"hostId\": \"$host_id\",\n  \"templateId\": \"$fileset_template_id\",\n  \"configuredSlaDomainId\": \"$sla_domain_id\"\n}\n```\n\n### Retrieving missed snapshots\nTo retrieve the details of snapshots that were missed for a fileset,\nsend a GET request to the [`/fileset/{id}/missed_snapshot`](#operation/getMissedFilesetSnapshots) endpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/fileset/$fileset_id/missed_snapshot\"\n```\nThe Rubrik REST API server responds with the details of snapshots\nthat were missed, for the specified fileset.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"archivalLocationType\": [\n        \"LOCAL\"\n      ],\n      \"missedSnapshotTime\": \"2021-03-04T07:59:59.999Z\",\n      \"missedSnapshotTimeUnits\": [\n        {\n          \"timeUnit\": \"Daily\",\n          \"frequency\": 1,\n          \"retention\": 2\n        }\n      ]\n    }\n  ],\n  \"total\": 1\n}\n```\n\n## Search & Recovery\n### Searching at fileset-level\nTo search for specific file within a fileset, send a GET request to the\n[`/fileset/{id}/search`](#operation/searchFileset) endpoint. Specify\na path prefix or a filename prefix in the `path` query parameter.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/fileset/$fileset_id/search?path=$path\"\n```\n\nThe Rubrik REST API server responds with the details of the files that\nmatch the search query.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"path\": \"$path_to_file\",\n      \"filename\": \"$filename\",\n      \"fileVersions\": [\n        {\n          \"snapshotId\": \"$snapshot_id\",\n          \"lastModified\": \"2014-07-17T02:02:54+0000\",\n          \"size\": 533120,\n          \"fileMode\": \"file\",\n          \"source\": \"cloud\"\n        }\n      ]\n    }\n  ],\n  \"total\": 1\n}\n```\n### Searching at host-level\nTo search for specific file at the host-level, send a GET request to the\n[`/host/{id}/search`](#operation/searchHost) endpoint. Specify\na path prefix or a filename prefix in the `path` query parameter.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/host/$host_id/search?path=$path\"\n```\n\nThe Rubrik REST API server responds with the details of the files that\nmatch the search query.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"path\": \"$path_to_file\",\n      \"filename\": \"$filename\",\n      \"fileVersions\": [\n        {\n          \"snapshotId\": \"$snapshot_id\",\n          \"lastModified\": \"2014-07-17T02:02:54+0000\",\n          \"size\": 533120,\n          \"fileMode\": \"file\",\n          \"source\": \"cloud\"\n        }\n      ]\n    }\n  ],\n  \"total\": 1\n}\n```\n\n### Browsing files in a snapshot\nTo list all files and folders within a snapshot, send a GET request to the\n[`/fileset/snapshot/{id}/browse`](#operation/browseFilesetSnapshot)\nendpoint.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/browse?path=$absolute_file_path\"\n```\n\nThe Rubrik REST API server responds with the details of all the files\nand folders available at the specified path in the snapshot.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"filename\": \"$filename\",\n      \"path\": \"$path_relative_to_absolute_file_path\",\n      \"lastModified\": \"2016-12-01T23:26:59+0000\",\n      \"size\": 529024,\n      \"fileMode\": \"file\",\n      \"statusMessage\": \"\"\n    }\n  ],\n  \"total\": 1\n}\n```\n### Download options\nThere are two options for downloading the files of a fileset snapshot:\ndownload the entire snapshot or download specific files from the\nsnapshot.\n\nTo download the entire snapshot from an archival location, send a\nPOST request to the\n[`/fileset/snapshot/{id}/download`](#operation/createDownloadFilesetSnapshotFromCloud) endpoint.\n\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/download\"\n```\n\nTo download files from a specific location in a snapshot, send a POST\nrequest to the [`/fileset/snapshot/{id}/download_file`](#operation/createFilesetDownloadFileJob) endpoint.\n\n```bash\ncurl -X POST -d \\\n'{\n    \"sourceDir\": \"$path_to_download_from\"\n }' \\\n  \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/download_file\"\n```\n\nThe Rubrik REST API server initiates an async download job and returns\na job instance ID.\n\n```bash\n{\n  \"id\": \"$job_instance_id\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"2021-03-05T18:19:27.584Z\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address//api/v1/fileset/request/$job_instance_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\nTo retrieve the download location, send a GET request to the\n[`fileset/request/{id}`](#operation/getFilesetAsyncRequestStatus) endpoint where, `{id}` is the `$job_instance_id`.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/fileset/request/$job_instance_id\"\n```\n\nThe Rubrik REST API server responds with the status of the download\njob. The response includes a download link when the job completes\nsuccessfully.\n\n```bash\n{\n  \"id\": \"$job_instance_id\",\n  \"status\": \"SUCCEEDED\",\n  \"startTime\": \"2021-03-05T18:01:43.755Z\",\n  \"endTime\": \"2021-03-05T18:02:48.481Z\",\n  \"nodeId\": \"$node_id\",\n  \"links\": [\n    {\n      \"href\": \"$download_url\",\n      \"rel\": \"result\"\n    },\n    {\n      \"href\": \"https://$cluster_address/api/v1/fileset/request/$job_instance_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Recovery options\nTo restore files from a fileset snapshot on to the source host, send a\nPOST request to the [`/fileset/snapshot/{id}/restore_file`](#operation/createFilesetRestoreFileJob) endpoint.\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"sourceDir\": \"$source_of_restore\",\n    \"destinationDir\": \"$destination_of_restore\"\n  }' \\\n  \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/restore_file\"\n```\n\nTo restore files from a fileset snapshot on to a host other than the\nsource host, send a POST request to the [`/fileset/snapshot/{id}/export_file`](#operation/createFilesetExportFileJob).\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"sourceDir\": \"$source_of_restore\",\n    \"destinationDir\": \"$destination_of_restore\",\n    \"hostId\": \"$destination_host_id\"\n  }' \\\n  \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/export_file\"\n```\n\nThe Rubrik REST API server initiates an async restore job and returns\na job instance ID.\n\n```bash\n{\n  \"id\": \"$job_instance_id\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"2021-03-05T18:19:27.584Z\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address//api/v1/fileset/request/$job_instance_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\nTo check the progress of the request, send a GET request to the\n[`fileset/request/{id}`](#operation/getFilesetAsyncRequestStatus) endpoint where, `{id}` is the `$job_instance_id`.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/fileset/request/$job_instance_id\"\n```\n\nThe Rubrik REST API server responds with the status of the restore\njob.\n\n```bash\n{\n  \"id\": \"$job_instance_id\",\n  \"status\": \"SUCCEEDED\",\n  \"startTime\": \"2021-03-05T18:01:43.755Z\",\n  \"endTime\": \"2021-03-05T18:02:48.481Z\",\n  \"nodeId\": \"$node_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/fileset/request/$job_instance_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n#  host hierarchy\n\nThis REST API is used to get host/share hierarchy objects.\n\n### Get summary of a hierarchy object\nGet a summary of a hierarchy object by making a GET call to\n[/host/hierarchy/{id}]\\\n(#operation/getHostHierarchyObject).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/host/hierarchy/{id}\"\n```\n\nThe Rubrik REST API server returns a host hierarchy object contains the ID,\nobjectType, status, descendantCount, primaryClusterId, name, alias,\noperatingSystem, operatingSystemType shareType, vendorType, hostId, exportPoint,\nfilesets and isSnapdiff.\n\n### Get list of immediate descendant objects\nGet a list of immediate descendant objects using a GET request to\n[/host/hierarchy/{id}/children]\\\n(#operation/getHostHierarchyChildren).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/host/hierarchy/{id}/children\"\n```\n\nThe Rubrik REST API server returns a list of host hierarchy objects.\n\n# Directories\n\nA HDFS directory defines a set of files and folders on a HDFS cluster.  The Rubrik cluster uses the directorys that are assigned to a HDFS cluster to determine the data to protect on that cluster.\n\nThe Rubrik cluster interprets a directory based on the values provided in the\nInclude, Exclude, and Do Not Exclude arrays. The Rubrik cluster applies a\nset of rules to the values provided in these arrays and permits several\ntypes of values to be added to the arrays. The Do Not Exclude array specifies objects that should not be excluded from the directory by the values in the Exclude array.\n\n## Directory workflow\nThe basic workflow to follow when using directorys to protect data in host file systems is:\n1. Obtain and install the Rubrik Backup Service software on the HDFS cluster.\nThe Rubrik user guide describes this task.\n2. Add the HDFS cluster to the Rubrik cluster.\nThe [Hosts](#section/Hosts) section describes this task.\n3. Create a directory template that defines a set of file system data to protect.\n4. Use a directory template to assign a directory to a host.\n5. Assign the host directory to an SLA Domain.\n\n## Directory templates\n\nFirst, create a directory template.\nA directory template can be used to create directory instances for various HDFS clusters.\nPerforming a POST on [`/hdfs_template`](#operation/createHdfsTemplate)  with the necessary details will create a directory template.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"name\": \"Users\",\n    \"includes\": [\"/Users\"]}' \\\n  \"https://$cluster_address/api/v1/hdfs_template\"\n```\n\n```bash\n{\n  \"id\": \"$directory_template_id\",\n  \"name\": \"Users\",\n  \"excludes\": [],\n  \"includes\": [\n    \"/Users\"\n  ]\n}\n```\n\nTo get the details of a directory template, use GET on the [`/hdfs_template/{id}`](#operation/getHdfsTemplate) endpoint.\n\n```bash\ncurl -X GET \\\n  -d '{\n    \"id\": \"$directory_template_id\" }' \\\n  \"https://$cluster_address/api/v1/hdfs_template\"\n```\n\n```bash\n{\n  \"id\": \"$host_id\",\n  \"hostname\": \"$hostname\",\n  \"status\": \"Connected\"\n}\n```\n\nTo get the current list of all directory templates matching a query, use GET on the [`/hdfs_template`](#operation/queryHdfsTemplate) endpoint.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"hostname\": \"$hostname\" }' \\\n  \"https://$cluster_address/api/v1/hdfs_template\"\n```\n\n```bash\n{\n  \"id\": \"$host_id\",\n  \"hostname\": \"$hostname\",\n  \"status\": \"Connected\"\n}\n```\n\nModify with PATCH on the [`/hdfs_template/{id}`](#operation/updateHdfsTemplate) endpoint.\n\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"id\": \"$directory_template_id\" }' \\\n  \"https://$cluster_address/api/v1/hdfs_template\"\n```\n\n```bash\n{\n  \"id\": \"$host_id\",\n  \"hostname\": \"$hostname\",\n  \"status\": \"Connected\"\n}\n```\n\nDelete with the [`/hdfs_template/{id}`](#operation/deleteHdfsTemplate) endpoint.\n\n```bash\ncurl -X DELETE \\\n  -d '{\n    \"id\": \"$directory_template_id\" }' \\\n  \"https://$cluster_address/api/v1/hdfs_template\"\n```\n## Directory\n\nCreate a directory using a directory template.\nThe directory is an instance of the template that is assigned to a specific HDFS cluster.\n\nTo get the current list of HDFS clusters, use GET on the [`/hdfs`](#operation/queryHdfs) endpoint.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"hostname\": \"$hostname\" }' \\\n  \"https://$cluster_address/api/v1/hdfs\"\n```\n\n```bash\n{\n  \"id\": \"$host_id\",\n  \"hostname\": \"$hostname\",\n  \"status\": \"Connected\"\n}\n```\n\nTo get the current further details of HDFS clusters, use GET on the [`/hdfs/{id}`](#operation/getHdfs) endpoint.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"hostname\": \"$hostname\" }' \\\n  \"https://$cluster_address/api/v1/hdfs\"\n```\n\n```bash\n{\n  \"id\": \"$host_id\",\n  \"hostname\": \"$hostname\",\n  \"status\": \"Connected\"\n}\n```\n\nA directory can be created with a POST on [`/hdfs`](#operation/createHdfs).\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"templateId\": \"$directory_template_id\",\n    \"hostId\": \"$host_id\" }' \\\n  \"https://$cluster_address/api/v1/hdfs\"\n```\n\n```bash\n{\n  \"id\": \"$directory_id\",\n  \"excludes\": [],\n  \"includes\": [\n    \"/Users\"\n  ],\n  \"hostId\": \"$host_id\",\n  \"templateId\": \"$directory_template_id\",\n  \"configuredSlaDomainId\": \"UNPROTECTED\"\n}\n```\n\nA directory can be deleted with a DELETE on [`/hdfs`](#operation/deleteHdfs).\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"templateId\": \"directory_template_id\",\n    \"hostId\": \"$host_id\" }' \\\n  \"https://$cluster_address/api/v1/hdfs\"\n```\n\n```bash\n{\n  \"id\": \"$directory_id\",\n  \"excludes\": [],\n  \"includes\": [\n    \"/Users\"\n  ],\n  \"hostId\": \"$host_id\",\n  \"templateId\": \"$directory_template_id\",\n  \"configuredSlaDomainId\": \"UNPROTECTED\"\n}\n```\n## On demand backups of HDFS cluster directorys\n\nTo create an on-demand snapshot, use POST on [`/hdfs/{id}/snapshot`](#operation/createHdfsBackupJob).\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/hdfs/$directory_id/snapshot\"\n```\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/hdfs/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"QUEUED\"\n}\n```\n\nAfter taking a snapshot, retrieve the `$snapshot_id` by querying [`/hdfs/request`](#operation/getHdfsAsyncRequestStatus).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/hdfs/request/$request_id\"\n```\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/hdfs/snapshot/$snapshot_id\",\n      \"rel\": \"result\"\n    },\n    {\n      \"href\": \"https://$cluster_address/api/v1/hdfs/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"SUCCEEDED\"\n}\n```\n\n\nAfter taking a snapshot, retrieve the `$snapshot_id` from the request.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/hdfs/request/$request_id\"\n```\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/hdfs/snapshot/$snapshot_id\",\n      \"rel\": \"result\"\n    },\n    {\n      \"href\": \"https://$cluster_address/api/v1/hdfs/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"SUCCEEDED\"\n}\n```\n\nFor more information about a specific snapshot, send a GET request to\nthe [`/hdfs/snapshot/{id}`](#operation/getHdfsSnapshot) endpoint.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/hdfs/snapshot/$snapshot_id\"\n```\n\n```bash\n{\n  \"id\": \"$snapshot_id\"\n  \"date\": <timestamp1>,\n  \"expirationDate\": <timestamp2>,\n  \"sourceObjectType\": \"Hdfs\",\n  \"isOnDemandSnapshot\": true,\n  \"cloudState\": 2,\n  \"consistencyLevel\": \"none\",\n  \"indexState\": 1,\n  \"replicationLocationIds\": [\n    \"$replication_location_id\"\n  ],\n  \"archivalLocationIds\": [\n    \"$archival_location_id\"\n  ],\n  \"slaId\": \"$sla_id\",\n  \"slaName\": \"sla\",\n  \"directoryName\": \"directory\",\n  \"fileCount\": 10,\n  \"lastModified\": <timestamp3>,\n  \"size\": 533120\n}\n```\n\nTo delete a specific snapshot, send a DELETE request to the\n[`/hdfs/snapshot/{id}`](#operation/deleteHdfsSnapshot) endpoint,\nwhere `{id}` is the ID of the snapshot.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/hdfs/snapshot/$snapshot_id\"\n```\n\n```bash\n{\n}\n```\n\nDelete all snapshots for a specific HDFS cluster with a DELETE on [`/hdfs/{id}/snapshot`](#operation/deleteHdfsSnapshots).\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/hdfs/$id/snapshot\"\n```\n## SLA Domain protection of host directorys\n\nAssign a directory to an SLA with a PATCH [`/hdfs/{id}`](#operation/updateHdfs).\n\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"configuredSlaDomainId\": \"$sla_domain_id\" }' \\\n  \"https://$cluster_address/api/v1/hdfs/$directory_id\"\n```\n\n```bash\n{\n  \"id\": \"$directory_id\",\n  \"excludes\": [],\n  \"includes\": [\n    \"/Users\"\n  ],\n  \"hostId\": \"$host_id\",\n  \"templateId\": \"$directory_template_id\",\n  \"configuredSlaDomainId\": \"$sla_domain_id\"\n}\n```\n\nList missed snapshots with a GET on [`/hdfs/{id}/missed_snapshot`](#operation/getMissedHdfsSnapshots).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/hdfs/$id/missed_snapshot\"\n```\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"missedSnapshotTime\": \"2000-01-02T11:08:40.420Z\"\n    }\n  ],\n  \"total\": 1\n}\n```\n\n## Search & Recovery\n\nOnce snapshots have been taken, they can be used to search for files and recover.\n\nFile search can be performed on a specific directory using its `$directory_id` with a GET on [`/hdfs/{id}/search`](#operation/searchHdfs) and specifying the file path with the `path` query parameter.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/hdfs/$directory_id/search?path=home\"\n```\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"path\": \"/home\",\n      \"filename\": \"home\",\n      \"fileVersions\": [\n        {\n          \"snapshotId\": \"$snapshot_id\",\n          \"lastModified\": \"2014-07-17T02:02:54+0000\",\n          \"size\": 533120\n        }\n      ]\n    }\n  ],\n  \"total\": 1\n}\n```\n\nFiles within a snapshot can be browsed by using GET on [`/hdfs/snapshot/{id}/browse`](#operation/browseHdfsSnapshot).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/hdfs/snapshot/$snapshot_id/browse?path=%2Fhome&offset=0\"\n```\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"filename\": \"ubuntu\",\n      \"path\": \"ubuntu\",\n      \"lastModified\": \"2016-12-01T23:26:59+0000\",\n      \"size\": 529024,\n    }\n  ],\n  \"total\": 1\n}\n```\n\nFiles from a snapshot can also be restored to a host with POST on [`/hdfs/snapshot/{id}/restore_file`](#operation/createHdfsRestoreFileJob).\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"sourceDir\": \"/foo.txt\",\n    \"destinationDir\": \"/bar.txt\"\n  }' \\\n  \"https://$cluster_address/api/v1/hdfs/snapshot/$snapshot_id/restore_file\"\n```\n\nFiles can also be restored to a different host with POST on [`/hdfs/snapshot/{id}/export_file`](#operation/createHdfsExportFileJob).\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"sourceDir\": \"/foo.txt\",\n    \"destinationDir\": \"/bar.txt\",\n    \"hostId\": \"$host_id\"\n  }' \\\n  \"https://$cluster_address/api/v1/hdfs/snapshot/$snapshot_id/export_file\"\n```\n\n# SQL Server databases\n\nVersion 3.0 added support for Microsoft SQL backups.\nFirst add the hosts hosting the Microsoft SQL databases as specified in the [host protection](#section/Hosts) section.\nOnce the host has been added, instances and databases will be auto-discovered.\n\n## Instances\n\nMicrosoft SQL instances can be found by a GET on [`/mssql/instance`](#operation/queryMssqlInstance)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/instance\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"$instance_id\",\n      \"name\": \"$instance_name\",\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"configuredSlaDomainName\": \"Inherit\",\n      \"effectiveSlaDomainId\": \"INHERIT\",\n      \"effectiveSlaDomainName\": \"Inherit\"\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\nFurther details are acquired from [`/mssql/instance/{id}`](#operation/getMssqlInstance).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/instance/$instance_id\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"$instance_id\",\n      \"name\": \"$instance_name\",\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"configuredSlaDomainName\": \"Inherit\",\n      \"effectiveSlaDomainId\": \"UNPROTECTED\",\n      \"effectiveSlaDomainName\": \"Unprotected\"\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\nThe Rubrik cluster auto-detects most fields of the Microsoft SQL instance. However, certain fields such as the `clusterInstanceAddress` can be overridden with a PATCH to [`/mssql/instance/{id}`](#operation/updateMssqlInstance).\n\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"clusterInstanceAddress\": \"1.1.1.1\"\n  }' \\\n  \"https://$cluster_address/api/v1/mssql/instance/$instance_id\"\n```\n\n```bash\n{\n  \"data\": [\n    '{\n      \"id\": \"$instance_id\",\n      \"name\": \"$instance_name\",\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"configuredSlaDomainName\": \"Inherit\",\n      \"effectiveSlaDomainId\": \"UNPROTECTED\",\n      \"effectiveSlaDomainName\": \"Unprotected\",\n      \"clusterInstanceAddress\": \"1.1.1.1\"\n  }' \\\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\nThe total number of SQL Server Instances can be found by GET on\n[/mssql/instance/count](#operation/countMssqlInstanceV1).\n\n  ```bash\n  curl -X GET \"https://$cluster_address/api/v1/mssql/instance/count\"\n  ```\n\n  ```bash\n  {\n    \"count\": $total_number_of_instances\n  }\n  ```\n\n## Databases\n\nAll Microsoft SQL databases on an instance can be found with a GET on\n [`/mssql/db`](#operation/queryMssqlDb).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/db?instance_id=$instance_id\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"$db_id\",\n      \"name\": \"$db_name\",\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"configuredSlaDomainName\": \"Inherit\",\n      \"effectiveSlaDomainId\": \"UNPROTECTED\",\n      \"effectiveSlaDomainName\": \"Unprotected\",\n      \"instanceId\": \"$instance_id\"\n      \"instanceName\": \"$instance_name\"\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\nFurther details are acquired from [`/mssql/db/{id}`](#operation/getMssqlDb).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/db/$db_id\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"$db_id\",\n      \"name\": \"$db_name\",\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"configuredSlaDomainName\": \"Inherit\",\n      \"effectiveSlaDomainId\": \"UNPROTECTED\",\n      \"effectiveSlaDomainName\": \"Unprotected\",\n      \"instanceId\": \"$instance_id\"\n      \"instanceName\": \"$instance_name\"\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\nThe total number of SQL Server Databases can be found by GET on\n [/mssql/db/count](#operation/countMssqlDbV1).\n\n  ```bash\n  curl -X GET \"https://$cluster_address/api/v1/mssql/db/count?root_id=$host_id\"\n  ```\n\n  ```bash\n  {\n    \"numTotal\": 15,\n    \"numProtected\": 2,\n    \"numNoSla\": 0,\n    \"numDoNotProtect\": 13\n  }\n  ```\n\nSnappable Id of a SQL Server database can be found by GET on\n[/mssql/db/{id}/snappable_id](#operation/mssqlGetSnappableIdV1).\n\n  ```bash\n  curl -X GET \"https://$cluster_address/api/v1/mssql/db/$db_id/snappable_id\"\n  ```\n\n  ```bash\n  {\n    \"snappableId\": \"$snappable_id\"\n  }\n  ```\n\nThe properties of SQL Server database can be updated by PATCH on\n[/mssql/db/bulk](#operation/bulkUpdateMssqlDbV1).\n\n```bash\ncurl -X PATCH \"https://$cluster_address/api/v1/mssql/db/bulk\" -d\\\n'[\n  {\n      \"databaseId\": \"$db_id\",\n      \"updateProperties\": {\n         \"logBackupFrequencyInSeconds\": 2000,\n         \"logRetentionHours\": 180,\n         \"copyOnly\": true,\n         \"maxDataStreams\": 8,\n         \"isPaused\": true,\n         \"shouldForceFull\": true\n   }\n }\n]'\n```\n\n```bash\n[\n  {\n    \"id\": \"MssqlDatabase:::5d1da757-95d0-4740-9851-53c25c3dda2d\",\n    \"name\": \"simple_rec\",\n    \"configuredSlaDomainId\": \"ea82adf1-fa12-4b33-89af-9c2a08802a5d\",\n    \"configuredSlaDomainName\": \"Gold\",\n    \"configuredSlaDomainType\": \"ProtectionSla\",\n    \"primaryClusterId\": \"977dbc71-8137-4de5-be23-67251f0b63c1\",\n    \"isConfiguredSlaDomainRetentionLocked\": false,\n    \"effectiveSlaDomainId\": \"ea82adf1-fa12-4b33-89af-9c2a08802a5d\",\n    \"effectiveSlaDomainName\": \"Gold\",\n    \"isEffectiveSlaDomainRetentionLocked\": false,\n    \"effectiveSlaSourceObjectId\": \"MssqlDatabase:::5d1da757-95d0-4740-9851-53c25c3dda2d\",\n    \"effectiveSlaSourceObjectName\": \"simple_rec\",\n    \"slaAssignment\": \"Direct\",\n    \"retentionSlaDomainId\": \"ea82adf1-fa12-4b33-89af-9c2a08802a5d\",\n    \"rootProperties\": {\n      \"rootType\": \"Host\",\n      \"rootId\": \"Host:::151e41d1-5395-4940-98ec-17460eae8949\",\n      \"rootName\": \"10.0.46.37\"\n    },\n    \"instanceId\": \"MssqlInstance:::442b9524-9e45-4b03-aa66-eec1f3d0c470\",\n    \"instanceName\": \"SQLEXPRESS\",\n    \"isRelic\": false,\n    \"copyOnly\": true,\n    \"logBackupFrequencyInSeconds\": 2000,\n    \"logBackupRetentionHours\": 180,\n    \"isLiveMount\": false,\n    \"isLogShippingSecondary\": false,\n    \"recoveryModel\": \"FULL\",\n    \"state\": \"ONLINE\",\n    \"hasPermissions\": true,\n    \"isInAvailabilityGroup\": false,\n    \"replicas\": [\n      {\n        \"instanceId\": \"MssqlInstance:::442b9524-9e45-4b03-aa66-eec1f3d0c470\",\n        \"instanceName\": \"SQLEXPRESS\",\n        \"recoveryModel\": \"FULL\",\n        \"state\": \"ONLINE\",\n        \"hasPermissions\": true,\n        \"isStandby\": false,\n        \"recoveryForkGuid\": \"83145A93-8921-4318-8508-B9ABE1D3B0F6\",\n        \"isArchived\": false,\n        \"isDeleted\": false,\n        \"rootProperties\": {\n          \"rootType\": \"Host\",\n          \"rootId\": \"Host:::151e41d1-5395-4940-98ec-17460eae8949\",\n          \"rootName\": \"10.0.46.37\"\n        }\n      }\n    ],\n    \"unprotectableReasons\": [],\n    \"numMissedSnapshot\": 0,\n    \"lastSnapshotTime\": \"2020-09-07T13:36:33.000Z\",\n    \"includeBackupTaskInfo\": false,\n    \"isOnline\": true,\n    \"blackoutWindowStatus\": {\n      \"isGlobalBlackoutActive\": false,\n      \"isSnappableBlackoutActive\": true\n    },\n    \"blackoutWindows\": {\n      \"globalBlackoutWindows\": [],\n      \"snappableBlackoutWindows\": [\n        {\n          \"startTime\": \"2020-09-13T11:02:04+0000\"\n        }\n      ]\n    },\n    \"snapshotCount\": 2,\n    \"isLocal\": true,\n    \"isStandby\": false,\n    \"latestRecoveryPoint\": \"2020-09-07T14:11:54.000Z\",\n    \"oldestRecoveryPoint\": \"2020-09-07T12:47:38.000Z\",\n    \"protectionDate\": \"2020-08-26T07:43:26.429Z\",\n    \"recoveryForkGuid\": \"83145A93-8921-4318-8508-B9ABE1D3B0F6\",\n    \"maxDataStreams\": 8,\n    \"localStorage\": 1363475,\n    \"archiveStorage\": 0\n  }\n]\n```\n\n## Availability Groups\n\nTo get the details of a SQL Server Availability Group, GET on\n[`/mssql/availability_group/{id}`](#operation/getMssqlAvailabilityGroupV1).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/availability_group/$availability_group_id\"\n```\n\n```bash\n{\n  \"id\": \"$availability_group_id\",\n  \"name\": \"$availability_group_name\",\n  \"configuredSlaDomainId\": \"$sla_id\",\n  \"configuredSlaDomainName\": \"$sla_name\",\n  \"configuredSlaDomainType\": \"$sla_type\",\n  \"primaryClusterId\": \"$primary_cluster_id\",\n  \"isConfiguredSlaDomainRetentionLocked\": $is_sla_retention_locked,\n  \"effectiveSlaDomainId\": \"$sla_id\",\n  \"effectiveSlaDomainName\": \"$sla_name\",\n  \"isEffectiveSlaDomainRetentionLocked\": $is_sla_retention_locked,\n  \"slaAssignment\": \"$sla_assignment\",\n  \"logBackupFrequencyInSeconds\": $log_backup_frequenct,\n  \"logRetentionHours\": $log_backup_retention,\n  \"copyOnly\": $copy_only\n}\n```\n\nTo get a summary of all SQL Server Availability Groups, GET on\n[`/mssql/availability_group`](#operation/queryMssqlAvailabilityGroupV1).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/availability_group\"\n```\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"id\": \"$availability_group_id\",\n      \"name\": \"$availability_group_name\",\n      \"configuredSlaDomainId\": \"$sla_id\",\n      \"configuredSlaDomainName\": \"$sla_name\",\n      \"configuredSlaDomainType\": \"$sla_type\",\n      \"primaryClusterId\": \"$primary_cluster_id\",\n      \"isConfiguredSlaDomainRetentionLocked\": $is_sla_retention_locked,\n      \"effectiveSlaDomainId\": \"$sla_id\",\n      \"effectiveSlaDomainName\": \"$sla_name\",\n      \"isEffectiveSlaDomainRetentionLocked\": $is_sla_retention_locked,\n      \"slaAssignment\": \"$sla_assignment\",\n      \"logBackupFrequencyInSeconds\": $log_backup_frequenct,\n      \"logRetentionHours\": $log_backup_retention,\n      \"copyOnly\": $copy_only\n    }\n  ],\n  \"total\": 1\n}\n```\n\nTo update a SQL Server Availability Group, PATCH on\n[`/mssql/availability_group/{id}`](#operation/updateMssqlAvailabilityGroupV1).\n\n```bash\ncurl -X PATCH \"https://$cluster_address/api/v1/mssql/availability_group/$availability_group_id\" -d\\\n '{\n    \"logBackupFrequencyInSeconds\": $log_backup_freq,\n    \"logRetentionHours\": $log_backup_retention,\n    \"copyOnly\": $copy_only,\n    \"configuredSlaDomainId\\\": \"$sla_id\"\n  }'\n```\n\n```bash\n{\n  \"id\": \"$availability_group_id\",\n  \"name\": \"$availability_group_name\",\n  \"configuredSlaDomainId\": \"$sla_id\",\n  \"configuredSlaDomainName\": \"$sla_name\",\n  \"configuredSlaDomainType\": \"$sla_type\",\n  \"primaryClusterId\": \"$primary_cluster_id\",\n  \"isConfiguredSlaDomainRetentionLocked\": $is_sla_retention_locked,\n  \"effectiveSlaDomainId\": \"$sla_id\",\n  \"effectiveSlaDomainName\": \"$sla_name\",\n  \"isEffectiveSlaDomainRetentionLocked\": $is_sla_retention_locked,\n  \"slaAssignment\": \"$sla_assignment\",\n  \"logBackupFrequencyInSeconds\": $log_backup_frequenct,\n  \"logRetentionHours\": $log_backup_retention,\n  \"copyOnly\": $copy_only\n}\n```\n\n## Protection\n\nTo create an on-demand snapshot, POST on [`/mssql/db/{id}/snapshot`](#operation/createOnDemandMssqlBackup).\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/snapshot\"\n```\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/db/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"QUEUED\"\n}\n```\n\nOnce the snapshot has been taken, the `$snapshot_id` can be retrieved from the request with [`/mssql/request/{id}`](#operation/getMssqlAsyncRequestStatus).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/mssql/request/$request_id\"\n```\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/db/snapshot/$snapshot_id\",\n      \"rel\": \"result\"\n    },\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"SUCCEEDED\"\n}\n```\n\nThe `$snapshot_id` can be used to extract further information on the snapshot with a GET on [`/mssql/db/snapshot/{id}`](#operation/getMssqlDbSnapshot).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/mssql/db/snapshot/$snapshot_id\"\n```\n\n```bash\n{\n  \"id\": \"$snapshot_id\",\n  \"date\": \"2017-02-02T18:53:12.718Z\",\n  \"isOnDemandSnapshot\": true\n}\n```\n\nTo create an on-demand log backup, POST on [`/mssql/db/{id}/log_backup`](#operation/createOnDemandMssqlLogBackup).\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/log_backup\"\n```\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/db/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"QUEUED\"\n}\n```\n\nTo protect a specific database under an SLA, perform a PATCH on [`/mssql/db/{id}`](#operation/updateMssqlDb)\n\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"configuredSlaDomainId\": \"$sla_domain_id\" }' \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id\"\n```\n\n```bash\n{\n  \"id\": \"$db_id\",\n  \"name\": \"$db_name\",\n  \"configuredSlaDomainId\": \"$sla_domain_id\",\n  \"configuredSlaDomainName\": \"$sla_domain_name\",\n  \"effectiveSlaDomainId\": \"$sla_domain_id\",\n  \"effectiveSlaDomainName\": \"sla_domain_name\",\n  \"instanceId\": \"$instance_id\"\n  \"instanceName\": \"$instance_name\"\n}\n```\n\nList all snapshots for a database with a GET on [`/mssql/db/{id}/snapshot`](#operation/queryMssqlDbSnapshot).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/snapshot\"\n```\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"$snapshot_id\",\n      \"date\": \"2017-02-02T18:53:12.718Z\",\n      \"isOnDemandSnapshot\": true\n    }\n  ],\n  \"total\": 1\n}\n```\n\nPoint-in-time recovery is supported when log backups are taken. The range of recoverable times can be listed with a GET on [`/mssql/db/{id}/recoverable_range`](#operation/getMssqlDbRecoverableRanges).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/recoverable_range\"\n```\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"beginTime\": \"2017-02-02T18:53:12.694Z\",\n      \"endTime\": \"2017-02-02T20:53:12.694Z\"\n    }\n  ],\n  \"total\": 1\n}\n```\n\n## Download\nThe Rubrik REST API server provides endpoints to browse and\ndownload snapshots and logs for a specific SQL Server database.\n\n### Browsing SQL Server snapshots\nTo view a list of snapshots and log backups of a specific SQL Server\ndatabase, send a POST request to the \n[`/mssql/db/{id}/browse`](#operation/browseMssqlBackupFiles)\nendpoint where, `{id}` is the ID of the SQL Server database.\n\nThis POST call fetches metadata based on a timestamp or the\nlog sequence number (LSN) provided in the request payload.\n\nTo fetch a list of snapshots and log backups that are required to\nrecover to a point in time, specify the point in time using either the\n`date` or the `lsnpoint` attribute of the `recoveryPoint` attribute.\nBoth `date` and `lsnPoint` cannot be used at the same time.\n\n```bash\ncurl -X POST -d \\\n  '{ \n        \"recoveryPoint\": {\"date\": \"2019-08-15T10:40\"}\n   }' \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/browse\n```\n\nTo fetch a list of snapshots and log backups that fit within a range,\nspecify the range by using a combination of the `startPoint` and\n`endPoint` attributes.\nWithin the `startPoint` and `endPoint` attributes, specify values for\neither the `lsnPoint` or the `date` attributes, not for both.\n\n```bash\ncurl -X POST -d \\\n  '{ \n        \"startPoint\": {\"date\": \"2019-08-15T10:40\"}, \n        \"endPoint\": {\"date\": \"2019-08-15T10:45:47\"} \n   }' \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/browse\n```\n\nTo recover to a point in time, use the `recoveryPoint` attribute; do\nnot define a range using the `startPoint` and `endPoint` attributes.\n\nTo fetch a list of snapshots and log backups that fit within a range,\nspecify the beginning of a range using the `startPoint` attribute and\nspecify the end of the range using the `endPoint` attribute.\nWhen specifying a range, do not specify a `recoveryPoint`.\n\nThe Rubrik REST API server responds with the list of the log and\ndatabase snapshots that fit within the parameters specified in the\nrequest.\n\n```bash\n{\n  \"items\": [\n    {\n      \"backupId\": \"e8f0c6ee-fafc-4740-b9c9-deadba9815df\",\n      \"backupType\": \"Log\",\n      \"path\": \"testdb/logs/2019-08-15T10-40-58Z.trn\",\n      \"date\": \"2019-08-15T10:40:58.000Z\",\n      \"lsn\": \"45000000219000001\",\n      \"recoveryForkGuid\": \"03F633D8-6B5A-48F5-97F0-401440F124FD\",\n      \"backupSize\": 86528\n    },\n    {\n      \"backupId\": \"5e3de1ce-f5ab-4787-a057-accec64fe7af\",\n      \"backupType\": \"Snapshot\",\n      \"path\": \"testdb/snapshot-2019-08-15T10-45-31Z/\",\n      \"date\": \"2019-08-15T10:45:47.000Z\",\n      \"lsn\": \"45000000221300001\",\n      \"recoveryForkGuid\": \"03F633D8-6B5A-48F5-97F0-401440F124FD\",\n      \"backupSize\": 16777216\n    },\n    {\n      \"backupId\": \"c57d1908-c085-43ef-9a7f-fcb482994bf7\",\n      \"backupType\": \"Log\",\n      \"path\": \"testdb/logs/2019-08-15T10-46-03Z.trn\",\n      \"date\": \"2019-08-15T10:46:03.000Z\",\n      \"lsn\": \"45000000222300001\",\n      \"recoveryForkGuid\": \"03F633D8-6B5A-48F5-97F0-401440F124FD\",\n      \"backupSize\": 86528\n    }\n  ]\n}\n\n```\n\n### Downloading all SQL Server snapshots and logs\nTo initiate a request to build a zip file containing the\nsnapshots and log backups that are required to recover to a specific\npoint in time, or a range of time, send a POST request to the\n[`/mssql/db/{id}/download_files`](#operation/createDownloadMssqlBackupFiles) endpoint.\n\nThe usage of parameters for this POST call is identical to the usage\ndescribed for the [browse API call](#browsing-sql-server-snapshots).\n\n```bash\ncurl -X POST -d \\\n  '{ \"startPoint\": {\"date\": \"2019-08-15T10:40\"}, \"endPoint\": {\"date\": \"2019-08-15T10:45:47\"} }' \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/download_files\n```\n\nThe Rubrik REST API server responds with the details of the\nasynchronous task that is initiated by the POST API call.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"status\": \"$request_status\",\n  \"progress\": 0,\n  \"startTime\": \"2021-03-23T20:38:05.511Z\",\n  \"endTime\": \"2021-03-23T20:38:05.511Z\",\n  \"nodeId\": \"$node_id\",\n  \"error\": {\n    \"message\": \"$error_message\"\n  },\n  \"links\": [\n    {\n      \"href\": \"string\",\n      \"rel\": \"string\"\n    }\n  ]\n}\n```\n\nTo check the status of the download request, send a GET request to the\n(`/mssql/request/{id}`)[#operation/getMssqlAsyncRequestStatus]\nendpoint where, `{id}` is the `$request_id`.\n\nThe Rubrik REST API server responds with the link to\ndownload the zip file when the zip file is ready for download.\n\n### Downloading specific SQL Server snapshots and logs\nTo initiate a request to build a zip file containing\nspecific snapshots and log backups, send a POST\nrequest to the [`/mssql/db/{id}/download_files_by_id`](#operation/createDownloadMssqlBackupFilesById) endpoint with\nthe object IDs for the snapshots and logs to be downloaded.\n\n```bash\ncurl -X POST -d \\\n  '{ \"items\": [\"e8f0c6ee-fafc-4740-b9c9-deadba9815df\", \"c57d1908-c085-43ef-9a7f-fcb482994bf7\"] }' \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/download_files_by_id\"\n```\n\nThe Rubrik REST API server responds with the details of the\nasynchronous task that is initiated by the POST API call.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"status\": \"$request_status\",\n  \"progress\": 0,\n  \"startTime\": \"2021-03-23T20:38:05.511Z\",\n  \"endTime\": \"2021-03-23T20:38:05.511Z\",\n  \"nodeId\": \"$node_id\",\n  \"error\": {\n    \"message\": \"$error_message\"\n  },\n  \"links\": [\n    {\n      \"href\": \"string\",\n      \"rel\": \"string\"\n    }\n  ]\n}\n```\nTo check the status of the download request, send a GET request to the\n(`/mssql/request/{id}`)[#operation/getMssqlAsyncRequestStatus]\nendpoint where, `{id}` is the `$request_id`.\n\nThe Rubrik REST API server responds with the link to\ndownload the zip file when the zip file is ready for download.\n\nThe zip file uses the naming convention of `$database_name`-\n`$random_string`.zip.\n\nThe path to the log backup files inside the zip file is of the form\n`$database_name`/logs/`$database_name`-`$timestamp`.trn.\nFor example, if the `$database_name` is `BigDatabase`, the log\nbackup file is located at `BigDatabase/logs/BigDatabase-2021-03-23T03-15-55Z.trn` inside the downloaded zip\nfile.\n\nThe path to the database snapshot files inside the zip file is of the form\n`$database_name`/snapshot-`$timestamp`/`$snapshot_files`. For\nexample, if the `$database_name` is\n`BigDatabase` and a snapshot filename is `snapshot.mdf`, then the \nlocation of the file inside the downloaded zip file is\n`BigDatabase/snapshot-2021-03-23T03-15-55Z/snapshot.mdf`.\n\n\nMake an asynchronous POST request to the [`/mssql/db/{id}/download`](#operation/downloadFromArchive) endpoint to download snapshots and logs from archival for a given database and recovery point.\n\n```bash\ncurl -X POST -d \\\n  '{ \"recoveryPoint\": { \"timestampMs\": 12345 } }' \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/download\"\n```\n\nA 'missed snapshot' occurs when a snapshot that is required by SLA Domain policy cannot be created.\nTo retrieve information about missed snapshots, send a GET request to the [`/mssql/db/{id}/missed_snapshot`](#operation/getMissedMssqlDbSnapshots) endpoint.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/missed_snapshot\"\n```\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"missedSnapshotTime\": \"2000-01-02T11:08:40.420Z\"\n    }\n  ],\n  \"total\": 1\n}\n```\n\nTo retrieve the recoverable time ranges that were missed for a specified database, send a GET request to the [`/mssql/db/{id}/missed_recoverable_range`](#operation/getMssqlDbMissedRecoverableRanges) endpoint.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/missed_recoverable_range\"\n```\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"beginTime\": \"2017-02-02T18:53:12.694Z\",\n      \"endTime\": \"2017-02-02T20:53:12.694Z\"\n    }\n  ],\n  \"total\": 1\n}\n```\n\nDelete all snapshots for a specific database with a DELETE on [`/mssql/db/{id}/snapshot`](#operation/deleteMssqlDbSnapshots).\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/mssql/db/$db_id/snapshot\"\n```\n\nAssign SLA properties to multiple objects with a POST to\n[`mssql/sla_domain/assign`](#operation/assignMssqlSlaProperties).\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"ids\": [\"$id1\", \"$id2\"],\n    \"copyOnly\": true,\n    \"configuredSlaDomainId\": \"$slaDomainId\"\n  }' \\\n  \"https://$cluster_address/api/v1/mssql/sla_domain/assign\"\n```\n\nTo take on demand snapshot of multiple SQL Server databases, perform POST on\n [`/mssql/db/bulk/snapshot`](#operation/createOnDemandMssqlBatchBackupV1).\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/mssql/db/bulk/snapshot\" -d\\\n'{\n   \"slaId\": \"$sla_id\",\n   \"databaseIds\": [\n     \"$db_id_1\",\n     \"$db_id_2\"\n   ],\n   \"instanceIds\": [\n     \"$instance_id_3\"\n   ],\n   \"hostIds\": [\n     \"$host_id_4\",\n     \"$host_id_5\",\n     \"$host_id_6\",\n   ],\n   \"windowsClusterIds\": [\n     \"$windows_cluster_id_7\"\n   ],\n   \"availabilityGroupIds\": [\n     \"$availability_group_id_8\"\n   ],\n   \"forceFullSnapshot\": true\n }'\n```\n```bash\n{\n  \"id\": \"$mssql_multi_host_batch_backup_job_id\",\n  \"status\": \"$job_status\",\n  \"progress\": $job_progress,\n  \"startTime\": \"$job_start_time\",\n  \"links\": [\n    {\n      \"href\": \"$link1\",\n      \"rel\": \"self\"\n    }\n  ]\n\n```\n\nGet the details of on demand backup job of SQL Server databases by performing\n GET on\n [`/mssql/db/bulk/snapshot/{id}`](#operation/getOnDemandMssqlBatchBackupResultV1).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/db/bulk/snapshot/$mssql_multi_host_batch_backup_job_id\"\n```\n\n```bash\n{\n  \"id\": \"$mssql_multi_host_batch_backup_job_id\",\n  \"successfulSnapshots\": [\n    {\n      \"databaseId\": \"$db_id\",\n      \"snapshotId\": \"$snapshot_id\"\n    }\n  ],\n  \"failedSnapshots\": [\n    {\n      \"databaseId\": \"$db_id_2\",\n      \"error\": \"$error\"\n    }\n  ],\n  \"canceledSnapshots\": []\n}\n```\n\n\nTo delete all the downloaded snapshots and logs for a SQL Server database,\n perform DELETE on\n [`mssql/db/{id}/recoverable_range/download`](#operation/deleteDownloadedMssqlDbRecoverableRangesV1).\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/mssql/db/$db_id/recoverable_range_download\"\n```\n```bash\n{\n  \"jobInstanceId\": \"$expire_mssql_download_ranges_job_id\"\n}\n```\n\nTo get the deletion status of downloaded recoverable range, perform GET on\n [`/mssql/db/recoverable_range/download/{id}`](#operation/getDeleteMssqlDbRecoverableRangesStatusV1).\n\n```bash\ncurl -X GET \\\n\"https://$cluster_address/api/v1/mssql/db/recoverable_range/download/$expire_mssql_download_ranges_job_id\"\n```\n\n```bash\n{\n  \"id\": \"$expire_mssql_download_ranges_job_id\"\n  \"status\": \"SUCCEEDED\",\n  \"startTime\": \"$job_start_time\",\n  \"endTime\": \"$job_end_time\",\n  \"jobType\": \"EXPIRE_MSSQL_DOWNLOADED_RANGES\",\n  \"nodeId\": \"$node_id\",\n  \"isDisabled\": $is_disabled,\n  \"archived\": $archived\n}\n```\n\nTo get the default SQL Server database backup properties, perform GET on\n [`/mssql/db/defaults`](#operation/getDefaultDbPropertiesV1).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/db/defaults\"\n```\n\n```bash\n{\n  \"logBackupFrequencyInSeconds\": $log_backup_frequency,\n  \"cbtStatus\": $cbt_status,\n  \"logRetentionTimeInHours\": $log_retention_time\n}\n```\n\nTo update the default SQL Server database backup properties, perform PATCH on\n [`/mssql/db/defaults`](#operation/updateDefaultDbPropertiesV1).\n\n```bash\ncurl -X PATCH \"https://$cluster_address/api/v1/mssql/db/defaults\" -d\\\n '{\n    \"logBackupFrequencyInSeconds\": 900,\n    \"cbtStatus\": true,\n    \"logRetentionTimeInHours\": 168\n  }'\n```\n\n```bash\n{\n  \"logBackupFrequencyInSeconds\": 900,\n  \"cbtStatus\": true,\n  \"logRetentionTimeInHours\": 168\n}\n```\n\n## Restore\n\nPerform a restore with a POST on [`/mssql/db/{id}/restore`](#operation/createRestoreMssqlDb) specifying the timestamp as the recovery point.\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"recoveryPoint\": {\n      \"timestampMs\": 12345\n    }\n  }' \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/restore\"\n```\n\nA database can also be exported to another instance with a POST on [`/mssql/db/{id}/export`](#operation/createExportMssqlDb).\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"recoveryPoint\": {\n      \"timestampMs\": 12345\n    },\n    \"targetInstanceId\": \"$instance_id\",\n    \"targetDatabaseName\": \"$db_name\"\n  }' \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/export\"\n```\n\nList of all the database files which are needed to restore a SQL Server\n database can be found by GET on\n [/mssql/db/{id}/restore_files](#operation/mssqlGetRestoreFilesV1).\n\n  ```bash\n  curl -X GET \"https://$cluster_address/api/v1mssql/db/$db_id/restore_files?time=$time_to_restore\"\n  ```\n\n  ```bash\n  [\n    {\n      \"logicalName\": \"$logical_file_name\",\n      \"originalPath\": \"$original_file_path\",\n      \"originalName\": \"$original_file_name\",\n      \"fileType\": \"Data\",\n      \"fileId\": $file_id\n    },\n    {\n      \"logicalName\": \"$logical_file_name\",\n      \"originalPath\": \"$original_file_path\",\n      \"originalName\": \"$original_file_name\",\n      \"fileType\": \"Log\",\n      \"fileId\": $file_id\n    }\n  ]\n  ```\n\nAn estimate of resources needed for restoring a SQL Server database can be\n found by GET on\n [/mssql/db/{id}/restore_estimate](#operation/mssqlRestoreEstimateV1).\n\n  ```bash\n  curl -X GET \"https://$cluster_address/api/v1/mssql/db/$db_id/restore_estimate?time=$time_to_restore\"\n  ```\n\n  ```bash\n  {\n    \"bytesFromCloud\": $bytes_from_cloud\n  }\n  ```\n\nGet compatible instances for recovery of a SQL Server database by performing\n GET on\n [/mssql/db/{id}/compatible_instance](#operation/getCompatibleMssqlInstancesV1).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/db/$db_id/compatible_instance?recovery_type=$recovery_type\"\n```\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"logBackupFrequencyInSeconds\": $log_backup_frequency,\n      \"logRetentionHours\": $log_backup_retention,\n      \"copyOnly\": $copy_only,\n      \"id\": \"$instance_id\",\n      \"internalTimestamp\": $internal_timestamp,\n      \"name\": \"$instance_name\",\n      \"primaryClusterId\": \"$cluster_id\",\n      \"rootProperties\": {\n        \"rootType\": \"$root_type\",\n        \"rootId\": \"$root_id\",\n        \"rootName\": \"$root_name\"\n      },\n      \"version\": \"$version\",\n      \"configuredSlaDomainId\": \"$sla_domain_id\",\n      \"configuredSlaDomainType\": \"$sla_type\",\n      \"configuredSlaDomainName\": \"$sla_name\",\n      \"isRetentionLocked\": $is_retention_locked,\n      \"unprotectableReasons\": []\n    }\n  ],\n  \"total\": 1\n}\n```\n\n## Live Mount\n\nPerform a Live Mount with a POST on [`/mssql/db/{id}/mount`](#operation/createMssqlMount), specifying the timestamp as the recovery point.\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"recoveryPoint\": {\n      \"timestampMs\": 12345\n    },\n    \"mountedDatabaseName\": \"$db_name\"\n  }' \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/mount\"\n```\n\nAll current Live Mounts can be found with a GET on [`/mssql/db/mount`](#operation/queryMssqlMount).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/db/mount\"\n```\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"$mount_id\",\n      \"sourceDatabaseId\": \"$source_db_id\",\n      \"sourceRecoveryPoint\": {\n        \"timestampMs\": 12345\n      },\n      \"targetInstanceId\": \"$target_instance_id\",\n      \"creationDate\": \"2017-02-02T18:53:12.694Z\",\n      \"isReady\": true,\n      \"mountedDatabaseId\": \"$mounted_db_id\"\n    }\n  ],\n  \"total\": 1\n}\n```\n\nFurther details for a single Live Mount are acquired from [`/mssql/db/mount/{id}`](#operation/getMssqlMount).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/db/mount/$mount_id\"\n```\n\n```bash\n{\n  \"id\": \"$mount_id\",\n  \"sourceDatabaseId\": \"$source_db_id\",\n  \"sourceRecoveryPoint\": {\n    \"timestampMs\": 12345\n  },\n  \"targetInstanceId\": \"$target_instance_id\",\n  \"creationDate\": \"2017-02-02T18:53:12.694Z\",\n  \"isReady\": true,\n  \"mountedDatabaseId\": \"$mounted_db_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/db/$source_db_id\",\n      \"rel\": \"sourceDatabase\"\n    },\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/instance/$target_instance_id\",\n      \"rel\": \"targetInstance\"\n    },\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/db/$mounted_db_id\",\n      \"rel\": \"mountedDatabase\"\n    }\n  ],\n}\n```\n\nDelete a Live Mount with a DELETE on [`/mssql/db/mount/{id}`](#operation/createMssqlUnmount).\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/mssql/db/mount/$mount_id\"\n```\n\n## Log Shipping\n\nCreate a Log Shipping Configuration with a POST on [`/mssql/db/{id}/log_shipping`](#operation/createLogShippingConfiguration).\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"config\": {\n      \"targetInstanceId\": \"$target_instance_id\",\n      \"targetDatabaseName\": \"$db_name\",\n      \"state\": \"$state\"\n    }\n  }' \\\n  \"https://$cluster_address/api/v1/mssql/db/{id}/log_shipping\"\n```\n\nAll current Log Shipping Configurations can be found with a GET on [`/mssql/db/log_shipping`](#operation/queryLogShippingConfigurations).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/db/log_shipping\"\n```\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"$log_shipping_id\",\n      \"lastAppliedPoint\": \"2017-02-02T18:53:12.694Z\",\n      \"location\": \"$host_name/$instance_name\",\n      \"primaryDatabaseId\": \"$primary_db_id\",\n      \"primaryDatabaseName\": \"$primary_database_name\",\n      \"secondaryDatabaseName\": \"$secondary_database_name\",\n      \"secondaryDatabaseId\": \"$secondary_database_id\",\n      \"state\": \"$state\",\n      \"status\": \"OK\"\n    }\n  ],\n  \"total\": 1\n}\n```\n\nFurther details for a single Log Shipping configuration are acquired from [`/mssql/db/log_shipping/{id}`](#operation/getLogShippingConfiguration).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/db/log_shipping/{id}\"\n```\n\n```bash\n{\n  \"id\": \"$log_shipping_id\",\n  \"lastAppliedPoint\": \"2017-02-02T18:53:12.694Z\",\n  \"location\": \"$host_name/$instance_name\",\n  \"primaryDatabaseId\": \"$primary_db_id\",\n  \"primaryDatabaseName\": \"$primary_database_name\",\n  \"secondaryDatabaseName\": \"$secondary_database_name\",\n  \"secondaryDatabaseId\": \"$secondary_database_id\",\n  \"state\": \"$state\",\n  \"status\": \"OK\"\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/db/$primary_db_id\",\n      \"rel\": \"primaryDatabase\"\n    },\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/instance/$secondary_instance_id\",\n      \"rel\": \"secondaryInstance\"\n    },\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/db/$secondary_db_id\",\n      \"rel\": \"secondaryDatabase\"\n    }\n  ],\n}\n```\n\nUpdate a Log Shipping Configuration with a PATCH on [`/mssql/db/log_shipping/{id}`](#operation/updateLogShippingConfiguration).\n\n```bash\ncurl -X PATCH -d \\\n  '{\n    \"config\": {\n      \"state\": \"$state\"\n    }\n  }' \\\n  \"https://$cluster_address/api/v1/mssql/db/log_shipping/$id\"\n```\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/db/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"QUEUED\"\n}\n```\n\nDelete a Log Shipping Configuration with a DELETE on [`/mssql/db/log_shipping/{id}`](#operation/deleteLogShippingConfiguration).\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/mssql/db/log_shipping/$id?delete_secondary_database=true\"\n```\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/db/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"QUEUED\"\n}\n```\n\nReseed a Log Shipping Configuration with a POST on [`/mssql/db/log_shipping/{id}/reseed`](#operation/reseedSecondary)\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"config\": {\n      \"state\": \"$state\"\n    }\n  }' \\\n  \"https://$cluster_address/api/v1/mssql/db/log_shipping/$id/reseed\"\n```\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/db/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"QUEUED\"\n}\n```\n\n# Hierarchy\n\nThis REST API is used to get SQL Server hierarchy objects.\n\n### Get list of immediate descendant objects\nGet a list of immediate descendant objects using a GET request to\n[/mssql/hierarchy/{id}/children]\\\n(#operation/getMssqlHierarchyChildren).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/hierarchy/{id}/children\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"$database_id\",\n      \"name\": \"$database_name\",\n      \"objectType\": \"MssqlDatabase\",\n      \"descendantCount\": {},\n      \"hasPermissions\": true,\n      \"isInAvailabilityGroup\": false,\n      \"isLiveMount\": false,\n      \"isLogShippingSecondary\": false,\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"configuredSlaDomainName\": \"Inherit\",\n      \"effectiveSlaDomainId\": \"INHERIT\",\n      \"effectiveSlaDomainName\": \"Inherit\"\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\n### Get list of descendant objects\nGet a list of descendant objects using\na GET request to\n[/mssql/hierarchy/{id}/descendants]\\\n(#operation/getMssqlHierarchyDescendants).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/hierarchy/{id}/descendants\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"$database_id\",\n      \"name\": \"$database_name\",\n      \"objectType\": \"MssqlDatabase\",\n      \"descendantCount\": {},\n      \"hasPermissions\": true,\n      \"isInAvailabilityGroup\": false,\n      \"isLiveMount\": false,\n      \"isLogShippingSecondary\": false,\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"configuredSlaDomainName\": \"Inherit\",\n      \"effectiveSlaDomainId\": \"INHERIT\",\n      \"effectiveSlaDomainName\": \"Inherit\"\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\n### Get an object\nGet an object in the hierarchy using a GET request to\n[/mssql/hierarchy/{id}]\\\n(#operation/getMssqlHierarchyObject).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/hierarchy/{id}\"\n```\n\n```bash\n{\n  \"id\": \"$database_id\",\n  \"name\": \"$database_name\",\n  \"objectType\": \"MssqlDatabase\",\n  \"descendantCount\": {},\n  \"hasPermissions\": true,\n  \"isInAvailabilityGroup\": false,\n  \"isLiveMount\": false,\n  \"isLogShippingSecondary\": false,\n  \"configuredSlaDomainId\": \"INHERIT\",\n  \"configuredSlaDomainName\": \"Inherit\",\n  \"effectiveSlaDomainId\": \"INHERIT\",\n  \"effectiveSlaDomainName\": \"Inherit\"\n}\n```\n## Host configurations\n\n### Retrieving SQL Server host configurations\nTo retrieve all the SQL Server host configurations, send a GET request to\n [`/mssql/host/configuration`](#operation/queryMssqlHostConfig).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1//mssql/host/configuration\"\n```\n\nThe Rubrik REST API server responds with a list of all the SQL Server host \nconfigurations.\n```bash\n{\n  \"data\": [\n    {\n      \"hostId\": \"hostId\",\n      \"enableDatabaseBatchSnapshots\": \"Enabled\",\n      \"enableVdi\": \"Enabled\",\n      \"enableVdiDb\": \"Enabled\",\n      \"enableGroupFetch\": \"Enabled\",\n      \"enableCbtBackup\": \"Enabled\",\n      \"physicalHostLogBackupThrottleMaxRefCount\": 10,\n      \"throttlePhysicalHostMaxRefCount\": 3,\n      \"fileTransferParallelism\": 8,\n      \"mssqlDefaultMaxDataStreamsPerDatabase\": 2,\n      \"fileRestoreReadParallelism\": 16,\n      \"fileRestoreWriteParallelism\": 4\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\nTo retrieve the configuration of a specific SQL Server host, send a GET \nrequest to\n [`/mssql/host/configuration/{host_id}`](#operation/getMssqlHostConfig).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1//mssql/host/configuration/{host_id}\"\n```\n\nThe Rubrik REST API server responds with the configuration details of the \nspecified SQL Server host.\n\n```bash\n{\n  \"enableDatabaseBatchSnapshots\": \"Enabled\",\n  \"enableVdi\": \"Enabled\",\n  \"enableVdiDb\": \"Enabled\",\n  \"enableGroupFetch\": \"Enabled\",\n  \"enableCbtBackup\": \"Enabled\",\n  \"physicalHostLogBackupThrottleMaxRefCount\": 10,\n  \"throttlePhysicalHostMaxRefCount\": 3,\n  \"fileTransferParallelism\": 8,\n  \"mssqlDefaultMaxDataStreamsPerDatabase\": 2,\n  \"fileRestoreReadParallelism\": 16,\n  \"fileRestoreWriteParallelism\": 4\n}\n```\n\n\n### Creating a SQL Server host configuration\nTo create a new SQL Server host configuration, send a POST request to\n [`/mssql/host/configuration`](#operation/createMssqlHostConfig).\n\n```bash\ncurl -X POST -d \\\n '{\n   \"hostId\": \"hostId\",\n   \"enableDatabaseBatchSnapshots\": \"Enabled\",\n   \"enableVdi\": \"Enabled\",\n   \"enableVdiDb\": \"Enabled\",\n   \"enableGroupFetch\": \"Enabled\",\n   \"enableCbtBackup\": \"Enabled\",\n   \"physicalHostLogBackupThrottleMaxRefCount\": 10,\n   \"throttlePhysicalHostMaxRefCount\": 3,\n   \"fileTransferParallelism\": 8,\n   \"mssqlDefaultMaxDataStreamsPerDatabase\": 2,\n   \"fileRestoreReadParallelism\": 16,\n   \"fileRestoreWriteParallelism\": 4\n }' \\\n\"https://$cluster_address/api/v1/mssql/host/configuration\"\n```\n\nThe Rubrik REST API server responds with the details of the new SQL Server \nhost configuration.\n```bash\n{\n  \"hostId\": \"hostId\",\n  \"enableDatabaseBatchSnapshots\": \"Enabled\",\n  \"enableVdi\": \"Enabled\",\n  \"enableVdiDb\": \"Enabled\",\n  \"enableGroupFetch\": \"Enabled\",\n  \"enableCbtBackup\": \"Enabled\",\n  \"physicalHostLogBackupThrottleMaxRefCount\": 10,\n  \"throttlePhysicalHostMaxRefCount\": 3,\n  \"fileTransferParallelism\": 8,\n  \"mssqlDefaultMaxDataStreamsPerDatabase\": 2,\n  \"fileRestoreReadParallelism\": 16,\n  \"fileRestoreWriteParallelism\": 4\n}\n```\n\n### Updating a SQL Server host configuration\nTo update the configuration of a specific SQL Server host, send a PATCH \nrequest to\n [`/mssql/host/configuration/{host_id}`](#operation/updateMssqlHostConfig).\n\n```bash\ncurl -X PATCH -d \\\n '{\n   \"enableDatabaseBatchSnapshots\": true,\n   \"enableVdi\": true,\n   \"enableVdiDb\": false,\n   \"enableGroupFetch\": false,\n   \"enableCbtBackup\": false,\n   \"physicalHostLogBackupThrottleMaxRefCount\": 10,\n   \"throttlePhysicalHostMaxRefCount\": 3,\n   \"fileTransferParallelism\": 8,\n   \"mssqlDefaultMaxDataStreamsPerDatabase\": 2,\n   \"fileRestoreReadParallelism\": 16,\n   \"fileRestoreWriteParallelism\": 4\n }' \\\n\"https://$cluster_address/api/v1//mssql/host/configuration/{host_id}\"\n```\n\nThe Rubrik REST API server responds with the updated configuration details of \nthe specified SQL Server host.\n\n```bash\n{\n  \"enableDatabaseBatchSnapshots\": \"Enabled\",\n  \"enableVdi\": \"Enabled\",\n  \"enableVdiDb\": \"Enabled\",\n  \"enableGroupFetch\": \"Enabled\",\n  \"enableCbtBackup\": \"Enabled\",\n  \"physicalHostLogBackupThrottleMaxRefCount\": 10,\n  \"throttlePhysicalHostMaxRefCount\": 3,\n  \"fileTransferParallelism\": 8,\n  \"mssqlDefaultMaxDataStreamsPerDatabase\": 2,\n  \"fileRestoreReadParallelism\": 16,\n  \"fileRestoreWriteParallelism\": 4\n}\n```\n\n### Deleting a SQL Server host configuration\nTo delete a specific SQL Server host configuration, send a DELETE request to\n [`/mssql/host/configuration/{host_id}`](#operation/deleteMssqlHostConfig).\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/mssql/host/configuration/{host_id}\"\n```\n\nThe Rubrik REST API server deletes the specified SQL Server host configuration.\n\n# Oracle Databases\n\n## Delete Downloaded Oracle Db Snapshots and Log Snapshots\n\nTo request an asynchronous job to expire downloaded database snapshots taken during a specified time period as well as log snapshots that contain any logs with timestamps within that time period, send a DELETE request to the [`/oracle/db/{id}/downloaded_snapshots`](#operation/deleteDownloadedSnapshots) endpoint with optional query parameters before_time and after_time.\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/oracle/db/{id}/downloaded_snapshots?before_time=2016-01-01T01:23:45.678&after_time=2016-01-01T01:23:45.678\"\n  ```\nAn async request is returned and can be polled to retrieve the job status.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/internal/oracle/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"QUEUED\"\n}\n```\n\n## Provide Estimate for Restore Operation Download\n\nTo request the number of bytes that must be downloaded for a restore operation for an Oracle database, send a GET request to the [`/oracle/db/{id}/restore_estimate`](#operation/oracleRestoreEstimate) endpoint with the snapshot ID or the time to be restored to.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/oracle/db/{id}/restore_estimate?recovery_time=2016-01-01T01:23:45.678\"\n```\nAn OracleRestoreEstimateResult object is returned which stores the number of bytes which are needed to restore.\n\n```bash\n{\n  \"bytesToRestore\": \"$bytesToRestore\",\n}\n```\n\n## Bulk Update Oracle Databases\n\nTo update a list of Oracle Databases in bulk, send a PATCH request to the [`/oracle/db/bulk`](#operation/bulkUpdateOracleDb) endpoint with a bulk_update_properties to complete a update.\n\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"ids\": \"$ids\",\n    \"logBackupFrequencyInMinutes\": \"$logBackupFrequencyInMinutes\",\n    \"logRetentionHours\": \"$logRetentionHours\",\n    \"hostLogRetentionHours\": \"$hostLogRetentionHours\",\n    \"numChannels\": \"$numChannels\",\n    \"hostMount\": \"string\",\n    \"configuredSlaDomainIdDeprecated\": \"string\",\n    \"nodeOrder\": [\n      {\n        \"nodeName\": \"string\",\n        \"order\": 0\n      }\n    ]\n  }' \\\n  \"https://$cluster_address/api/v1/oracle/db/bulk\"\n```\n\nA BulkOracleDbDetails object contains an array of OracleDbDetail is returned.\n\n## Bulk Update Oracle Hosts\n\nTo update a list of Oracle hosts in bulk, send a PATCH request to the [`/oracle/host/bulk`](#operation/bulkUpdateOracleHost) endpoint with a bulk_update_properties to complete a update.\n\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"ids\": \"$ids\",\n    \"logBackupFrequencyInMinutes\": \"$logBackupFrequencyInMinutes\",\n    \"logRetentionHours\": \"$logRetentionHours\",\n    \"hostLogRetentionHours\": \"$hostLogRetentionHours\",\n    \"numChannels\": \"$numChannels\",\n    \"hostMount\": \"string\",\n    \"configuredSlaDomainIdDeprecated\": \"string\",\n    \"nodeOrder\": [\n      {\n        \"nodeName\": \"string\",\n        \"order\": 0\n      }\n    ]\n  }' \\\n  \"https://$cluster_address/api/v1/oracle/host/bulk\"\n```\n\nA BulkOracleHostDetails object contains an array of OracleHostDetail is returned.\n\n## Bulk Update Oracle RACs\n\nTo update a list of Oracle RACs in bulk, send a PATCH request to the [`/oracle/rac/bulk`](#operation/bulkUpdateOracleRac) endpoint with a bulk_update_properties to complete a update.\n\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"ids\": \"$ids\",\n    \"logBackupFrequencyInMinutes\": \"$logBackupFrequencyInMinutes\",\n    \"logRetentionHours\": \"$logRetentionHours\",\n    \"hostLogRetentionHours\": \"$hostLogRetentionHours\",\n    \"numChannels\": \"$numChannels\",\n    \"hostMount\": \"string\",\n    \"configuredSlaDomainIdDeprecated\": \"string\",\n    \"nodeOrder\": [\n      {\n        \"nodeName\": \"string\",\n        \"order\": 0\n      }\n    ]\n  }' \\\n  \"https://$cluster_address/api/v1/oracle/rac/bulk\"\n```\n\nA BulkOracleRacDetails object contains an array of OracleRacDetail is returned.\n\n## Trigger a ORACLE_VALIDATE_BACKUP job to validate backups of selected recovery point on a choosing Oracle host\n\nTo request an asynchronous job to validate backups of selected recovery point on a choosing Oracle host or Oracle RAC, send a POST request to the [`/oracle/db/{id}/validate`](#operation/createOracleValidateBackupJob) endpoint with a OracleValidateConfig.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"config\": {\n      \"recoveryPoint\": { \"timestampMs\": 12345 },\n      \"targetOracleHostOrRacId\": \"54321\":,\n      \"sgaMaxSize\": 4,\n      \"targetOracleHome\": \"/fullpath/for/oracleHome\",\n      \"targetMountPath\": \"/fullpath/for/mountPath\",\n      \"numChannels\": 4\n    }\n  }' \\\n  \"https://$cluster_address/api/v1/oracle/db/{id}/validate\n  ```\nAn async request is returned and can be polled to retrieve the job status.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/internal/oracle/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"QUEUED\"\n}\n```\n\n## Get a download link of example Advanced Recovery Options file\n\nTo get a link to download an example Advanced Recovery Options file, send a GET request to the [`/oracle/aco_example_download_link`](#operation/getExampleAcoDownloadLink) endpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/oracle/aco_example_download_link\"\n```\n\nAn OracleFileDownloadLink object is returned which has a link to download the sample Advanced Recovery Options file.\n\n## Update Oracle Data Guard Group\n\nTo update an Oracle Data Guard group, send a PATCH request to the [`/oracle/data_guard_group/{id}`](#operation/updateOracleDataGuardGroup) endpoint. Edit the update_properties field with the properties to be updated.\n\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"logBackupFrequencyInMinutes\": \"$logBackupFrequencyInMinutes\",\n    \"logRetentionHours\": \"$logRetentionHours\",\n    \"hostLogRetentionHours\": \"$hostLogRetentionHours\",\n    \"numChannels\": \"$numChannels\",\n    \"hostMount\": \"string\",\n    \"shouldBackupFromPrimaryOnly\": false,\n    \"preferredDGMemberUniqueNames\": [\"unique_name\"]\n    ]\n  }' \\\n  \"https://$cluster_address/api/v1/oracle/data_guard_group/{id}\"\n```\n\nThe Rubrik REST API server responds with an OracleDbDetail object containing information about the Data Guard group.\n```bash\n{\n  \"id\": \"OracleDatabase:::1e7d288f-deed-4d72-a3a2-ad578c093f2e\",\n  \"name\": \"rbk\",\n  \"configuredSlaDomainId\": \"INHERIT\",\n  \"configuredSlaDomainName\": \"Inherit\",\n  \"configuredSlaDomainType\": \"ProtectionSla\",\n  \"primaryClusterId\": \"55a8c22c-424c-41ee-91e0-94c282281e4b\",\n  \"isConfiguredSlaDomainRetentionLocked\": false,\n  \"effectiveSlaDomainId\": \"UNPROTECTED\",\n  \"effectiveSlaDomainName\": \"Unprotected\",\n  \"isEffectiveSlaDomainRetentionLocked\": false,\n  \"effectiveSlaSourceObjectId\": \"Global:::All\",\n  \"slaAssignment\": \"Unassigned\",\n  \"retentionSlaDomainId\": \"UNPROTECTED\",\n  \"infraPath\": [],\n  \"isRelic\": false,\n  \"numTablespaces\": 0,\n  \"logBackupFrequencyInMinutes\": 0,\n  \"numMissedSnapshot\": 0,\n  \"includeBackupTaskInfo\": true,\n  \"isDbLocalToTheCluster\": true,\n  \"hostLogRetentionHours\": 0,\n  \"isArchiveLogModeEnabled\": true,\n  \"dbUniqueName\": \"DG_rbk\",\n  \"dataGuardType\": \"DataGuardGroup\",\n  \"dataGuardGroupMembers\": [\n    {\n      \"dbUniqueName\": \"rbk\",\n      \"role\": \"PRIMARY\",\n      \"standaloneHostId\": \"OracleHost:::d108cb3f-e4c6-4579-8aa1-f471940d6f8f\",\n      \"standaloneHostName\": \"oel75-121-dg-primary-20210421023956\"\n    }\n  ],\n  \"logRetentionHours\": 720,\n  \"numChannels\": 1,\n  \"hostMount\": \"/var/rubrik/oracle\",\n  \"tablespaces\": [],\n  \"snapshotCount\": 0,\n  \"isLiveMount\": false,\n  \"hostsInfo\": [\n    {\n      \"id\": \"Host:::0134de15-10b7-4296-a0b4-7232d2a9edaa\",\n      \"hostname\": \"10.0.188.224\",\n      \"oracleSysDbaUser\": \"oracle\",\n      \"oracleQueryUser\": \"oracle\"\n    }\n  ],\n  \"shouldBackupFromPrimaryDGGroupMemberOnly\": true,\n  \"preferredDGMemberUniqueNames\": []\n}\n```\n\n## Retrieving Oracle databases\n### Retrieving a summary of all Oracle databases\n\nTo get a list of Oracle databases, send a GET request to the [`/oracle/db`](#operation/queryOracleDbV1) endpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/oracle/db\"\n```\n\nThe Rubrik REST API server responds with a list of OracleDbSummary objects containing information about the databases.\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"OracleDatabase:::912819e7-d603-4c1a-860a-88ba9c15b930\",\n      \"name\": \"rbk\",\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"configuredSlaDomainName\": \"Inherit\",\n      \"configuredSlaDomainType\": \"ProtectionSla\",\n      \"primaryClusterId\": \"55a8c22c-424c-41ee-91e0-94c282281e4b\",\n      \"isConfiguredSlaDomainRetentionLocked\": false,\n      \"effectiveSlaDomainId\": \"UNPROTECTED\",\n      \"effectiveSlaDomainName\": \"Unprotected\",\n      \"isEffectiveSlaDomainRetentionLocked\": false,\n      \"effectiveSlaSourceObjectId\": \"Global:::All\",\n      \"slaAssignment\": \"Unassigned\",\n      \"retentionSlaDomainId\": \"UNPROTECTED\",\n      \"infraPath\": [\n        {\n          \"name\": \"oel75-121-dg-primary-20210421023956\",\n          \"id\": \"OracleHost:::d108cb3f-e4c6-4579-8aa1-f471940d6f8f\"\n        }\n      ],\n      \"isRelic\": false,\n      \"numTablespaces\": 5,\n      \"numMissedSnapshot\": 0,\n      \"includeBackupTaskInfo\": false,\n      \"isDbLocalToTheCluster\": true,\n      \"hostLogRetentionHours\": 0,\n      \"sid\": \"rbk\",\n      \"standaloneHostId\": \"OracleHost:::d108cb3f-e4c6-4579-8aa1-f471940d6f8f\",\n      \"numInstances\": 1,\n      \"instances\": [\n        {\n          \"hostName\": \"10.0.188.224\",\n          \"instanceSid\": \"rbk\"\n        }\n      ],\n      \"isArchiveLogModeEnabled\": true,\n      \"standaloneHostName\": \"oel75-121\",\n      \"archiveLogDestinations\": [\n        \"\"\n      ],\n      \"isPrimary\": true,\n      \"dbUniqueName\": \"rbk\",\n      \"databaseRole\": \"PRIMARY\",\n      \"dataGuardType\": \"DataGuardMember\",\n      \"dataGuardGroupId\": \"OracleDatabase:::1e7d288f-deed-4d72-a3a2-ad578c093f2e\",\n      \"dataGuardGroupName\": \"DG_rbk\"\n    }\n  ],\n  \"total\": 1\n}\n```\n\n### Retrieving detailed information for a specific Oracle database\n\nTo get detailed information about an Oracle Database, send a GET request to the [`/oracle/db/{id}`](#operation/getOracleDbV1) endpoint where, {id} is the ID of the Oracle database.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/oracle/db/$oracle_database_id\"\n```\n\nThe Rubrik REST API server responds with an OracleDbDetail object containing information about the specified  database.\n\n```bash\n{\n  \"id\": \"OracleDatabase:::912819e7-d603-4c1a-860a-88ba9c15b930\",\n  \"name\": \"rbk\",\n  \"configuredSlaDomainId\": \"INHERIT\",\n  \"configuredSlaDomainName\": \"Inherit\",\n  \"configuredSlaDomainType\": \"ProtectionSla\",\n  \"primaryClusterId\": \"55a8c22c-424c-41ee-91e0-94c282281e4b\",\n  \"isConfiguredSlaDomainRetentionLocked\": false,\n  \"effectiveSlaDomainId\": \"UNPROTECTED\",\n  \"effectiveSlaDomainName\": \"Unprotected\",\n  \"isEffectiveSlaDomainRetentionLocked\": false,\n  \"effectiveSlaSourceObjectId\": \"Global:::All\",\n  \"slaAssignment\": \"Unassigned\",\n  \"retentionSlaDomainId\": \"UNPROTECTED\",\n  \"infraPath\": [\n    {\n      \"name\": \"oel75-121-dg-primary-20210421023956\",\n      \"id\": \"OracleHost:::d108cb3f-e4c6-4579-8aa1-f471940d6f8f\"\n    }\n  ],\n  \"isRelic\": false,\n  \"numTablespaces\": 5,\n  \"logBackupFrequencyInMinutes\": 0,\n  \"numMissedSnapshot\": 0,\n  \"includeBackupTaskInfo\": true,\n  \"isDbLocalToTheCluster\": true,\n  \"hostLogRetentionHours\": 0,\n  \"sid\": \"rbk\",\n  \"standaloneHostId\": \"OracleHost:::d108cb3f-e4c6-4579-8aa1-f471940d6f8f\",\n  \"numInstances\": 1,\n  \"instances\": [\n    {\n      \"hostName\": \"10.0.188.224\",\n      \"instanceSid\": \"rbk\"\n    }\n  ],\n  \"isArchiveLogModeEnabled\": true,\n  \"standaloneHostName\": \"oel75-121-dg-primary-20210421023956\",\n  \"archiveLogDestinations\": [\n    \"\"\n  ],\n  \"isPrimary\": true,\n  \"dbUniqueName\": \"rbk\",\n  \"databaseRole\": \"PRIMARY\",\n  \"dataGuardType\": \"DataGuardMember\",\n  \"dataGuardGroupId\": \"OracleDatabase:::1e7d288f-deed-4d72-a3a2-ad578c093f2e\",\n  \"dataGuardGroupName\": \"DG_rbk\",\n  \"logRetentionHours\": 720,\n  \"numChannels\": 1,\n  \"hostMount\": \"/var/rubrik/oracle\",\n  \"tablespaces\": [\n    \"SYSAUX\",\n    \"SYSTEM\",\n    \"UNDOTBS1\",\n    \"USERS\",\n    \"TEMP\"\n  ],\n  \"snapshotCount\": 0,\n  \"oracleHome\": \"/u01/app/oracle/product/12.1.0.2/dbhome_1\",\n  \"isLiveMount\": false,\n  \"hostsInfo\": [\n    {\n      \"id\": \"Host:::0134de15-10b7-4296-a0b4-7232d2a9edaa\",\n      \"hostname\": \"10.0.188.224\",\n      \"oracleSysDbaUser\": \"oracle\",\n      \"oracleQueryUser\": \"oracle\"\n    }\n  ]\n}\n```\n\n## Updating Oracle Database\n\nTo update an Oracle database, send a PATCH request to the [`/oracle/db/{id}`](#operation/updateOracleDbV1) endpoint. Edit the update_properties field with the properties to be updated.\n\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"logBackupFrequencyInMinutes\": \"$logBackupFrequencyInMinutes\",\n    \"logRetentionHours\": \"$logRetentionHours\",\n    \"hostLogRetentionHours\": \"$hostLogRetentionHours\",\n    \"numChannels\": \"$numChannels\",\n    \"hostMount\": \"$hostMount\"\n    ]\n  }' \\\n  \"https://$cluster_address/api/v1/oracle/db/$oracle_database_id\"\n```\n\nThe Rubrik REST API server responds with an OracleDbDetail object containing information about the updated database.\n```bash\n{\n  \"id\": \"OracleDatabase:::912819e7-d603-4c1a-860a-88ba9c15b930\",\n  \"name\": \"rbk\",\n  \"configuredSlaDomainId\": \"INHERIT\",\n  \"configuredSlaDomainName\": \"Inherit\",\n  \"configuredSlaDomainType\": \"ProtectionSla\",\n  \"primaryClusterId\": \"55a8c22c-424c-41ee-91e0-94c282281e4b\",\n  \"isConfiguredSlaDomainRetentionLocked\": false,\n  \"effectiveSlaDomainId\": \"UNPROTECTED\",\n  \"effectiveSlaDomainName\": \"Unprotected\",\n  \"isEffectiveSlaDomainRetentionLocked\": false,\n  \"effectiveSlaSourceObjectId\": \"Global:::All\",\n  \"slaAssignment\": \"Unassigned\",\n  \"retentionSlaDomainId\": \"UNPROTECTED\",\n  \"infraPath\": [\n    {\n      \"name\": \"oel75-121-dg-primary-20210421023956\",\n      \"id\": \"OracleHost:::d108cb3f-e4c6-4579-8aa1-f471940d6f8f\"\n    }\n  ],\n  \"isRelic\": false,\n  \"numTablespaces\": 5,\n  \"logBackupFrequencyInMinutes\": 0,\n  \"numMissedSnapshot\": 0,\n  \"includeBackupTaskInfo\": true,\n  \"isDbLocalToTheCluster\": true,\n  \"hostLogRetentionHours\": 0,\n  \"sid\": \"rbk\",\n  \"standaloneHostId\": \"OracleHost:::d108cb3f-e4c6-4579-8aa1-f471940d6f8f\",\n  \"numInstances\": 1,\n  \"instances\": [\n    {\n      \"hostName\": \"10.0.188.224\",\n      \"instanceSid\": \"rbk\"\n    }\n  ],\n  \"isArchiveLogModeEnabled\": true,\n  \"standaloneHostName\": \"oel75-121-dg-primary-20210421023956\",\n  \"archiveLogDestinations\": [\n    \"\"\n  ],\n  \"isPrimary\": true,\n  \"dbUniqueName\": \"rbk\",\n  \"databaseRole\": \"PRIMARY\",\n  \"dataGuardType\": \"DataGuardMember\",\n  \"dataGuardGroupId\": \"OracleDatabase:::1e7d288f-deed-4d72-a3a2-ad578c093f2e\",\n  \"dataGuardGroupName\": \"DG_rbk\",\n  \"logRetentionHours\": 720,\n  \"numChannels\": 1,\n  \"hostMount\": \"/var/rubrik/oracle\",\n  \"tablespaces\": [\n    \"SYSAUX\",\n    \"SYSTEM\",\n    \"UNDOTBS1\",\n    \"USERS\",\n    \"TEMP\"\n  ],\n  \"snapshotCount\": 0,\n  \"oracleHome\": \"/u01/app/oracle/product/12.1.0.2/dbhome_1\",\n  \"isLiveMount\": false,\n  \"hostsInfo\": [\n    {\n      \"id\": \"Host:::0134de15-10b7-4296-a0b4-7232d2a9edaa\",\n      \"hostname\": \"10.0.188.224\",\n      \"oracleSysDbaUser\": \"oracle\",\n      \"oracleQueryUser\": \"oracle\"\n    }\n  ]\n}\n```\n\n## Get Oracle Advanced Cloning Options (ACO) parameters\n\nTo get a list of supported ACO parameter names, send a GET request to the [`/oracle/aco_parameter_list`](#operation/getAcoParameterList) endpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/oracle/aco_parameter_list\"\n```\n\nThe Rubrik REST API server responds with an OracleAcoParameterList object which contains the list of supported ACO parameter names.\n\n## Validate an Oracle Advanced Cloning Options (ACO) config file\n\nTo validate an ACO file, send a POST request to the [`/oracle/validate_aco_file`](#operation/validateOracleAcoFile) endpoint. Send the base 64 encoded string of the ACO file contents in the body and a boolean determining whether the ACO file is for a Live Mount or not, as a query parameter.\n```bash\ncurl -X POST \\\n  -d '{\n    \"aco_contents_base64\": \"$aco_contents_base64\"\n  }' \\\n  \"https://$cluster_address/api/v1/oracle/validate_aco_file?is_live_mount={is_live_mount}\n```\n\nThe Rubrik REST API server validates the given ACO file contents and returns an OracleAcoValidationResult containing the validation result of the ACO file given.\n\n# vApps\n\nThe Rubrik cluster protects vApps running in a VMware vCloud Director environment through the vCloud Director REST APIs.\nThe Rubrik cluster must connect to the underlying vCenter servers to protect vApps.\n\n## vApp Templates\n\nThe Rubrik cluster protects vApp template objects through the vCloud Director APIs.\n\n## vCloud Director server\n\nA Rubrik cluster protects and manages vApps and vApp templates through the vCloud Director server that administers those\nvApps. After a vCloud Director server is added to a Rubrik cluster, the Rubrik cluster automatically discovers the vApps\nadministered under the server.\n\n### Retrieving details for a vApp template snapshot export\n\nTo retrieve the options available for exporting a specified vApp template snapshot to an organization vDC and available\nstorage policies, send a GET request\nto [`/vcd/vapp/template/snapshot/{snapshot_id}/export/options`](#operation/getVappTemplateSnapshotExportOptions).\n\nTo filter the results of the GET request sent to the \n[`/vcd/vapp/template/snapshot/{snapshot_id}/export/options`](#operation/getVappTemplateSnapshotExportOptions)\nendpoint, configure the following query parameters before sending the request.\n\n| Parameter  | Required | Type   | Description |\n| ---------- | -------- | ------ | ----------- |\n|`catalog_id`| Required | string | ID of the target Catalog object.|\n|`name`      | Required | string | Name of template object to be created. This is used to verify the existence of a template with the given name. Templates must have unique names.\n|`org_vdc_id`| Optional | string | ID assigned to a target organization VDC object. This parameter is required when advanced export options are used.\n\nA vApp template export targets a catalog and requires a valid storage policy and organization vDC. There are three\noptions available for export of a vApp template -\n\n* **OriginalVdcExportOptions** - This option is used to export to the original organization vDC of the vApp template\n  when the snapshot was taken. Only available when the catalog to export is under the same organization as the original\n  organization vDC and the vDC is still active.\n  `org_vdc_id` is not required when using this option.\n* **DefaultCatalogExportOptions** - This option is used to export to the vDC corresponding to the default storage policy\n  of the catalog. This option is unavailable for catalogs that do not have storage policies.\n  `org_vdc_id` is not required when using this option.\n* **AdvancedExportOptions** - This option is used to export to a specific organization vDC under the same organization\n  as the Catalog to export. The GET request returns the choices of storage policies available.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vcd/vapp/template/snapshot/$snapshot_id/export/options?catalog_id=$catalog_id&name=$template_name\"\n```\n\nThe Rubrik REST API responds with a `VappTemplateExportOptionsUnion` object which has fields for all the above options.\n\n**Note:** To shorten the example, the response uses ellipses to replace some members.\n\n```bash\n{\n  \"hasMore\": false,\n  \"originalVdcExportOptions\" :\n    {\n      \"orgVdcId\": \"$org_vdc_id1\",\n      \"availableStoragePolicies\": [\n        ...\n      ]\n    },\n   \"defaultCatalogExportOptions\" :\n    {\n      \"orgVdcId\": \"$org_vdc_id1\",\n      \"availableStoragePolicies\": [\n        ...\n      ]\n    },\n   \"advancedExportOptions\" :\n    {\n      \"orgVdcId\": \"$org_vdc_id1\",\n      \"availableStoragePolicies\": [\n        ...\n      ]\n    }\n}\n```\n\n### Exporting a vApp template snapshot\n\nTo create a new vApp template in a catalog using the export feature, send a POST request to the \n[`/vcd/vapp/template/snapshot/{snapshot_id}/export`](#operation/createVappTemplateSnapshotExport) endpoint.\nThe request takes the snapshot_id as a path parameter. The request payload includes the parameters described in the \nfollowing table.\n\n| Name            | Required | Type   | Description |\n| --------------- | -------- | ------ | ----------- |\n|`name`           | Required | string | Name of vApp template to be created.|\n|`catalogId`      | Required | string | ID of the Catalog where the vApp template is created.|\n|`orgVdcId`       | Required | string | ID of the organization vDC where the vApp template is created.|\n|`storagePolicyId`| Required | string | ID of the organization vDC storage policy to be used. In case a storage policy ID is not provided, the default storage policy of the organization vDC is used.\n\n**Note:** The Catalog and organization vDC must belong to the same organization. When providing a storage policy, that\nstorage policy must be present in the organization vDC.\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"name\": \"$template_name\",\n    \"catalogId\": \"$catalog_id\",\n    \"orgVdcId\": \"$org_vdc_id\"\n   }' \\\n   \"https://$cluster_address/api/v1/vcd/vapp/template/snapshot/$snapshot_id/export\"\n```\n\nThe Rubrik REST API server initiates the asynchronous request task and responds with the the details of the\nAsyncRequestStatus request.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$timestamp\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vcd/vapp/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Retrieving summary of vApps\n\nTo retrieve the summary information for all vCD vApp objects, send a GET request to the\n[`/vcd/vapp`](#operation/queryVcdVappsV1) endpoint. The parameters described in the following table are available to \nfilter the results of the GET request.\n\n| Name                     | Required | Type    | Description |\n| ------------------------ | -------- | ------- | ----------- |\n|`sort_by`                 | Optional | string  | Attribute to sort the vCD vApp list on.|\n|`sort_order`              | Optional | string  | Order for sorting the results, either ascending or descending.|\n|`limit`                   | Optional | int     | Limit the number of matches returned.|\n|`offset`                  | Optional | int     | Number of matches to ignore from the beginning of the results.|\n|`name`                    | Optional | string  | Search for a vCD vApp object by name.|\n|`is_relic`                | Optional | boolean | Filter by isRelic field of vCD vApp object. Returns both relic and non-relic vApps when this value is not specified.|\n|`effective_sla_domain_id` | Optional | string  | SLA Domain applied to the virtual machine, either directly or derived.|\n|`primary_cluster_id`      | Optional | string  | Filter by primary cluster ID, or **local**.|\n|`sla_assignment`          | Optional | string  | Filter by SLA assignment type.|\n|`include_backup_task_info`| Optional | boolean | Include backup task information in response.|\n\n ```bash\n curl -X GET \"https://$cluster_address/api/v1/vcd/vapp\"\n ```\n\nThe Rubrik REST API server responds with a list of vApp objects that fit the specified parameters. The response is a \nList of VcdVappSummary objects.\n\n ```bash\n {\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"$vappId\",\n      \"name\": \"$vappName\",\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"configuredSlaDomainName\": \"Inherit\",\n      \"configuredSlaDomainType\": \"ProtectionSla\",\n      \"primaryClusterId\": \"$primaryClusterId\",\n      \"isConfiguredSlaDomainRetentionLocked\": true,\n      \"slaLastUpdateTime\": \"$slaLastUpdateTime\",\n      \"effectiveSlaDomainId\": \"UNPROTECTED\",\n      \"effectiveSlaDomainName\": \"Unprotected\",\n      \"isEffectiveSlaDomainRetentionLocked\": true,\n      \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",\n      \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",\n      \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",\n      \"slaAssignment\": \"Derived\",\n      \"retentionSlaDomainId\": \"$retentionSlaDomainId\",\n      \"vcdClusterId\": \"$vcdId\",\n      \"vcdClusterName\": \"$vcdClusterName\",\n      \"infraPath\": [\n        ...\n      ],\n      \"isRelic\": true,\n      \"numMissedSnapshot\": 0,\n      \"lastSnapshotTime\": \"$lastSnapshotTime\",\n      \"includeBackupTaskInfo\": true,\n      \"currentBackupTaskInfo\": {\n        \"taskStatus\": \"Queued\",\n        \"queueTime\": \"$queueTime\",\n        \"expectedEndTime\": \"$expectedEndTime\"\n      },\n      \"isTemplate\": true,\n      \"catalogId\": \"$catalogId\",\n      \"pendingSlaDomain\": {\n        \"objectId\": \"$objectId\",\n        \"pendingSlaDomainId\": \"$pendingSlaDomain\",\n        \"pendingSlaDomainName\": \"$pendingSlaDomainName\",\n        \"isPendingSlaDomainRetentionLocked\": true\n      }\n    }\n  ],\n  \"total\": 0\n}\n ```\n\n### Retrieving details for a specific vApp\n\nTo retrieve detailed information about a specific vApp, send a GET request to\n[`/vcd/vapp/{id}`](#operation/getVcdVappV1), where {id} is the ID of a vApp object.\n\n ```bash\n curl -X GET -d \"https://$cluster_address/api/v1/vcd/vapp/{id}\"\n ```\n\nThe Rubrik REST API server responds with the details (VcdVappDetail) of the specified vApp object.\n\n ```bash\n{\n  \"id\": \"string\",\n  \"status\": \"string\",\n  \"progress\": 0,\n  \"startTime\": \"2021-03-16T04:37:38.913Z\",\n  \"endTime\": \"2021-03-16T04:37:38.913Z\",\n  \"nodeId\": \"string\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"string\",\n      \"rel\": \"string\"\n    }\n  ]\n}\n ```\n\n### Updating vApp\n\nTo make changes to the parameters of a specified vApp object, send a PATCH request\nto [`/vcd/vapp/{id}`](#operation/updateVcdVappV1), where {id} is the ID of the vApp object to be updated. The request\npayload of the PATCH request includes the parameters to be updated.\n\n| Name |  Description | Notes |\n  | ---- | ------------ | ----- |\n| configured_sla_domain_id | ID of the SLA Domain object that manages protection for the specified vApp object. Existing snapshots of the vApp object will be retained with the configuration of the specified SLA Domain. | optional |\n| is_paused | Boolean value that indicates whether protection activity is paused for the specified vApp. Set to &#39;true&#39; when protection activity is paused and &#39;false&#39; when protection activity is not paused. Protection activity includes: backup, replication, and archiving. | optional |\n| is_best_effort_synchronization_enabled | Boolean value that indicates whether the Rubrik cluster should attempt taking synchronized snapshots across all child Virtual Machines of the vApp object. | optional |\n| vcd_vm_moids_to_exclude_from_snapshot | Array containing vCloud Director Virtual Machine moids that will be excluded from the vApp snapshots. | optional |\n\n```bash\n curl -X PATCH -d \\\n  '{\n    \"configuredSlaDomainId\": \"$sla_domain_id\",\n    \"isPaused\": \"true\",\n    \"isBestEffortSynchronizationEnabled\": \"true\",\n    \"vcdVmMoidsToExcludeFromSnapshot\": \"$vm_moids_to_exclude\"\n   }' \\\n   \"https://$cluster_address/api/v1/vcd/vapp/{id}\"\n ```\n\nThe Rubrik REST API server responds with the details (VcdVappDetail) of the updated vApp object.\n\n ```bash\n{\n  \"configuredSlaDomainId\": \"INHERIT\",\n  \"isPaused\": true,\n  \"isBestEffortSynchronizationEnabled\": true,\n  \"vcdVmMoidsToExcludeFromSnapshot\": [\n    ...\n  ],\n  \"id\": \"$vappId\",\n  \"name\": \"$name\",\n  \"configuredSlaDomainName\": \"Inherit\",\n  \"configuredSlaDomainType\": \"ProtectionSla\",\n  \"primaryClusterId\": \"$primaryClusterId\",\n  \"isConfiguredSlaDomainRetentionLocked\": true,\n  \"slaLastUpdateTime\": \"$slaLastUpdateTime\",\n  \"effectiveSlaDomainId\": \"UNPROTECTED\",\n  \"effectiveSlaDomainName\": \"Unprotected\",\n  \"isEffectiveSlaDomainRetentionLocked\": true,\n  \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",\n  \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",\n  \"effectiveSlaSourceObjectName\": \"effectiveSlaSourceObjectName\",\n  \"slaAssignment\": \"Derived\",\n  \"retentionSlaDomainId\": \"$retentionSlaDomainId\",\n  \"vcdClusterId\": \"$vcdClusterId\",\n  \"vcdClusterName\": \"$vcdClusterName\",\n  \"infraPath\": [\n    ...\n  ],\n  \"isRelic\": true,\n  \"numMissedSnapshot\": 0,\n  \"lastSnapshotTime\": \"$lastSnapshotTime\",\n  \"includeBackupTaskInfo\": true,\n  \"currentBackupTaskInfo\": {\n    \"taskStatus\": \"Queued\",\n    \"queueTime\": \"$queueTime\",\n    \"expectedEndTime\": \"$expectedEndTime\"\n  },\n  \"isTemplate\": true,\n  \"catalogId\": \"$catalogId\",\n  \"pendingSlaDomain\": {\n    \"objectId\": \"$objectId\",\n    \"pendingSlaDomainId\": \"$pendingSlaDomainId\",\n    \"pendingSlaDomainName\": \"$pendingSlaDomainName\",\n    \"isPendingSlaDomainRetentionLocked\": true\n  },\n  \"networks\": [\n    ...\n  ],\n  \"vms\": [\n    ...\n  ]\n}\n ```\n\n### Retrieving summary information for all vApp snapshots\n\n## vApp snapshots\n\nTo retrieve summary information for each of the snapshot objects of a specified vApp object, send a GET request\nto [`/vcd/vapp/{id}/snapshot`](#operation/queryVappSnapshotV1), where {id} is the ID of the vApp object.\n\n ```bash\n curl -X GET -d \"https://$cluster_address/api/v1/vcd/vapp/{id}/snapshot\"\n ```\n\nThe Rubrik REST API server responds with the details of all the snapshots of the specified vApp. \nThe response is a List of VcdVappSnapshotSummary objects.\n\n ```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"$vappId\",\n      \"date\": \"$date\",\n      \"expirationDate\": \"$expirationDate\",\n      \"sourceObjectType\": \"$sourceObjectType\",\n      \"isOnDemandSnapshot\": true,\n      \"isCustomRetentionApplied\": true,\n      \"cloudState\": 0,\n      \"consistencyLevel\": \"#consistencyLevel\",\n      \"indexState\": 0,\n      \"replicationLocationIds\": [\n        \"string\"\n      ],\n      \"archivalLocationIds\": [\n        \"string\"\n      ],\n      \"slaId\": \"$slaId\",\n      \"slaName\": \"$slaName\",\n      \"isRetainedByRetentionLockSla\": true,\n      \"cloudStorageTier\": \"Hot\",\n      \"isPlacedOnLegalHold\": true,\n      \"snapshotRetentionInfo\": {\n        \"localInfo\": {\n          \"id\": \"string\",\n          \"name\": \"string\",\n          \"isSnapshotPresent\": true,\n          \"isExpirationDateCalculated\": true,\n          \"expirationTime\": \"$expirationTime\",\n          \"snapshotFrequency\": \"$snapshotFrequency\",\n          \"isExpirationInformationUnavailable\": true\n        },\n        \"archivalInfos\": [\n          {\n            \"id\": \"$id\",\n            \"name\": \"$name\",\n            \"isSnapshotPresent\": true,\n            \"isExpirationDateCalculated\": true,\n            \"expirationTime\": \"$expirationTime\",\n            \"snapshotFrequency\": \"$snapshotFrequency\",\n            \"isExpirationInformationUnavailable\": true\n          }\n        ],\n        \"replicationInfos\": [\n          {\n            \"id\": \"$id\",\n            \"name\": \"$name\",\n            \"isSnapshotPresent\": true,\n            \"isExpirationDateCalculated\": true,\n            \"expirationTime\": \"$expirationTime\",\n            \"snapshotFrequency\": \"$snapshotFrequency\",\n            \"isExpirationInformationUnavailable\": true\n          }\n        ],\n        \"cloudNativeLocationInfo\": [\n          {\n            \"id\": \"$id\",\n            \"name\": \"$name\",\n            \"isSnapshotPresent\": true,\n            \"isExpirationDateCalculated\": true,\n            \"expirationTime\": \"$expirationTime\",\n            \"snapshotFrequency\": \"$snapshotFrequency\",\n            \"isExpirationInformationUnavailable\": true\n          }\n        ]\n      },\n      \"parentSnapshotId\": \"$parentSnapshotId\",\n      \"vappName\": \"$vappName\",\n      \"isSynchronized\": true,\n      \"vmSnapshots\": [\n        {\n          \"vcenterVmId\": \"$vcenterVmId\",\n          \"vmSnapshotId\": \"$vmSnapshotId\",\n          \"vmName\": \"$vmName\",\n          \"vcdVmMoid\": \"$vcdVmMoid\",\n          \"indexState\": 0\n        }\n      ]\n    }\n  ],\n  \"total\": 0\n}\n ```\n\n## Creating an on-demand snapshot for a vApp\n\nTo create an on-demand snapshot for a specified vApp object, send a POST request to\n[`/vcd/vapp/{id}/snapshot`](#operation/createOnDemandSnapshotV1), where {id} is the ID of the vApp object.\n\n ```bash\n curl -X POST -d \"https://$cluster_address/api/v1/vcd/vapp/$id/snapshot\"\n ```\n\nThe Rubrik REST API server initiates an asynchronous job to create an on-demand snapshot and returns the details of the\nAsyncRequestStatus request.\n\n ```bash\n{\n  \"id\": \"$requestId\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$startTime\",\n  \"endTime\": \"$endTime\",\n  \"nodeId\": \"$nodeId\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vcd/vapp/request/$requestId\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n ```\n\n### Deleting all snapshots of a vApp object\n\nTo delete all snapshots for a specified vApp object, send a DELETE request to\n[`/vcd/vapp/{id}/snapshot`](#operation/deleteVappSnapshotsV1), where {id} is the ID of the vApp object whose snapshot\nneeds to be deleted.\n\n ```bash\n curl -X DELETE -d \"https://$cluster_address/api/v1/vcd/vapp/$id/snapshot\"\n ```\n\nThe Rubrik REST API server deletes all snapshots of the specified vApp.\n\n ```bash\n{\"Snapshots deleted successfully.\"}\n ```\n\n## Retrieving details about a specific vApp snapshot\n\nTo retrieve detailed information about a specified snapshot for a vApp object, send a GET request\nto [`/vcd/vapp/snapshot/{id}`](#operation/getVappSnapshotV1), where {id} is the ID of the snapshot object whose details\nare required.\n\n```bash\n curl -X GET -d \"https://$cluster_address/api/v1/vcd/vapp/snapshot/{id}\"\n ```\n\nThe Rubrik REST API server fetches details (VcdVappSnapshotDetail) of the specified vApp snapshot.\n\n ```bash\n{\n  \"id\": \"$id\",\n  \"date\": \"$date\",\n  \"expirationDate\": \"$expirationDate\",\n  \"sourceObjectType\": \"$sourceObjectType\",\n  \"isOnDemandSnapshot\": true,\n  \"isCustomRetentionApplied\": true,\n  \"cloudState\": 0,\n  \"consistencyLevel\": \"$consistencyLevel\",\n  \"indexState\": 0,\n  \"replicationLocationIds\": [\n    \"string\"\n  ],\n  \"archivalLocationIds\": [\n    \"string\"\n  ],\n  \"slaId\": \"$slaId\",\n  \"slaName\": \"$slaName\",\n  \"isRetainedByRetentionLockSla\": true,\n  \"cloudStorageTier\": \"Hot\",\n  \"isPlacedOnLegalHold\": true,\n  \"snapshotRetentionInfo\": {\n    \"localInfo\": {\n      \"id\": \"string\",\n      \"name\": \"string\",\n      \"isSnapshotPresent\": true,\n      \"isExpirationDateCalculated\": true,\n      \"expirationTime\": \"$expirationTime\",\n      \"snapshotFrequency\": \"$snapshotFrequency\",\n      \"isExpirationInformationUnavailable\": true\n    },\n    \"archivalInfos\": [\n      {\n        \"id\": \"$id\",\n        \"name\": \"$name\",\n        \"isSnapshotPresent\": true,\n        \"isExpirationDateCalculated\": true,\n        \"expirationTime\": \"$expirationTime\",\n        \"snapshotFrequency\": \"$snapshotFrequency\",\n        \"isExpirationInformationUnavailable\": true\n      }\n    ],\n    \"replicationInfos\": [\n      {\n        \"id\": \"$id\",\n        \"name\": \"$name\",\n        \"isSnapshotPresent\": true,\n        \"isExpirationDateCalculated\": true,\n        \"expirationTime\": \"$expirationTime\",\n        \"snapshotFrequency\": \"$snapshotFrequency\",\n        \"isExpirationInformationUnavailable\": true\n      }\n    ],\n    \"cloudNativeLocationInfo\": [\n      {\n        \"id\": \"$id\",\n        \"name\": \"$name\",\n        \"isSnapshotPresent\": true,\n        \"isExpirationDateCalculated\": true,\n        \"expirationTime\": \"$expirationTime\",\n        \"snapshotFrequency\": \"$snapshotFrequency\",\n        \"isExpirationInformationUnavailable\": true\n      }\n    ]\n  },\n  \"parentSnapshotId\": \"$parentSnapshotId\",\n  \"vappName\": \"$vappName\",\n  \"isSynchronized\": true,\n  \"vmSnapshots\": [\n    {\n      \"vcenterVmId\": \"$vcenterVmId\",\n      \"vmSnapshotId\": \"$vmSnapshotId\",\n      \"vmName\": \"$vmName\",\n      \"vcdVmMoid\": \"$vcdVmMoid\",\n      \"indexState\": 0,\n      \"networkConnections\": [\n        {\n          \"nicIndex\": 0,\n          \"macAddress\": \"$macAddress\",\n          \"addressingMode\": \"DHCP\",\n          \"ipAddress\": \"$ipAddress\",\n          \"vappNetworkName\": \"vappNetworkName\",\n          \"isConnected\": true,\n          \"networkAdapterType\": \"$networkAdapterType\"\n        }\n      ]\n    }\n  ],\n  \"networks\": [\n    {\n      \"name\": \"$name\",\n      \"parentNetworkId\": \"$parentNetworkId\",\n      \"isDeployed\": true\n    }\n  ],\n  \"excludedVcdVmMoids\": [\n    $excludedVcdVmMoids\n  ]\n}\n ```\n\n### Deleting a specific vApp snapshot object\n\nTo delete an on-demand snapshot or a snapshot from a vApp that is not assigned to an SLA Domain, send a DELETE request\nto [`/vcd/vapp/snapshot/{id}`](#operation/deleteVappSnapshotV1), where {id}  is the ID assigned to a snapshot object.\n\n```bash\n curl -X DELETE -d \"https://$cluster_address/api/v1/vcd/vapp/snapshot/{id}?location=$snapshot_location\"\n ```\n\nThe Rubrik REST API server deletes the specified vApp snapshot at the location (\"all\" or \"local\") specified. \n\n ```bash\n{\"Snapshot successfully deleted.\"}\n ```\n\n### Retrieving details about missed snapshots for a vApp object\n\nTo retrieve the timestamp for each missed snapshot for a specified vApp, send a GET request\nto [`/vcd/vapp/{id}/missed_snapshot`](#operation/vcdMissedSnapshotsV1). where {id} is the id of the vapp.\n\n ```bash\n  curl -X GET -d \"https://$cluster_address/api/v1/vcd/vapp/$id/missed_snapshot\"\n  ```\n\nThe Rubrik REST API server fetches details about all missed snapshots (List of MissedSnapshot) of the specified vApp.\n\n  ```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"archivalLocationType\": [\n        \"string\"\n      ],\n      \"missedSnapshotTime\": \"$missedSnapshotTime\",\n      \"missedSnapshotTimeUnits\": [\n        {\n          \"timeUnit\": \"Minute\",\n          \"frequency\": 0,\n          \"retention\": 0,\n          \"dayOfTime\": \"Monday\"\n        }\n      ]\n    }\n  ],\n  \"total\": 0\n}\n  ```\n\n### Retrieving exportable network configurations\n\nTo retrieve the summary information for the vApp networks that are available for network connections from the virtual\nmachines in the exported vApp snapshot, send a GET request\nto [`/vcd/vapp/snapshot/{snapshot_id}/export/options`](#operation/getVappSnapshotExportOptionsV1). This API requires the\nsnapshot_id of the vApp snapshot object to export. It also requires the `export_mode`, `target_vapp_id` and the\n`target_org_vdc_id1`.\n\n```bash\n  curl -X GET -d \"https://$cluster_address/api/v1/vcd/vapp/snapshot/$snapshot_id/export/options?export_mode=$export_mode\"\n  ```\n\nThe Rubrik REST API server fetches VappExportOptions for the specified snapshot and export mode specified.\n\n  ```bash\n{\n  \"restorableNetworks\": [\n    {\n      \"name\": \"$name\",\n      \"parentNetworkId\": \"$parentNetworkId\",\n      \"isDeployed\": true,\n      \"newName\": \"$newName\"\n    }\n  ],\n  \"targetVappNetworks\": [\n    {\n      \"name\": \"$name\",\n      \"parentNetworkId\": \"$parentNetworkId\",\n      \"isDeployed\": true\n    }\n  ],\n  \"availableStoragePolicies\": [\n    {\n      \"name\": \"$name\",\n      \"id\": \"$id\"\n    }\n  ],\n  \"allChildVmsWithDefaultNetworkConnections\": [\n    {\n      \"name\": \"$name\",\n      \"vcdMoid\": \"$vcdMoid\",\n      \"storagePolicyId\": \"$storagePolicyId\",\n      \"networkConnections\": [\n        {\n          \"nicIndex\": 0,\n          \"macAddress\": \"$macAddress\",\n          \"addressingMode\": \"DHCP\",\n          \"ipAddress\": \"$ipAddress\",\n          \"vappNetworkName\": \"$vappNetworkName\",\n          \"isConnected\": true,\n          \"networkAdapterType\": \"$networkAdapterType\"\n        }\n      ]\n    }\n  ]\n}\n  ```\n\n### Exporting vApp snapshot\n\nTo export the specified vApp snapshot into a new vApp or an existing vApp, send a POST request\nto [`/vcd/vapp/snapshot/{snapshot_id}/export`](#operation/createVappExportV1), where {snapshot_id} is the ID assigned to\nthe vApp snapshot object.\n\n```bash\n    curl -X POST -d \\\n    '{\n      \"exportMode\": \"$exportMode\",\n      \"newVappParams\": {\n        \"name\": \"$name\",\n        \"orgVdcId\": \"$orgVdcId\"\n      },\n      \"targetVappId\": \"$targetVappId\",\n      \"networksToRestore\": [\n        {\n          \"name\": \"$name\",\n          \"parentNetworkId\": \"$parentNetworkId\",\n          \"isDeployed\": true,\n          \"newName\": \"$newName\"\n        }\n      ],\n      \"vmsToExport\": [\n        {\n          \"name\": \"$name\",\n          \"vcdMoid\": \"$vcdMoid\",\n          \"storagePolicyId\": \"$storagePolicyId\",\n          \"networkConnections\": [\n            {\n              \"nicIndex\": 0,\n              \"macAddress\": \"$macAddress\",\n              \"addressingMode\": \"DHCP\",\n              \"ipAddress\": \"$ipAddress\",\n              \"vappNetworkName\": \"$vappNetworkName\",\n              \"isConnected\": true,\n              \"networkAdapterType\": \"$networkAdapterType\"\n            }\n          ]\n        }\n      ],\n      \"shouldPowerOnVappAfterExport\": false\n    }' \\\n    \"https://$cluster_address/api/v1/vcd/vapp/snapshot/$snapshot_id/export\"\n```\n\nThe Rubrik REST API server initiates an asynchronous job to export vApp snapshot and returns the details of the\nAsyncRequestStatus request.\n\n```bash\n{\n  \"id\": \"$requestId\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$startTime\",\n  \"endTime\": \"$endTime\",\n  \"nodeId\": \"$nodeId\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vcd/vapp/request/$requestId\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Recovering vApp objects of virtual machines\n\nTo instantly recover the specified vApp, send a POST request\nto [`/vcd/vapp/snapshot/{snapshot_id}/instant_recover`](#operation/createVappInstantRecoveryV1), where {snapshot_id} is\nthe ID assigned to the vApp snapshot object.\n\n```bash\n    curl -X POST -d \\\n    '{\n      \"vmsToRestore\": [\n        {\n          \"name\": \"$name\",\n          \"vcdMoid\": \"$vcdMoid\",\n          \"storagePolicyId\": \"$storagePolicyId\",\n          \"networkConnections\": [\n            {\n              \"nicIndex\": 0,\n              \"macAddress\": \"$macAddress\",\n              \"addressingMode\": \"DHCP\",\n              \"ipAddress\": \"$ipAddress\",\n              \"vappNetworkName\": \"$vappNetworkName\",\n              \"isConnected\": true,\n              \"networkAdapterType\": \"$networkAdapterType\"\n            }\n          ]\n        }\n      ],\n      \"shouldPowerOnVmsAfterRecovery\": false\n    }' \\\n    \"https://$cluster_address/api/v1/vcd/vapp/snapshot/$snapshot_id/instant_recover\"\n```\n\nThe Rubrik REST API server initiates an asynchronous job to Instant Recover vApp snapshot and returns the details of the\nAsyncRequestStatus request.\n\n```bash\n{\n  \"id\": \"$requestId\",\n  \"status\": \"$status\",\n  \"progress\": 0,\n  \"startTime\": \"$startTime\",\n  \"endTime\": \"$endTime\",\n  \"nodeId\": \"$nodeId\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vcd/vapp/request/$requestId\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Retrieving Instant Recovery information\n\nTo retrieve the available vApp network connections and the default vApp network connection for the virtual machines in a\nvApp snapshot, send a GET request\nto [`/vcd/vapp/snapshot/{snapshot_id}/instant_recover/options`](#operation/getVappSnapshotInstantRecoveryOptionsV1),\nwhere {snapshot_id} is the ID of the vApp snapshot object.\n\n```bash\n    curl -X GET -d \"https://$cluster_address/api/v1/vcd/vapp/snapshot/$snapshot_id/instant_recover/options\"\n```\n\nThe Rubrik REST API server fetches VappInstantRecoveryOptions for the specified snapshot.\n\n```bash\n{\n  \"restorableVms\": [\n    {\n      \"name\": \"$name\",\n      \"vcdMoid\": \"$vcdMoid\",\n      \"storagePolicyId\": \"$storagePolicyId\",\n      \"networkConnections\": [\n        {\n          \"nicIndex\": 0,\n          \"macAddress\": \"$macAddress\",\n          \"addressingMode\": \"DHCP\",\n          \"ipAddress\": \"$ipAddress\",\n          \"vappNetworkName\": \"$vappNetworkName\",\n          \"isConnected\": true,\n          \"networkAdapterType\": \"$networkAdapterType\"\n        }\n      ]\n    }\n  ],\n  \"availableVappNetworks\": [\n    {\n      \"name\": \"$name\",\n      \"parentNetworkId\": \"$parentNetworkId\",\n      \"isDeployed\": true\n    }\n  ]\n}\n```\n\n### Retrieving vApp job status\n\nTo retrieves the details of a specified asynchronous job for a vApp, send a GET request\nto [`/vcd/vapp/request/{id}`](#operation/getVappAsyncRequestStatusV1), where {id} is the ID assigned to an asynchronous\njob.\n\n```bash\n    curl -X GET -d \"https://$cluster_address/api/v1/vcd/vapp/request/{id}\"\n```\n\nThe Rubrik REST API server fetches status of a vApp asynchronous job (AsyncRequestStatus).\n\n```bash\n{\n  \"id\": \"$requestId\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$startTime\",\n  \"endTime\": \"$endTime\",\n  \"nodeId\": \"$nodeId\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vcd/vapp/request/$requestId\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Searching for a file in a vApp snapshot\n\nTo search for a file through snapshots of all virtual machines that are part of the vApp, send a GET request\nto [`/vcd/vapp/{id}/search`](#operation/searchVappV1), where {id} is the ID of the vApp. It also requires a `path`\nparameter. The parameter takes either a path prefix or a filename prefix.\n\n```bash\n    curl -X GET -d \"https://$cluster_address/api/v1/vcd/vapp/$id/search/options?path=$path\"\n```\n\nThe Rubrik REST API server searches a file through snapshots of all virtual machines and returns list of \nAppSearchResponse.\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"path\": \"$path\",\n      \"filename\": \"$filename\",\n      \"fileVersions\": [\n        {\n          \"lastModified\": \"$lastModified\",\n          \"size\": 0,\n          \"snapshotId\": \"$snapshotId\",\n          \"fileMode\": \"$fileMode\",\n          \"source\": \"$source\"\n        }\n      ],\n      \"childObjectId\": \"$childObjectId\",\n      \"childObjectName\": \"$childObjectName\"\n    }\n  ],\n  \"total\": 0\n}\n```\n\n### Downloading snapshot from archive\n\nTo retrieve a snapshot that is not available locally, from an archival location, send a POST request\nto [`/vcd/vapp/snapshot/{id}/download`](#operation/createVcdVappDownloadSnapshotFromCloudV1)z where {id} is the ID of\nthe snapshot which needs to be downloaded.\n\n```bash\n    curl -X POST -d \"https://$cluster_address/api/v1/vcd/vapp/snapshot/$id/download\"\n```\n\nThe Rubrik REST API server initiates an asynchronous job to download vApp snapshot from archive and returns the \ndetails of the AsyncRequestStatus request.\n\n```bash\n{\n  \"id\": \"$requestId\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$startTime\",\n  \"endTime\": \"$endTime\",\n  \"nodeId\": \"$nodeId\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vcd/vapp/request/$requestId\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Retrieving summary for all vCD Clusters\n\nTo retrieve the summary information for all vCD cluster objects, send a GET request\nto [`/vcd/cluster`](#operation/queryVcdClusterV1). The parameters described in the following table are available to\nfilter the results of the GET request.\n\n| Name       | Required | Type   | Description |\n| ---------- | -------- | ------ | ----------- |\n|`name`      | Optional | string | Search for a vCD Cluster object by name.|\n|`status`    | Optional | string | Filter the results using the status value of the vCD Cluster objects.|\n|`sort_by`   | Optional | string | Attribute to sort the results on.|\n|`sort_order`| Optional | string | Order for sorting the results, either ascending or descending.|\n\n```bash\n    curl -X GET -d \"https://$cluster_address/api/v1/vcd/cluster\"\n```\n\nThe Rubrik REST API server fetches VcdClusterSummary for all vCD instances on the Rubrik cluster.\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"$id\",\n      \"name\": \"$name\",\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"configuredSlaDomainName\": \"Inherit\",\n      \"configuredSlaDomainType\": \"ProtectionSla\",\n      \"primaryClusterId\": \"$primaryClusterId\",\n      \"isConfiguredSlaDomainRetentionLocked\": true,\n      \"slaLastUpdateTime\": \"$slaLastUpdateTime\",\n      \"hostname\": \"$hostname\",\n      \"username\": \"$username\",\n      \"caCerts\": \"$caCerts\",\n      \"connectionStatus\": {\n        \"status\": \"Disconnected\",\n        \"message\": \"string\"\n      }\n    }\n  ],\n  \"total\": 0\n}\n```\n\n### Adding a vCD Cluster\n\nTo create a vCD Cluster object by providing the address of the vCD Cluster and the credentials for an account on the\nvCD Cluster that has administrator privileges, send a POST request to [`/vcd/cluster`](#operation/createVcdClusterV1).\n\n```bash\n    curl -X POST -d \\\n    '{\n      \"hostname\": \"$hostname\",\n      \"username\": \"$username\",\n      \"caCerts\": \"$caCerts\",\n      \"password\": \"$password\"\n    }' \\\n    \"https://$cluster_address/api/v1/vcd/cluster\"\n```\n\nThe Rubrik REST API server attempts to add vCD to the Rubrik cluster and returns AsyncRequestStatus of request.\n\n```bash\n{\n  \"id\": \"$requestId\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$startTime\",\n  \"endTime\": \"$endTime\",\n  \"nodeId\": \"$nodeId\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vcd/cluster/request/$requestId\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Retrieving VimServers of a vCD Cluster\n\nTo retrieve the VimServer representation of the vCenter Servers that are attached to a specified vCD Cluster object,\nsend a GET request to [`/vcd/cluster/{id}/vimserver`](#operation/queryVcdVimServerV1), where {id} is the ID assigned to\nthe vCD cluster. It also need two parameters `sort_by` and `sort_order` which decide the order of the results.\n\n```bash\n    curl -X GET -d \"https://$cluster_address/api/v1/vcd/cluster/$id/vimserver\"\n```\n\nThe Rubrik REST API server fetches VimserverSummary for all Vim servers belonging to a vCD.\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"$id\",\n      \"name\": \"$name\",\n      \"vcenterId\": \"$vcenterId\",\n      \"vcdClusterId\": \"$vcdClusterId\",\n      \"vcdClusterName\": \"$vcdClusterName\",\n      \"hostname\": \"$hostname\",\n      \"connectionStatus\": {\n        \"status\": \"Disconnected\",\n        \"message\": \"string\"\n      }\n    }\n  ],\n  \"total\": 0\n}\n```\n\n### Refreshing a vCD Cluster\n\nTo refresh the metadata for a specified vCD Cluster object, send a POST request\nto [`/vcd/cluster/{id}/refresh`](#operation/refreshVcdClusterV1), where {id} is the ID assigned to a vCD Cluster object.\n\n```bash\n    curl -X POST -d \"https://$cluster_address/api/v1/vcd/cluster/$id/refresh\"\n```\n\nThe Rubrik REST API server initiates an asynchronous job to refresh a vCD and returns the\ndetails of the AsyncRequestStatus request.\n\n```bash\n{\n  \"id\": \"$requestId\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$startTime\",\n  \"endTime\": \"$endTime\",\n  \"nodeId\": \"$nodeId\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vcd/cluster/request/$requestId\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Retrieving vCD Cluster details\n\nTo retrieve detailed information for a vCD Cluster object, send a GET request\nto [`/vcd/cluster/{id}`](#operation/getVcdClusterV1), where {id} is the ID assigned to a vCD Cluster object.\n\n```bash\n    curl -X GET -d \"https://$cluster_address/api/v1/vcd/cluster/{id}\"\n```\n\nThe Rubrik REST API server fetches VcdClusterDetail for the specified vCD instance.\n\n```bash\n{\n  \"id\": \"$id\",\n  \"name\": \"$name\",\n  \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n  \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n  \"configuredSlaDomainType\": \"ProtectionSla\",\n  \"primaryClusterId\": \"$primaryClusterId\",\n  \"isConfiguredSlaDomainRetentionLocked\": true,\n  \"slaLastUpdateTime\": \"$slaLastUpdateTime\",\n  \"hostname\": \"$hostname\",\n  \"username\": \"$username\",\n  \"caCerts\": \"$caCerts\",\n  \"connectionStatus\": {\n    \"status\": \"Disconnected\",\n    \"message\": \"string\"\n  }\n}\n```\n\n### Changing vCD Cluster object\n\nTo modify the hostname and credentials of a specified vCD Cluster object, send a PATCH request\nto [`/vcd/cluster/{id}`](#operation/updateVcdClusterV1), where {id} is the ID assigned to a vCD Cluster object. It also\nrequires a parameter named `patch_properties` which contains the updated hostname and credentials for a specified vCD\nCluster object.\n\n```bash\n    curl -X PATCH -d \\\n    '{\n      \"hostname\": \"$hostname\",\n      \"username\": \"$username\",\n      \"password\": \"$password\",\n      \"caCerts\": \"$caCerts\",\n      \"configuredSlaDomainId\": \"$configuredSlaDomainId\"\n    }' \\\n    \"https://$cluster_address/api/v1/vcd/cluster/{id}\"\n```\n\nThe Rubrik REST API server updates and fetches the updated VcdClusterDetail for the specified vCD instance.\n\n```bash\n{\n  \"id\": \"$id\",\n  \"name\": \"$name\",\n  \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n  \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n  \"configuredSlaDomainType\": \"ProtectionSla\",\n  \"primaryClusterId\": \"$primaryClusterId\",\n  \"isConfiguredSlaDomainRetentionLocked\": true,\n  \"slaLastUpdateTime\": \"$slaLastUpdateTime\",\n  \"hostname\": \"$hostname\",\n  \"username\": \"$username\",\n  \"caCerts\": \"$caCerts\",\n  \"connectionStatus\": {\n    \"status\": \"Disconnected\",\n    \"message\": \"string\"\n  }\n}\n```\n\n### Removing a vCD Cluster\n\nTo remove a vCD Cluster object, send a DELETE request to [`/vcd/cluster/{id}`](#operation/deleteVcdClusterV1), where\n{id} is the ID of assigned to a vCD Cluster object.\n\n```bash\n    curl -X DELETE -d \"https://$cluster_address/api/v1/vcd/cluster/{id}\"\n```\n\nThe Rubrik REST API server initiates an asynchronous job to delete a vCD instance and returns the\ndetails of the AsyncRequestStatus request.\n\n```bash\n{\n  \"id\": \"$requestId\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$startTime\",\n  \"endTime\": \"$endTime\",\n  \"nodeId\": \"$nodeId\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vcd/cluster/request/$requestId\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Retrieving details of jobs on vCD cluster\n\nTo retrieve the details of a specified asynchronous job for a vCD Cluster, send a GET request\nto [`/vcd/cluster/request/{id}`](#operation/getVcdClusterAsyncRequestStatusV1), where {id} is the ID assigned to an\nasynchronous job.\n\n```bash\n    curl -X GET -d \"https://$cluster_address/api/v1/vcd/cluster/request/{id}\"\n```\n\nThe Rubrik REST API server fetches details of the specifed asynchronous job and returns the AsyncRequestStatus request.\n\n```bash\n{\n  \"id\": \"$requestId\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$startTime\",\n  \"endTime\": \"$endTime\",\n  \"nodeId\": \"$nodeId\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vcd/cluster/request/$requestId\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Retrieving summary of a vCD hierarchy object\n\nTo retrieve details of the specified object in the vCD hierarchy, send a GET request\nto [`/vcd/hierarchy/{id}`](#operation/getVcdHierarchyObjectV1), where {id} is the ID of the vCD hierarchy object.\n\n```bash\n    curl -X GET -d \"https://$cluster_address/api/v1/vcd/hierarchy/{id}\"\n```\n\nThe Rubrik REST API server fetches VcdHierarchyObjectSummary for the specified vCD object.\n\n```bash\n{\n  \"id\": \"$id\",\n  \"name\": \"$name\",\n  \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n  \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n  \"configuredSlaDomainType\": \"$configuredSlaDomainType\",\n  \"primaryClusterId\": \"$primaryClusterId\",\n  \"isConfiguredSlaDomainRetentionLocked\": true,\n  \"slaLastUpdateTime\": \"$slaLastUpdateTime\",\n  \"effectiveSlaDomainId\": \"UNPROTECTED\",\n  \"effectiveSlaDomainName\": \"Unprotected\",\n  \"isEffectiveSlaDomainRetentionLocked\": true,\n  \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",\n  \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",\n  \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",\n  \"slaAssignment\": \"Derived\",\n  \"retentionSlaDomainId\": \"$retentionSlaDomainId\",\n  \"infraPath\": [\n    ...\n  ],\n  \"slaPath\": [\n    ...\n  ],\n  \"isRelic\": true,\n  \"isDeleted\": true,\n  \"objectType\": \"Cluster\",\n  \"descendantCount\": {\n    \"vcdCluster\": 0,\n    \"connectedVimServer\": 0,\n    \"disconnectedVimServer\": 0,\n    \"org\": 0,\n    \"orgVdc\": 0,\n    \"catalog\": 0,\n    \"vApp\": 0\n  },\n  \"connectionStatus\": {\n    \"status\": \"Disconnected\",\n    \"message\": \"string\"\n  },\n  \"ipAddress\": \"$ipAddress\",\n  \"vcenterId\": \"$vcenterId\",\n  \"extendedAttributes\": {\n    \"vappAtributes\": {\n      \"isVappTemplate\": true\n    }\n  },\n  \"pendingSlaDomain\": {\n    \"objectId\": \"$objectId\",\n    \"pendingSlaDomainId\": \"$pendingSlaDomainId\",\n    \"pendingSlaDomainName\": \"$pendingSlaDomainName\",\n    \"isPendingSlaDomainRetentionLocked\": true\n  }\n}\n```\n\n### Retrieving immediate descendant objects\n\nTo retrieve the list of immediate descendant objects for the specified parent, send a GET request\nto [`/vcd/hierarchy/{id}/children`](#operation/getVcdHierarchyChildrenV1), where {id} is the ID of the parent vCD\nhierarchy object. The parameters described in the following table are available to filter the results of the GET\nrequest.\n\n| Name                    | Required | Type    | Description |\n| ----------------------- | -------- | ------- | ----------- |\n|`id`                     | Required | string  | ID of the parent vCD hierarchy object. To get top-level nodes, use **root** as the ID.|\n|`sort_by`                | Optional | string  | Attribute to sort the results on.|\n|`sort_order`             | Optional | string  | Order for sorting the results, either ascending or descending.|\n|`limit`                  | Optional | int     | Limit the number of matches returned.|\n|`offset`                 | Optional | int     | Number of matches to ignore from the beginning of the results.|\n|`name`                   | Optional | string  | Search object by object name.|\n|`is_relic`               | Optional | boolean | Filter by isRelic field of vCD vApp hierarchy object. Return both relic and non-relic children when this value is not specified.|\n|`effective_sla_domain_id`| Optional | string  | Filter by ID of effective SLA domain.|\n|`object_type`            | Optional | string  | Filter by node object type. |\n|`primary_cluster_id`     | Optional | string  | Filter by primary cluster ID, or **local**.|\n|`sla_assignment`         | Optional | string  | Filter by SLA assignment type.|\n|`snappable_status`       | Optional | string  | Filters vCD hierarchy objects based on the specified query value.|\n\n```bash\n    curl -X GET -d \"https://$cluster_address/api/v1/vcd/hierarchy/$id/children\"\n```\n\nThe Rubrik REST API server fetches VcdHierarchyObjectSummary for all children (immediate descendants) \nof the specified vCD object.\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"$id\",\n      \"name\": \"$name\",\n      \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n      \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n      \"configuredSlaDomainType\": \"$configuredSlaDomainType\",\n      \"primaryClusterId\": \"$primaryClusterId\",\n      \"isConfiguredSlaDomainRetentionLocked\": true,\n      \"slaLastUpdateTime\": \"$slaLastUpdateTime\",\n      \"effectiveSlaDomainId\": \"UNPROTECTED\",\n      \"effectiveSlaDomainName\": \"Unprotected\",\n      \"isEffectiveSlaDomainRetentionLocked\": true,\n      \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",\n      \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",\n      \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",\n      \"slaAssignment\": \"Derived\",\n      \"retentionSlaDomainId\": \"$retentionSlaDomainId\",\n      \"infraPath\": [\n        ...\n      ],\n      \"slaPath\": [\n        ...\n      ],\n      \"isRelic\": true,\n      \"isDeleted\": true,\n      \"objectType\": \"Cluster\",\n      \"descendantCount\": {\n        \"vcdCluster\": 0,\n        \"connectedVimServer\": 0,\n        \"disconnectedVimServer\": 0,\n        \"org\": 0,\n        \"orgVdc\": 0,\n        \"catalog\": 0,\n        \"vApp\": 0\n      },\n      \"connectionStatus\": {\n        \"status\": \"Disconnected\",\n        \"message\": \"string\"\n      },\n      \"ipAddress\": \"$ipAddress\",\n      \"vcenterId\": \"$vcenterId\",\n      \"extendedAttributes\": {\n        \"vappAtributes\": {\n          \"isVappTemplate\": true\n        }\n      },\n      \"pendingSlaDomain\": {\n        \"objectId\": \"$objectId\",\n        \"pendingSlaDomainId\": \"$pendingSlaDomainId\",\n        \"pendingSlaDomainName\": \"$pendingSlaDomainName\",\n        \"isPendingSlaDomainRetentionLocked\": true\n      }\n    }\n  ],\n  \"total\": 0\n}\n```\n\n### Retrieving list of descendant objects\n\nTo retrieve the list of descendant objects for the specified parent, send a GET request to\n[`/vcd/hierarchy/{id}/descendants`](#operation/getVcdHierarchyDescendantsV1), where {id} is the ID of the parent vCD\nhierarchy object. The parameters described in the following table are available to filter the results of the GET\nrequest.\n\n| Name                    | Required | Type    | Description |\n| ----------------------- | -------- | ------- | ----------- |\n|`id`                     | Required | string  | ID of the parent vCD hierarchy object. To get top-level nodes, use **root** as the ID.|\n|`sort_by`                | Optional | string  | Attribute to sort the results on.|\n|`sort_order`             | Optional | string  | Order for sorting the results, either ascending or descending.|\n|`limit`                  | Optional | int     | Limit the number of matches returned.|\n|`offset`                 | Optional | int     | Number of matches to ignore from the beginning of the results.|\n|`name`                   | Optional | string  | Search object by object name.|\n|`is_relic`               | Optional | boolean | Filter by isRelic field of vCD vApp hierarchy object. Return both relic and non-relic children when this value is not specified.|\n|`effective_sla_domain_id`| Optional | string  | Filter by ID of effective SLA domain.|\n|`object_type`            | Optional | string  | Filter by node object type. |\n|`primary_cluster_id`     | Optional | string  | Filter by primary cluster ID, or **local**.|\n|`sla_assignment`         | Optional | string  | Filter by SLA assignment type.|\n|`snappable_status`       | Optional | string  | Filters vCD hierarchy objects based on the specified query value.|\n\n```bash\n    curl -X GET -d \"https://$cluster_address/api/v1/vcd/hierarchy/$id/descendants\"\n```\n\nThe Rubrik REST API server fetches VcdHierarchyObjectSummary for all descendants of specified vCD object.\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"$id\",\n      \"name\": \"$name\",\n      \"configuredSlaDomainId\": \"$configuredSlaDomainId\",\n      \"configuredSlaDomainName\": \"$configuredSlaDomainName\",\n      \"configuredSlaDomainType\": \"$configuredSlaDomainType\",\n      \"primaryClusterId\": \"$primaryClusterId\",\n      \"isConfiguredSlaDomainRetentionLocked\": true,\n      \"slaLastUpdateTime\": \"$slaLastUpdateTime\",\n      \"effectiveSlaDomainId\": \"UNPROTECTED\",\n      \"effectiveSlaDomainName\": \"Unprotected\",\n      \"isEffectiveSlaDomainRetentionLocked\": true,\n      \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",\n      \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",\n      \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",\n      \"slaAssignment\": \"Derived\",\n      \"retentionSlaDomainId\": \"$retentionSlaDomainId\",\n      \"infraPath\": [\n        ...\n      ],\n      \"slaPath\": [\n        ...\n      ],\n      \"isRelic\": true,\n      \"isDeleted\": true,\n      \"objectType\": \"Cluster\",\n      \"descendantCount\": {\n        \"vcdCluster\": 0,\n        \"connectedVimServer\": 0,\n        \"disconnectedVimServer\": 0,\n        \"org\": 0,\n        \"orgVdc\": 0,\n        \"catalog\": 0,\n        \"vApp\": 0\n      },\n      \"connectionStatus\": {\n        \"status\": \"Disconnected\",\n        \"message\": \"string\"\n      },\n      \"ipAddress\": \"$ipAddress\",\n      \"vcenterId\": \"$vcenterId\",\n      \"extendedAttributes\": {\n        \"vappAtributes\": {\n          \"isVappTemplate\": true\n        }\n      },\n      \"pendingSlaDomain\": {\n        \"objectId\": \"$objectId\",\n        \"pendingSlaDomainId\": \"$pendingSlaDomainId\",\n        \"pendingSlaDomainName\": \"$pendingSlaDomainName\",\n        \"isPendingSlaDomainRetentionLocked\": true\n      }\n    }\n  ],\n  \"total\": 0\n}\n```\n\n# Blackout Windows\n\n## Get Global Blackout Window Status\nSend a GET request to ['/blackout_window`](#operation/getBlackoutWindowStatus)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/blackout_window\"\n```\n\n## Start or Stop the Global Blackout Window in local Rubrik Cluster\nSend a PATCH request to [`/blackout_window`](#operation/toggleBlackoutWindow)\n\n```bash\ncurl -X PATCH \\\n  -d '{ \\\n   \"isGlobalBlackoutActive\": true \\\n   }' \\\n  \"https://$cluster_address/api/v1/blackout_window\"\n```\n\n# Managed Volumes\n\n## Create Script to Unify Managed Volume Export View\n\nTo request an asynchronous job to generate a script to create a directory to view all files in all channels of a managed volume export, send a POST request to the [`/managed_volume/snapshot/export/{id}/script`](#operation/createManagedVolumeGenerateScriptJob) endpoint with the ID of the snapshot export.\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/managed_volume/snapshot/export/{id}/script\"\n```\nAn asynchronous request is returned and can be polled to retrieve the job status.\n\n```bash\n{\n  \"id\":\"$request_id\",\n  \"links\": [\n    {\n      \"href\":\"https://$cluster_address/api/v1/managed_volume/request/$request_id\",\n      \"rel\":\"result\"\n    },\n  \"status\":\"QUEUED\"\n}\n```\n\n# Archival\n\n## Create Script to Refresh data sources in a Reader location\n\nSend a POST request to the [`/archive/location/{location_id}/reader/refresh/data_sources`](#operation/refreshArchivalLocationDataSources) endpoint to request an asynchronous job that refreshes the metadata for a list of data sources from a specified reader location. The POST request must provide the ID of the reader location and a list of the IDs of the data sources in the archival location.\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/archive/location/{location_id}/reader/refresh/data_sources\"\n```\nAn asynchronous request is returned and can be polled to retrieve the job status.\n\n```bash\n{\n  \"id\":\"$request_id\",\n  \"links\": [\n    {\n      \"href\":\"https://$cluster_address/api/v1/archive/request/$request_id\",\n      \"rel\":\"result\"\n    },\n  \"status\":\"QUEUED\"\n}\n```\n\n## Get the ID of the customer AWS account that owns the archival location\n\nSend a GET request to the [`/archive/aws/s3/{id}/account_id`](#operation/getAwsAccountId) endpoint to request the ID of the AWS customer account for the S3 archival location. Returns an error when the location given is not an AWS S3 archival location.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/archive/aws/s3/{id}/account_id\"\n```\nReturns the ID of the AWS account.\n\n## Disable archival location for archiving and modifications.\n\nSend a POST request to the [`/archive/location/{location_id}/owner/disable`](#operation/disableArchivalLocation) endpoint to disable the specified active archival location. The POST request must include the ID of the active location.\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/archive/location/{location_id}/owner/disable\"\n```\nReturns empty response body\n\n## Enable archival location for archiving and modifications.\n\nSend a POST request to the [`/archive/location/{location_id}/owner/enable`](#operation/enableArchivalLocation) endpoint to enable archiving and other\noperations that were previously disabled on the specified archival location\nwith the disable operation. The POST request must include the ID of the\nspecified location.\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/archive/location/{location_id}/owner/enable\"\n```\nReturns empty response body\n\n# Replication\n\n## Enable Source Specific Replication Pause\nSend a POST request to [`/replication/location_pause/enable`]\n(#operation/enablePerLocationPause)\n\n```bash\ncurl -X POST \\\n  -d '{ \\\n   \"sourceClusterUuids\": [\"510ae3f4-d733-4545-9ea4-fe702401fdca\"], \\\n   \"shouldCancelImmediately\": true \\\n   }' \\\n  \"https://$cluster_address/api/v1/replication/location_pause/enable\"\n```\n\n## Disable Source Specific Replication Pause\nSend a POST request to [`/replication/location_pause/disable`]\n(#operation/disablePerLocationPause)\n\n```bash\ncurl -X POST \\\n  -d '{ \\\n   \"sourceClusterUuids\": [\"510ae3f4-d733-4545-9ea4-fe702401fdca\"], \\\n   \"shouldSkipOldSnapshots\": true \\\n   }' \\\n  \"https://$cluster_address/api/v1/replication/location_pause/disable\"\n```\n\n# Unmanaged object\n\nAn unmanaged object is an object that is not currently assigned\nan active SLA.\n\n### Get all unmanaged reader object summaries\nGet a listing of all unmanaged reader object summaries using\na GET request to\n[/unmanaged_object/reader_object](#operation/queryUnmanagedReaderObject).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/unmanaged_object/reader_object\"\n```\nThe Rubrik REST API server returns a `ListResponse` object of unmanaged\nreader object summaries.\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"$vm1_managed_id\",\n      \"name\": \"$vm1_name\",\n      \"objectType\": \"VirtualMachine\",\n      \"physicalLocation\": [\n        {\n          \"managedId\": \"$location1_managed_id\",\n          \"name\": \"$location1_name\"\n        }\n      ],\n      \"unmanagedStatus\": \"Unprotected\",\n      \"autoSnapshotCount\": 20,\n      \"manualSnapshotCount\": 0,\n      \"localStorage\": 100,\n      \"archiveStorage\": 0,\n      \"retentionSlaDomainId\": \"$gold_sla_id\",\n      \"retentionSlaDomainName\": \"Gold\"\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n### Get all unmanaged object summaries\nGet a list of all objects with unmanaged snapshots using\na GET request to\n[/unmanaged_object](#operation/queryUnmanagedObjectV1).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/unmanaged_object\"\n```\nThe Rubrik REST API server returns a `ListResponse` object of objects with\n unmanaged snapshots.\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"$vm1_managed_id\",\n      \"name\": \"$vm1_name\",\n      \"objectType\": \"VirtualMachine\",\n      \"physicalLocation\": [\n        {\n          \"managedId\": \"$location1_managed_id\",\n          \"name\": \"$location1_name\"\n        }\n      ],\n      \"unmanagedStatus\": \"Unprotected\",\n      \"snapshotCount\": 20,\n      \"localStorage\": 100,\n      \"archiveStorage\": 0,\n      \"retentionSlaDomainId\": \"$gold_sla_id\",\n      \"retentionSlaDomainName\": \"Gold\"\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\n### Get summary of all snapshots for a given object\nGet summary of all snapshots for a given object using\na GET request to\n[/unmanaged_object/{id}/snapshot](#operation/queryUnmanagedObjectSnapshotsV1).\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/unmanaged_object/{id}/snapshot\"\n```\nThe Rubrik REST API server return a `ListResponse` object of snapshot summaries\nfor the given object.\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"$snapshot_id\",\n      \"date\": \"<timestamp>\",\n      \"snapshotType\": \"PolicyBased\",\n      \"snapshotRetentionInfo\": {\n        \"localInfo\": {\n          \"id\": \"location_id\",\n          \"name\": \"local_cluster\",\n          \"isSnapshotPresent\": true,\n          \"isExpirationDateCalculated\": true,\n          \"expirationTime\": \"<timestamp2>\"\n        },\n        \"archivalInfos\": [],\n        \"replicationInfos\": []\n      }\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\n### Assign a retention SLA to unmanaged object.\nAssign a retention SLA to an unmanaged object to expire existing snapshots\nin a structured manner.\n\nSend a POST request to [/unmanaged_object/assign_retention_sla](#operation/assignToRetentionSlaAsync).\n\n**Example:** Assigning a retention SLA Domain with ID $slaId to a list of unmanaged objects - $snap1Id, $snap2Id\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"slaDomainId\": $slaId,\n    \"managedIds\": [$snap1Id, $snap2Id]\n  }' \\\n  \"https://$cluster_address/api/v1/unmanaged_object/assign_retention_sla\"\n```\n\n### Bulk tier existing snapshots to cold storage\nSchedules a job to tier existing snapshots of the selected objects to cold\nstorage.\n\nSend a POST request to\n[/unmanaged_object/snapshot/bulk_archive_tier](#operation/bulkTierExistingSnapshots)\n\n**Example:** Tier existing snapshots for the objects - $object1Id, $object2Id\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"objectIds\": [$object1Id, $object2Id]\n  }' \\\n  \"https://$cluster_address/api/v1/unmanaged_object/snapshot/bulk_archive_tier\"\n```\n\n**Example:** Tier existing snapshots for the objects - $object1Id, $object2Id\nonly in archival location $archivalLocationId\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"objectIds\": [$object1Id, $object2Id],\n    \"locationId\": $archivalLocationId\n  }' \\\n  \"https://$cluster_address/api/v1/unmanaged_object/snapshot/bulk_archive_tier\"\n\nAn asynchronous request is returned and can be polled to retrieve the job status.\n\n```bash\n{\n  \"id\":\"$request_id\",\n  \"links\": [\n    {\n      \"href\":\"https://$cluster_address/api/v1/unmanaged_object/snapshot/bulk_archive_tier/request/$request_id\",\n      \"rel\":\"result\"\n    },\n  \"status\":\"QUEUED\"\n}\n```\n\n# Data Source\n\nA data source is an object whose snapshots can be taken.\n\n### Delete given snapshots for an object\nDelete snapshots identified by the given snapshot IDs for\nthe specified object using a POST request to\n[\n`/data_source/{id}/snapshot/bulk_delete`\n](#operation/bulkDeleteSnapshotsForObject).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/data_source/{id}/snapshot/bulk_delete\"\n```\n\n### Delete all snapshots for given objects\nDelete all snapshots for given objects using\na POST request to\n[`/data_source/snapshot/bulk_delete`](#operation/bulkDeleteSnapshots).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/data_source/snapshot/bulk_delete\"\n```\n\n### Get information of expired snapshots which were explicitly assigned a SLA domain\nTo get information on snapshots that expired according to their assigned\nSLA domain, send a GET request to\n[`/data_source/{id}/expired_custom_retention_snapshots`](#operation/expiredCustomRetentionSnapshots).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/data_source/{id}/expired_custom_retention_snapshots\"\n```\n\n# SAP HANA databases\n\n## Get SAP HANA database summary\n\nRequest a list of SAP HANA discovered databases by sending a GET\nrequest to [`/sap_hana/db`](#operation/querySapHanaDatabases).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/sap_hana/db\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"$db_id\",\n      \"name\": \"$db_name\",\n      \"dbStatus\": \"ACTIVE\",\n      \"dbType\": \"TENANT\",\n      \"dataPathType\": \"GCP\"\n      \"logBackupJobFrequencyMins\": 30\n      \"sapHanaSystemId\": \"$sap_hana_system_id\",\n      \"sid\": \"SC1\",\n      \"instanceNumber\": \"03\",\n      \"primaryClusterId\": \"$cluster_id\",\n      \"isRelic\": False,\n      \"isArchived\": False\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\nFurther details are acquired from\n[`/sap_hana/db/{id}`](#operation/getSapHanaDatabase).\n\n```\ncurl -X GET \"https://$cluster_address/api/v1/sap_hana/db/$db_id\"\n```\n\n```bash\n{\n      \"id\": \"$db_id\",\n      \"name\": \"$db_name\",\n      \"dbStatus\": \"ACTIVE\",\n      \"dbType\": \"TENANT\",\n      \"dataPathType\": \"GCP\"\n      \"logBackupJobFrequencyMins\": 30\n      \"sapHanaSystemId\": \"$sap_hana_system_id\",\n      \"sid\": \"SC1\",\n      \"instanceNumber\": \"03\",\n      \"primaryClusterId\": \"$cluster_id\",\n      \"isRelic\": False,\n      \"isArchived\": False,\n      \"previousFailedBackupPrefixes\": [\n        \"abcd\", \"defg\"\n      ],\n      \"snapShotCount\": 3\n}\n```\n\nUpdate SLA Domain assigned to SAP HANA database by using\n[`/sap_hana/db/{id}`](#operation/patchSapHanaDatabase). The API returns with\nthe summary of the SAP HANA database.\n\n```bash\ncurl -X PATCH \"https://$cluster_address/api/v1/sap_hana/db/$db_id\"\n```\n\n```bash\n{\n      \"id\": \"$db_id\",\n      \"name\": \"$db_name\",\n      \"dbStatus\": \"ACTIVE\",\n      \"dbType\": \"TENANT\",\n      \"dataPathType\": \"GCP\"\n      \"logBackupJobFrequencyMins\": 30\n      \"sapHanaSystemId\": \"$sap_hana_system_id\",\n      \"sid\": \"SC1\",\n      \"instanceNumber\": \"03\",\n      \"primaryClusterId\": \"$cluster_id\",\n      \"isRelic\": False,\n      \"isArchived\": False,\n      \"previousFailedBackupPrefixes\": [\n        \"abcd\", \"defg\"\n      ],\n      \"snapShotCount\": 3\n}\n```\n\n## System copy restore\n\nSystem copy restore is a type of restore that is used across different SAP HANA\ndatabases.\n\n### Configuring system copy restore\n\nTo initiate a task to configure a system copy restore on a SAP HANA database,\nsend a POST request to [`/sap_hana/db/{id}/configure_restore`](#operation/configureSapHanaRestore)\nwhere, {id} is the ID of the target SAP HANA database.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"source_config\": {\n        \"snappable_id\": \"$source_db_id\"\n      }\n    }' \\\n\"https://$cluster_address/api/v1/sap_hana/db/$target_db_id/configure_restore\"\n```\n\nThe Rubrik REST API server initiates the configuration task and responds with a\nrequest object.\n\n```bash\n{\n      \"id\": \"$request_id\",\n      \"status\": \"QUEUED\",\n      \"error\": \"None\",\n      \"progress\": 0,\n      \"startTime\": \"$start_timestamp\",\n      \"endTime\": \"$end_timestamp\",\n      \"links\": [\n        {\n          \"href\": \"https://$cluster_address/api/v1/sap_hana/db/request/$request_id\",\n          \"rel\": \"self\"\n        }\n      ]\n}\n```\n\n### Unconfiguring system copy restore\n\nTo initiate a task to reset the configuration for a system copy restore on a\nSAP HANA database, send a POST request to\n[`/sap_hana/db/{id}/unconfigure_restore`](#operation/unconfigureSapHanaRestore)\nwhere, {id} is the ID of the target SAP HANA database.\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/sap_hana/db/$target_db_id/unconfigure_restore\"\n```\nThe Rubrik REST API server initiates the task to reset the configuration for the\nsystem copy restore and responds with a request object.\n\n```bash\n{\n      \"id\": \"$request_id\",\n      \"status\": \"QUEUED\",\n      \"error\": \"None\",\n      \"progress\": 0,\n      \"startTime\": \"$start_timestamp\",\n      \"endTime\": \"$end_timestamp\",\n      \"links\": [\n        {\n          \"href\": \"https://$cluster_address/api/v1/sap_hana/db/request/$request_id\",\n          \"rel\": \"self\"\n        }\n      ]\n}\n```\n\n## SAP HANA system apis\n\nRequest a list of SAP HANA systems on a cluster by sending a GET\nrequest to [`/sap_hana/system`](#operation/querySapHanaSystems).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/sap_hana/system\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"$system_id\",\n      \"sid\": \"SC1\",\n      \"numDbs\": 3,\n      \"containerType\": \"SINGLE_CONTAINER\",\n      \"instanceNumber\": \"03\",\n      \"status\": \"OK\",\n      \"username\": \"$system_username\",\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\nAdds an entry for SAP HANA system to database. To add a SAP HANA system entry,\nsend a POST request to [`/sap_hana/system`](#operation/addSapHanaSystem).\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"username\": \"$username\",\n    \"password\": \"$password\",\n    \"sid\": \"$sid\",\n    \"instance\": \"$instance\",\n    \"hostIdList\": [\n      \"$host_id\"\n    ],\n    \"dataPathSpec\": {\n      \"$dataPathType\": \"GCP\"\n    } }' \\\n  \"https://$cluster_address/api/v1/sap_hana/system\"\n```\nThe Rubrik REST API server responds with the ID of the added SAP HANA system and\nthe status of the scheduled system refresh job.\n\n```bash\n{\n      \"id\": \"$system_id\",\n      \"sid\": \"SC1\",\n      \"numDbs\": 3,\n      \"containerType\": \"SINGLE_CONTAINER\",\n      \"instanceNumber\": \"03\",\n      \"status\": \"OK\",\n      \"username\": \"$system_username\",\n}\n```\n\nFurther details are acquired by\n[`/sap_hana/system/{id}`](#operation/getSapHanaSystem).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/sap_hana/system/$db_id\"\n```\n\n```bash\n{\n      \"id\": \"$system_id\",\n      \"sid\": \"SC1\",\n      \"numDbs\": 3,\n      \"containerType\": \"SINGLE_CONTAINER\",\n      \"instanceNumber\": \"03\",\n      \"status\": \"OK\",\n      \"username\": \"$system_username\",\n}\n```\n\nUpdate the SlA Domain assigned to the SAP HANA system by calling the\n[`/sap_hana/system/{id}`](#operation/patchSapHanaSystem) endpoint. The API\nreturns the summary of the SAP HANA system.\n\n```bash\ncurl -X PATCH \"https://$cluster_address/api/v1/sap_hana/system/$db_id\"\n```\n\n```bash\n{\n      \"id\": \"$system_id\",\n      \"sid\": \"SC1\",\n      \"numDbs\": 3,\n      \"containerType\": \"SINGLE_CONTAINER\",\n      \"instanceNumber\": \"03\",\n      \"status\": \"OK\",\n      \"username\": \"$system_username\",\n}\n```\n\nDelete a SAP HANA system by calling the\n[`/sap_hana/system/{id}`](#operation/deleteSapHanaSystem) endpoint. The API\ninitiates a delete job and responds with a request object.\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/sap_hana/system/$id\"\n```\n\n```bash\n{\n      \"id\": \"$request_id\",\n      \"status\": \"RUNNING\",\n      \"error\": \"None\",\n      \"progress\": 0,\n      \"startTime\": \"$start_timestamp\",\n      \"endTime\": \"$end_timestamp\",\n      \"links\": [\n        {\n          \"href\": \"https://$cluster_address/api/v1/sap_hana/system/request/$request_id\",\n          \"rel\": \"self\"\n        }\n      ]\n}\n```\n\nUsing the information provided in the request object, send a GET request to the\n[`/sap_hana/system/request/{id}`](#operation/getSapHanaSystemAsyncRequestStatus)\nendpoint to poll the task status. When the value of `status` in the task object\nis `SUCCEEDED`, the task finished successfully.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/sap_hana/system/request/$id\"\n```\n\n```bash\n{\n      \"id\": \"$request_id\",\n      \"status\": \"SUCCEEDED\",\n      \"error\": \"None\",\n      \"progress\": 0,\n      \"startTime\": \"$start_timestamp\",\n      \"endTime\": \"$end_timestamp\",\n      \"links\": [\n        {\n          \"href\": \"https://$cluster_address/api/v1/sap_hana/system/request/$request_id\",\n          \"rel\": \"self\"\n        }\n      ]\n}\n```\n\nRefresh the metadata of a SAP HANA system object by calling the\n[`/sap_hana/system/{id}/refresh`](#operation/createSapHanaSystemRefresh)\nendpoint. The API initiates a refresh job and responds with a request object.\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/sap_hana/system/$id/refresh\"\n```\n\n```bash\n{\n      \"id\": \"$request_id\",\n      \"status\": \"RUNNING\",\n      \"error\": \"None\",\n      \"progress\": 0,\n      \"startTime\": \"$start_timestamp\",\n      \"endTime\": \"$end_timestamp\",\n      \"links\": [\n        {\n          \"href\": \"https://$cluster_address/api/v1/sap_hana/system/request/$request_id\",\n          \"rel\": \"self\"\n        }\n      ]\n}\n```\n\nCreate a full data snapshot of a SAP HANA system object by\nsending a POST request to the\n[`/sap_hana/db/{id}/snapshot`](#operation/createOnDemandSapHanaBackup)\nendpoint. The API initiates a data backup job and responds with a request\nobject.\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/sap_hana/db/{id}/snapshot\"\n```\n\n```bash\n{\n      \"id\": \"$request_id\",\n      \"status\": \"QUEUED\",\n      \"error\": \"None\",\n      \"progress\": 0,\n      \"startTime\": \"$start_timestamp\",\n      \"endTime\": \"$end_timestamp\",\n      \"links\": [\n        {\n          \"href\": \"https://$cluster_address/api/v1/sap_hana/db/request/$request_id\",\n          \"rel\": \"self\"\n        }\n      ]\n}\n```\n\nUsing the information provided in the request object, send a\nGET request to the\n[`/sap_hana/db/request/{id}`](#operation/getSapHanaDbAsyncRequestStatus))\nendpoint to poll the task status. When the value of `status` in\nthe task object is `SUCCEEDED`, the task finished successfully.\nThe response also includes the `$snapshot_id`.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/sap_hana/db/request/{id}\"\n```\n\n```bash\n{\n      \"id\": \"$request_id\",\n      \"status\": \"SUCCEEDED\",\n      \"error\": \"None\",\n      \"progress\": 0,\n      \"startTime\": \"$start_timestamp\",\n      \"endTime\": \"$end_timestamp\",\n      \"links\": [\n        {\n          \"href\": \"https://$cluster_address/api/v1/sap_hana/db/snapshot/$snapshot_id\",\n          \"rel\": \"result\"\n        },\n        {\n          \"href\": \"https://$cluster_address/api/v1/sap_hana/db/request/$request_id\",\n          \"rel\": \"self\"\n        }\n      ]\n}\n```\n\nRequest a list of summary of snapshots of a SAP HANA database by\nsending a GET request to the\n[`/sap_hana/db/{id}/snapshot`](#operation/querySapHanaDbSnapshot)\nendpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/sap_hana/db/{id}/snapshot\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"$db_id\",\n      \"date\": \"2019-12-16T23:21:53.377Z\",\n      \"sourceObjectType\": \"SapHanaDatabase\",\n      \"isOnDemandSnapshot\": true,\n      \"isCustomRetentionApplied\": false\n      \"cloudState\": 0\n      \"replicationLocationIds\": [\n        \"string\"\n      ],\n      \"archivalLocationIds\": [\n        \"string\"\n      ],\n      \"slaId\": \"string\",\n      \"slaName\": \"string\",\n      \"isRetainedByRetentionLockSla\": true,\n      \"backupId\": 949363200000,\n      \"backupType\": \"FULL\",\n      \"sapHanaStartTime\": \"2019-12-16T23:21:53.377Z\",\n      \"sapHanaEndTime\": \"2019-12-16T23:21:53.377Z\",\n      \"rubrikSnapshotStartTime\": \"2019-12-16T23:21:53.377Z\",\n      \"rubrikSnapshotEndTime\": \"2019-12-16T23:21:53.377Z\",\n      \"backupPrefix\": \"RUBRIK_949363200000_ON_DEMAND\",\n      \"isExternalBackup\": false,\n      \"isRubrikTriggeredOnDemandBackup\": false\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\nRequest SAP HANA database snapshot details by sending a\nGET request to the\n[`/sap_hana/db/snapshot/{id}`](#operation/getSapHanaDbSnapshot) endpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/sap_hana/db/snapshot/{id}\"\n```\n\n```bash\n{\n      \"isCorrupt\": false,\n      \"id\": \"$db_id\",\n      \"date\": \"2019-12-16T23:21:53.377Z\",\n      \"sourceObjectType\": \"SapHanaDatabase\",\n      \"isOnDemandSnapshot\": true,\n      \"isCustomRetentionApplied\": false\n      \"cloudState\": 0\n      \"replicationLocationIds\": [\n        \"string\"\n      ],\n      \"archivalLocationIds\": [\n        \"string\"\n      ],\n      \"slaId\": \"string\",\n      \"slaName\": \"string\",\n      \"isRetainedByRetentionLockSla\": true,\n      \"backupId\": 949363200000,\n      \"backupType\": \"FULL\",\n      \"sapHanaStartTime\": \"2019-12-16T23:21:53.377Z\",\n      \"sapHanaEndTime\": \"2019-12-16T23:21:53.377Z\",\n      \"rubrikSnapshotStartTime\": \"2019-12-16T23:21:53.377Z\",\n      \"rubrikSnapshotEndTime\": \"2019-12-16T23:21:53.377Z\",\n      \"backupPrefix\": \"RUBRIK_949363200000_ON_DEMAND\",\n      \"isExternalBackup\": false,\n      \"isRubrikTriggeredOnDemandBackup\": false\n}\n```\n\nRequest details of recoverable ranges of a SAP HANA database\nby sending a GET request to the\n[`/sap_hana/db/{id}/recoverable_range`](#operation/getSapHanaDbRecoverableRanges)\nendpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/sap_hana/db/{id}/recoverable_range\"\n```\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"beginTime\": \"2017-02-02T18:53:12.694Z\",\n      \"endTime\": \"2017-02-02T20:53:12.694Z\"\n    }\n  ],\n  \"total\": 1\n}\n```\n\nDelete a full snapshot with a DELETE request to the\n [`/sap_hana/db/snapshot/{id}`](#operation/deleteSapHanaDbSnapshot) endpoint\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/sap_hana/db/snapshot/{id}\"\n```\nRequest details of missed snapshots of a SAP HANA database\nby sending a GET request to the\n[`/sap_hana/db/{id}/missed_snapshot`](#operation/getMissedSapHanaDbSnapshots)\nendpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/sap_hana/db/{id}/missed_snapshot\"\n```\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"archivalLocationType\": [\n        \"string\"\n      ],\n      \"missedSnapshotTime\": \"2020-08-06T14:23:13.666Z\",\n      \"missedSnapshotTimeUnits\": [\n        {\n          \"timeUnit\": \"Minute\",\n          \"frequency\": 0,\n          \"retention\": 0,\n          \"dayOfTime\": \"Monday\"\n        }\n      ]\n    }\n  ],\n  \"total\": 0\n}\n```\n\n# Volume Groups\n\nRubrik clusters can protect Windows volumes on a host as a Volume Group.\n\n## Getting a list of Volume Groups\n\nTo retrieve a current list of Volume Groups, send a GET request to\n[`/volume_group`](#operation/queryVolumeGroup).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/volume_group\"\n```\n\nThe Rubrik REST API server responds with a list of summary objects\nof Volume Groups.\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"string\",\n      \"name\": \"string\",\n      \"configuredSlaDomainId\": \"string\",\n      \"configuredSlaDomainName\": \"string\",\n      \"primaryClusterId\": \"string\",\n      \"isConfiguredSlaDomainRetentionLocked\": true,\n      \"effectiveSlaDomainId\": \"string\",\n      \"effectiveSlaDomainName\": \"string\",\n      \"isEffectiveSlaDomainRetentionLocked\": true,\n      \"effectiveSlaDomainPolarisManagedId\": \"string\",\n      \"effectiveSlaSourceObjectId\": \"string\",\n      \"effectiveSlaSourceObjectName\": \"string\",\n      \"slaAssignment\": \"Derived\",\n      \"hostname\": \"string\",\n      \"hostId\": \"string\",\n      \"isRelic\": true\n    }\n  ],\n  \"total\": 0\n}\n```\n\n## Getting Volume Group Details\n\nTo retrieve the details of a Volume Group, send a GET request to\n[`/volume_group/{id}`](#operation/getVolumeGroup)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/volume_group/{id}\"\n```\n\nThe Rubrik REST API server responds with the details of the Volume Group.\n\n```bash\n{\n  \"id\": \"string\",\n  \"name\": \"string\",\n  \"configuredSlaDomainId\": \"string\",\n  \"configuredSlaDomainName\": \"string\",\n  \"primaryClusterId\": \"string\",\n  \"isConfiguredSlaDomainRetentionLocked\": true,\n  \"effectiveSlaDomainId\": \"string\",\n  \"effectiveSlaDomainName\": \"string\",\n  \"isEffectiveSlaDomainRetentionLocked\": true,\n  \"effectiveSlaDomainPolarisManagedId\": \"string\",\n  \"effectiveSlaSourceObjectId\": \"string\",\n  \"effectiveSlaSourceObjectName\": \"string\",\n  \"slaAssignment\": \"Derived\",\n  \"hostname\": \"string\",\n  \"hostId\": \"string\",\n  \"isRelic\": true,\n  \"blackoutWindowStatus\": {\n    \"isGlobalBlackoutActive\": true,\n    \"isSnappableBlackoutActive\": true\n  },\n  \"blackoutWindows\": {\n    \"globalBlackoutWindows\": [\n      {\n        \"startTime\": \"string\",\n        \"endTime\": \"string\"\n      }\n    ],\n    \"snappableBlackoutWindows\": [\n      {\n        \"startTime\": \"string\",\n        \"endTime\": \"string\"\n      }\n    ]\n  },\n  \"isPaused\": true,\n  \"volumes\": [\n    {\n      \"id\": \"string\",\n      \"fileSystemType\": \"NTFS\",\n      \"mountPoints\": [\n        \"string\"\n      ],\n      \"size\": 0,\n      \"naturalId\": \"string\",\n      \"volumeGroupId\": \"string\",\n      \"isCurrentlyPresentOnSystem\": true\n    }\n  ]\n}\n```\n\n## Patching Volume Group Details\n\nTo modify the details of a Volume Group, send a PATCH request to\n[`/volume_group/{id}`](#operation/patchVolumeGroup)\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/volume_group/{id}\"\n```\n\n## Getting a list of all snapshots of a Volume Group\n\nTo get a list of all snapshots of a Volume Group, send a GET request to\n[`/volume_group/{id}/snapshot`](#operation/queryVolumeGroupSnapshot)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/volume_group/{id}/snapshot\"\n```\n\nThe Rubrik REST API server responses with a list of snapshots of the\nVolume Group.\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"string\",\n      \"date\": \"2019-12-16T23:21:53.446Z\",\n      \"expirationDate\": \"2019-12-16T23:21:53.446Z\",\n      \"sourceObjectType\": \"string\",\n      \"isOnDemandSnapshot\": true,\n      \"cloudState\": 0,\n      \"consistencyLevel\": \"string\",\n      \"indexState\": 0,\n      \"replicationLocationIds\": [\n        \"string\"\n      ],\n      \"archivalLocationIds\": [\n        \"string\"\n      ],\n      \"slaId\": \"string\",\n      \"slaName\": \"string\",\n      \"isRetainedByRetentionLockSla\": true,\n      \"cloudStorageTier\": \"Hot\",\n      \"volumeGroupId\": \"string\",\n      \"name\": \"string\",\n      \"includedVolumes\": [\n        {\n          \"id\": \"string\",\n          \"fileSystemType\": \"NTFS\",\n          \"mountPoints\": [\n            \"string\"\n          ],\n          \"size\": 0\n        }\n      ]\n    }\n  ],\n  \"total\": 0\n}\n```\n\n## Creating on-demand snapshot of a Volume Group\n\nTo create an on-demand snapshot of a Volume Group, send a POST request to\n[`/volume_group/{id}/snapshot`](#operation/createOnDemandVolumeGroupBackup)\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/volume_group/{id}/snapshot\"\n```\n\nThe Rubrik REST API server initiates the asynchronous snapshot task and\nresponds with a task object.\n\n```\n{\n  \"id\": \"string\",\n  \"status\": \"string\",\n  \"progress\": 0,\n  \"startTime\": \"2019-12-16T23:21:53.450Z\",\n  \"endTime\": \"2019-12-16T23:21:53.450Z\",\n  \"nodeId\": \"string\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"string\",\n      \"rel\": \"string\"\n    }\n  ]\n}\n```\n\n## Getting the forced full snapshot configuration of a Volume Group\n\nTo retrieve the configuration used to force a full snapshot of a Volume\nGroup, send a GET request to\n[`/volume_group/{id}/request/force_full_snapshot`](#operation/getVolumeGroupForceFullSpec)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/volume_group/{id}/request/force_full_snapshot\"\n```\n\nThe Rubrik REST API server responds with the Volume Group force full\nresponse object. The response object contains the latest configuration,\nunless it was cleared by a backup job of the Volume Group or it was\nnever set.\n\n```bash\n{\n  \"volumeGroupId\": \"VolumeGroup:::fe9470a4-4057-4357-ac1f-ae99ff735439\",\n  \"volumeInfos\": [\n    {\n      \"volumeId\": \"872bdd28-4d5d-4831-8698-59d692a822fc\",\n      \"shouldDedupe\": false\n    },\n    {\n      \"volumeId\": \"39f61483-9cf5-11e9-80b9-00155d094203\",\n      \"shouldDedupe\": true\n    }\n  ]\n}\n```\n\n## Requesting a forced full snapshot for a Volume Group\n\nTo request a forced full snapshot of a Volume Group, send a POST request to\n[`/volume_group/{id}/request/force_full_snapshot`](#operation/requestVolumeGroupForceFullSnapshot)\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/volume_group/{id}/request/force_full_snapshot\"\n```\n\nThe Rubrik REST API server persists the configuration for forcing a\nfull snapshot until the next backup job, which takes a full snapshot\nand clears the configuration.\n\n```\n{\n  \"volumeGroupId\": \"VolumeGroup:::fe9470a4-4057-4357-ac1f-ae99ff735439\",\n  \"volumeInfos\": [\n    {\n      \"volumeId\": \"872bdd28-4d5d-4831-8698-59d692a822fc\",\n      \"shouldDedupe\": false\n    },\n    {\n      \"volumeId\": \"39f61483-9cf5-11e9-80b9-00155d094203\",\n      \"shouldDedupe\": true\n    }\n  ]\n}\n```\n\n## Getting details of a Volume Group snapshot\n\nTo get the details of a Volume Group snapshot, send a GET request to\n[`/volume_group/snapshot/{id}`](#operation/getVolumeGroupSnapshot)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/volume_group/snapshot/{id}\"\n```\n\nThe The Rubrik REST API server responds with the details of a snapshot.\n\n```\n{\n  \"id\": \"string\",\n  \"date\": \"2019-12-16T23:21:53.395Z\",\n  \"expirationDate\": \"2019-12-16T23:21:53.395Z\",\n  \"sourceObjectType\": \"string\",\n  \"isOnDemandSnapshot\": true,\n  \"cloudState\": 0,\n  \"consistencyLevel\": \"string\",\n  \"indexState\": 0,\n  \"replicationLocationIds\": [\n    \"string\"\n  ],\n  \"archivalLocationIds\": [\n    \"string\"\n  ],\n  \"slaId\": \"string\",\n  \"slaName\": \"string\",\n  \"isRetainedByRetentionLockSla\": true,\n  \"cloudStorageTier\": \"Hot\",\n  \"volumeGroupId\": \"string\",\n  \"name\": \"string\",\n  \"includedVolumes\": [\n    {\n      \"id\": \"string\",\n      \"fileSystemType\": \"NTFS\",\n      \"mountPoints\": [\n        \"string\"\n      ],\n      \"size\": 0\n    }\n  ]\n}\n```\n\n## Getting summary information of all Volume Group mounts\n\nTo get summary information of all Volume Group mounts, send a GET request to\n[`/volume_group/snapshot/mount`](#operation/queryVolumeGroupSnapshotMount)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/volume_group/snapshot/mount\"\n```\n\nThe Rubrik REST API server returns summary information for all mounts.\n\n```\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"string\",\n      \"name\": \"string\",\n      \"sourceVolumeGroupId\": \"string\",\n      \"sourceHostId\": \"string\",\n      \"sourceHostName\": \"string\",\n      \"snapshotDate\": \"2019-12-16T23:21:53.377Z\",\n      \"snapshotSourceVersion\": \"WithLayoutInfo\",\n      \"mountedDate\": \"2019-12-16T23:21:53.377Z\",\n      \"mountedVolumes\": [\n        {\n          \"id\": \"string\",\n          \"originalMountPoints\": [\n            \"string\"\n          ],\n          \"size\": 0,\n          \"fileSystemType\": \"NTFS\",\n          \"smbPath\": \"string\",\n          \"hostMountedPath\": \"string\"\n        }\n      ],\n      \"targetHostId\": \"string\",\n      \"targetHostName\": \"string\",\n      \"mountRequestId\": \"string\",\n      \"unmountRequestId\": \"string\",\n      \"isReady\": true,\n      \"restoreScriptSmbPath\": \"string\"\n    }\n  ],\n  \"total\": 0\n}\n```\n\n## Getting summary information of one mount\n\nTo retrieve summary information of one Volume Group mount, send a GET\nrequest to\n[`/volume_group/snapshot/mount/{id}`](#operation/getVolumeGroupSnapshotMount)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/volume_group/snapshot/mount/{id}\"\n```\n\nThe Rubrik REST API server returns summary information of the mount.\n\n```\n{\n  \"id\": \"string\",\n  \"name\": \"string\",\n  \"sourceVolumeGroupId\": \"string\",\n  \"sourceHostId\": \"string\",\n  \"sourceHostName\": \"string\",\n  \"snapshotDate\": \"2019-12-16T23:21:53.387Z\",\n  \"snapshotSourceVersion\": \"WithLayoutInfo\",\n  \"mountedDate\": \"2019-12-16T23:21:53.388Z\",\n  \"mountedVolumes\": [\n    {\n      \"id\": \"string\",\n      \"originalMountPoints\": [\n        \"string\"\n      ],\n      \"size\": 0,\n      \"fileSystemType\": \"NTFS\",\n      \"smbPath\": \"string\",\n      \"hostMountedPath\": \"string\"\n    }\n  ],\n  \"targetHostId\": \"string\",\n  \"targetHostName\": \"string\",\n  \"mountRequestId\": \"string\",\n  \"unmountRequestId\": \"string\",\n  \"isReady\": true,\n  \"restoreScriptSmbPath\": \"string\"\n}\n\n```\n\n\n## Getting summary information of the latest snapshot of a Volume Group\n\nSend a GET request to\n[`/volume_group/{id}/latest_snapshot`]\\\n(#operation/queryVolumeGroupLatestSnapshot)\nto receive a summary of the latest snapshot of a Volume Group.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/volume_group/{id}/latest_snapshot\"\n```\n\nThe Rubrik REST API server returns summary information of the snapshot.\n```bash\n[\n  {\n    \"id\": \"string\",\n    \"date\": \"2019-12-16T23:21:53.446Z\",\n    \"expirationDate\": \"2019-12-16T23:21:53.446Z\",\n    \"sourceObjectType\": \"string\",\n    \"isOnDemandSnapshot\": true,\n    \"cloudState\": 0,\n    \"consistencyLevel\": \"string\",\n    \"indexState\": 0,\n    \"replicationLocationIds\": [\n      \"string\"\n    ],\n    \"archivalLocationIds\": [\n      \"string\"\n    ],\n    \"slaId\": \"string\",\n    \"slaName\": \"string\",\n    \"isRetainedByRetentionLockSla\": true,\n    \"cloudStorageTier\": \"Hot\",\n    \"volumeGroupId\": \"string\",\n    \"name\": \"string\",\n    \"includedVolumes\": [\n      {\n        \"id\": \"string\",\n        \"fileSystemType\": \"NTFS\",\n        \"mountPoints\": [\n          \"string\"\n        ],\n        \"size\": 0\n      }\n    ]\n  }\n]\n```\n\n# Snapshot Stats\n\n### Return storage stats of a snapshot\nTo receive the storage statistics of a snapshot, send a GET request to\n [`/snapshot/{id}/storage/stats`]\\\n(#operation/getSnapshotStorageStatsV1).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/snapshot/{id}/storage/stats\"\n```\n\n# Hierarchy\n\n### Return the list of descendant objects with SLA conflicts in bulk\nTo bulk get the list of descendant objects with SLA conflicts, send a POST\n request to\n [`/hierarchy/bulk_sla_conflicts`]\\\n(#operation/bulkHierarchySlaConflictsV1).\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/hierarchy/bulk_sla_conflicts\"\n```\n\n# Backup Verification\n\nBackup verification checks the validity of a backup\nbased on the specified snapshot ID and object ID.\n\n### Verify the validity of a given snapshot\nVerify the validity of the snapshot identified\nby the specified snapshot ID and object ID.\n[\n`/backup/verify`\n](#operation/verifySnapshot).\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"objectId\": \"$objectId\",\n    \"snapshotIdsOpt\": \"$snapshotIdsOpt\",\n    \"locationIdOpt\": \"$locationIdOpt\",\n    \"shouldVerifyAfterOpt\": \"$shouldVerifyAfterOpt\" }' \\\n  \"https://$cluster_address/api/v1/backup/verify/\"\n```\n\n### Get asynchronous request details for Backup Verification\nGet the details of an asynchronous request\nfor a backup verification job.\n[\n`/backup/verify/{id}`\n](#operation/getBackupVerificationAsyncRequestStatus).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/backup/verify/$id\"\n```\n\n### Reschedule unsuccessful backup tasks\n[\n`/backup/retry`\n](#operation/createBackupRemediationAsyncTask).\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"spec\": [\n      {\n        \"objectId\": \"$objectId\",\n        \"eventSeriesId\": \"$eventSeriesId\"\n      }\n    ],\n    \"config\": {\n      \"runNow\": \"$runNow\"\n    }\n  }' \\\n  \"https://$cluster_address/api/v1/backup/retry/\"\n```\n\n### Get status of reschedule operation\n[\n`/backup/retry/{id}`\n](#operation/getBackupRemediationAsyncTaskStatus).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/backup/retry/$id\"\n```\n\n# Exclusion pattern\n\nAn exclusion pattern is a regular expression pattern that enables Rubrik clusters to exclude files and folders, with names that match the regular expression pattern, from search results. Once created, the Rubrik cluster applies the exclusion pattern to the global search results and the snapshot level search results. The exclusion patterns also exclude matching files and folders from the recovery process.\n\nA Rubrik cluster can apply the exclusion pattern on a particular [Fileset](#section/Filesets) or on all the filesets associated with a particular [Host](#section/Hosts).\n\nThe exclusion patterns are either mutable or immutable. By default, the exclusion patterns are mutable or editable upon creation.\n\nThe Rubrik REST API exposes endpoints to:\n\n* create a single exclusion pattern\n* create multiple exclusion patterns, in bulk\n* get details of all the existing exclusion patterns\n* view details of a specific exclusion pattern\n* update an existing exclusion pattern\n* delete a single exclusion pattern\n* delete multiple exclusion patterns, in bulk\n\n## Adding an exclusion pattern\nTo create a new exclusion pattern, send a POST request to [/exclusion_pattern](#operation/createExclusionPattern).\nThe request payload must include the following attributes required to create an exclusion pattern:\n* `sourceId` - The ID for a fileset or a host to which the pattern will apply.\n* `pattern` - The regular expression pattern.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"sourceId\": \"$sourceId\",\n    \"pattern\": \"$pattern\" }' \\\n  \"https://$cluster_address/api/v1/exclusion_pattern\"\n```\n\nThe Rubrik REST API server responds with the details of the new exclusion pattern.\n\n```bash\n{\n  \"id\": \"$id\",\n  \"sourceId\": \"$sourceId\",\n  \"pattern\": \"$pattern\",\n  \"isMutable\": true,\n  \"patternStatus\": \"Queued\",\n  \"isActive\": true,\n  \"primaryClusterId\": \"$primaryClusterId\"\n}\n```\n\n## Bulk adding exclusion patterns\nTo create exclusion patterns in bulk, send a POST request to [/exclusion_pattern/bulk](#operation/bulkCreateExclusionPattern).\nThe request payload must be an array. The array contains one set of required attributes for every exclusion pattern that will be created. See [Adding an exclusion pattern](#adding-an-exclusion-pattern) for a list of required attributes.\n\n```bash\ncurl -X POST \\\n  -d '{\n    [{ \"sourceId\": \"$sourceId1\", \"pattern\": \"$pattern1\"}, { \"sourceId\": \"$sourceId2\", \"pattern\": \"$pattern2\"}] }' \\\n  \"https://$cluster_address/api/v1/exclusion_pattern/bulk\"\n```\n\nThe Rubrik REST API server responds with the details of the new exclusion patterns.\n\n```bash\n{\n  \"exclusionPatternDetails\": [\n    {\n      \"id\": \"$id\",\n      \"sourceId\": \"$sourceId1\",\n      \"pattern\": \"$pattern1\",\n      \"isMutable\": true,\n      \"patternStatus\": \"Queued\",\n      \"isActive\": true,\n      \"primaryClusterId\": \"$primaryClusterId\"\n    },\n    {\n      \"id\": \"$id\",\n      \"sourceId\": \"$sourceId2\",\n      \"pattern\": \"$pattern2\",\n      \"isMutable\": true,\n      \"patternStatus\": \"Queued\",\n      \"isActive\": true,\n      \"primaryClusterId\": \"$primaryClusterId\"\n    }\n  ]\n}\n```\n\n## Retrieving all exclusion patterns\nTo retrieve a summary of all the exclusion patterns that have been added to the Rubrik cluster, send a GET request to [/exclusion_pattern](#operation/queryExclusionPattern).\nThe GET /exclusion_pattern endpoint exposes a number of parameters to filter the list of exclusion patterns returned by the endpoint. The endpoint can be used with or without any of the available parameters.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/exclusion_pattern\"\n```\n\nThe Rubrik REST API server responds with a ListResponse object that contains the current list of exclusion patterns and their details.\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"$id\",\n      \"sourceId\": \"$sourceId\",\n      \"pattern\": \"$pattern\",\n      \"isMutable\": true,\n      \"patternStatus\": \"Applied\",\n      \"isActive\": true,\n      \"primaryClusterId\": \"$primaryClusterId\"\n    }\n  ],\n  \"total\": 1\n}\n```\n\n## Retrieving a specific exclusion pattern\nTo retrieve the details of a specific exclusion pattern, send a GET request to [/exclusion_pattern/{id}](#operation/getExclusionPattern).\nThe {id} represents the ID for the exclusion pattern and has the form - ExclusionPattern:::{uuid}.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/exclusion_pattern/$exclusion_pattern_id\"\n```\n\nThe Rubrik REST API server responds with the details of the specified exclusion pattern.\n\n```bash\n{\n  \"id\": \"$exclusion_pattern_id\",\n  \"sourceId\": \"$sourceId\",\n  \"pattern\": \"$pattern\",\n  \"isMutable\": true,\n  \"patternStatus\": \"Applied\",\n  \"isActive\": true,\n  \"primaryClusterId\": \"$primaryClusterId\"\n}\n```\n\n## Updating an exclusion pattern\nTo update a specific exclusion pattern, send a POST request to [/exclusion_pattern/{id}](#operation/updateExclusionPattern).\nNote that the Rubrik cluster allows updating only the exclusion patterns that have `\"isMutable\": true`.\nThe {id} represents the ID for the exclusion pattern to be updated and has the form - ExclusionPattern:::{uuid}.\n\nThe attributes that can be updated are all or a subset of the following attributes:\n\n* pattern\n* isActive\n* isMutable\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"pattern\": \"$pattern\",\n    \"isActive\": false,\n    \"isMutable\": true }' \\\n  \"https://$cluster_address/api/v1/exclusion_pattern/$exclusion_pattern_id\"\n```\n\nThe Rubrik REST API server responds with the details of the updated exclusion pattern.\n\n```bash\n{\n  \"id\": \"$exclusion_pattern_id\",\n  \"sourceId\": \"$sourceId\",\n  \"pattern\": \"$pattern\",\n  \"isMutable\": true,\n  \"patternStatus\": \"Queued\",\n  \"isActive\": true,\n  \"primaryClusterId\": \"$primaryClusterId\"\n}\n```\n\n## Deleting an exclusion pattern\nTo delete a specific exclusion pattern, send a DELETE request to [/exclusion_pattern/{id}](#operation/deleteExclusionPattern).\nNote that the Rubrik cluster only allows the deletion of the exclusion patterns that have `\"isMutable\": true`.\nThe {id} represents the ID for the exclusion pattern to be deleted and has the form - ExclusionPattern:::{uuid}.\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/exclusion_pattern/$exclusion_pattern_id\"\n```\nThe Rubrik REST API server responds with a 204 HTTP response code to indicate the successful deletion of the specified exclusion pattern.\n\n## Bulk deleting exclusion patterns\nTo delete exclusion patterns in bulk, send a DELETE request to [/exclusion_pattern/bulk](#operation/bulkDeleteExclusionPattern) with the IDs for the exclusion patterns to be deleted.\nNote that the Rubrik cluster only allows the deletion of the exclusion patterns that have `\"isMutable\": true`.\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/exclusion_pattern/bulk?ids=$exclusion_pattern_id1,$exclusion_pattern_id2\"\n```\nThe Rubrik REST API server responds with a 204 HTTP response code to indicate the successful deletion of the specified exclusion patterns.\n\n# Hyper-V VMs \n\n## Getting the forced full snapshot configuration of a Hyperv VM\n\nTo retrieve the configuration used to force a full snapshot\nof a Hyperv virtual machine, send a GET request to:\n[`/hyperv/vm/{id}/request/force_full_snapshot`](#operation/getHypervVirtualMachineForceFullSpec)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/hyperv/vm/{id}/request/force_full_snapshot\"\n```\n\nThe Rubrik REST API server responds with the Hyperv virtual machine force full\nresponse object. The response object contains the latest configuration,\nunless it was cleared by a backup job of the Hyperv virtual machine or was\nnever set.\n\n```bash\n{\n  \"vmId\": \"HypervVirtualMachine:::fe9470a4-4057-4357-ac1f-ae99ff735439\",\n  \"virtualDiskInfos\": [\n    {\n      \"virtualDiskId\": \"872bdd28-4d5d-4831-8698-59d692a822fc\",\n      \"shouldDedupe\": false\n    },\n    {\n      \"virtualDiskId\": \"39f61483-9cf5-11e9-80b9-00155d094203\",\n      \"shouldDedupe\": true\n    }\n  ]\n}\n```\n\n## Requesting a forced full snapshot for a Hyperv VM\n\nTo request a forced full snapshot of a Hyperv virtual machine, send a POST\nrequest to:\n[`/hyperv/vm/{id}/request/force_full_snapshot`](#operation/requestHypervVirtualMachineForceFullSnapshot)\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/hyperv/vm/{id}/request/force_full_snapshot\"\n```\n\nThe Rubrik REST API server persists the configuration to force a\nfull snapshot until the next backup job, which takes a full snapshot\nand clears the configuration.\n\n```bash\n{\n  \"vmId\": \"HypervVirtualMachine:::fe9470a4-4057-4357-ac1f-ae99ff735439\",\n  \"virtualDiskInfos\": [\n    {\n      \"virtualDiskId\": \"872bdd28-4d5d-4831-8698-59d692a822fc\",\n      \"shouldDedupe\": false\n    },\n    {\n      \"virtualDiskId\": \"39f61483-9cf5-11e9-80b9-00155d094203\",\n      \"shouldDedupe\": true\n    }\n  ]\n}\n```\n\n# Health monitor\nThe Rubrik REST API endpoints for health monitor will allow users to get insight\ninto the health of individual nodes or the entire Rubrik cluster.\nCurrently, the endpoints support following operations:\n* Retrieve a list of available health monitor policies.\n* Enforce health monitor policies on one or more nodes of the Rubrik cluster.\n* Retrieve the status of the health monitor policies.\n\n## Get health monitor policies\nTo retrieve a list of health monitor policies, send GET request to\nGET ['/health_monitor/policies'](#operation/getPolicies) endpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/health_monitor/policies\"\n```\nThe Rubrik REST API server responds with a list of the available health monitor\npolicies. Following output displays the response for Sdfs policy.\n```bash\n[\n  {\n    \"policyId\": \"Sdfs\",\n    \"policyType\": \"CHECKER\",\n    \"policyName\": \"Sdfs Check\",\n    \"description\": \"Verify /sd is accessible and the SDFS service is responding\",\n    \"script\": \"$policyScript\",\n    \"scope\": \"NODE\",\n    \"runInState\": [\n      \"OK\",\n      \"BAD\"\n    ],\n    \"isEnabled\": true,\n    \"isHidden\": false,\n    \"scheduleFreqInSec\": 20,\n    \"causes\": [],\n    \"remedies\": [],\n    \"configParams\": [],\n    \"notificationConfig\": {\n      \"name\": \"Sdfs Check Failure\",\n      \"notificationType\": \"DIAGNOSTIC\",\n      \"notificationMessage\": \"Sdfs check failed\",\n      \"criticalDetails\": {\n        \"numFailures\": 150,\n        \"failureWindow\": 3000,\n        \"action\": {\n          \"actionString\": \"$criticalActionScript\",\n          \"isEnabled\": true\n        }\n      },\n      \"warnDetails\": {\n        \"numFailures\": 75,\n        \"failureWindow\": 2000,\n        \"action\": {\n          \"actionString\": \"$warnActionScript\",\n          \"isEnabled\": true\n        }\n      }\n    },\n    \"dependencies\": []\n  }\n]\n\n```\n\n## Run health monitor Policies\nTo enforce health monitor policies on selected nodes or the entire Rubrik\ncluster send a POST Request to\n['/health_monitor/$runPolicy'](#operation/runPolicies) endpoint.\n\n```bash\ncurl -X POST\n  -d '{\n    \"policyIds\": [\"policy_id1\", \"policy_id2\"],\n    \"nodeIds\": [\"node_id1, node_id2\"]}' \\\n  \"https://$cluster_address>/api/v1/health_monitor/runPolicy\"\n```\nThe Rubrik REST API server responds with the result of running the health\nmonitor policies. Following output displays the Sdfs policy enforcement response.\n```\n[\n  {\n    \"nodeId\": \"$node_id1\",\n    \"checkResults\": [\n      {\n        \"nodeId\": \"$node_id1\",\n        \"policyId\": \"Sdfs\",\n        \"isCheckPassed\": true\n      }\n    ]\n  },\n  {\n    \"nodeId\": \"$node_id2\",\n    \"checkResults\": [\n      {\n        \"nodeId\": \"$node_id2\",\n        \"policyId\": \"Sdfs\",\n        \"isCheckPassed\": true\n      }\n    ]\n  },\n  {\n    \"nodeId\": \"$node_id3\",\n    \"checkResults\": [\n      {\n        \"nodeId\": \"$node_id3\",\n        \"policyId\": \"Sdfs\",\n        \"isCheckPassed\": true\n      }\n    ]\n  }\n\n```\n## Health monitor policy enforcement status\nTo retrieve the status of the policy enforcement, send a GET request to\nGET ['/health_monitor/policyStatus'](#operation/getPolicyStatus) endpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/health_monitor/policyStatus?\nnode_ids=<node_id1,node_id2>&policy_ids=policy_id1,policy_id2&has_detailed_status=true\"\n```\nThe Rubrik REST API server responds with the status of running the policies on\nthe selected nodes or the entire Rubrik cluster.\n```\n[\n  {\n    \"nodeId\": \"$node_id1\",\n    \"checkResults\": [\n      {\n        \"nodeId\": \"$node_id1\",\n        \"policyId\": \"Sdfs\",\n        \"isCheckPassed\": true,\n        \"checkOutput\": \"Passed last 12 attempts.\"\n      }\n    ]\n  },\n  {\n    \"nodeId\": \"$node_id2\",\n    \"checkResults\": [\n      {\n        \"nodeId\": \"$node_id2\",\n        \"policyId\": \"Sdfs\",\n        \"isCheckPassed\": true,\n        \"checkOutput\": \"Passed last 12 attempts.\"\n      }\n    ]\n  },\n  {\n    \"nodeId\": \"$node_id3\",\n    \"checkResults\": [\n      {\n        \"nodeId\": \"$node_id3\",\n        \"policyId\": \"Sdfs\",\n        \"isCheckPassed\": true,\n        \"checkOutput\": \"Passed last 12 attempts.\"\n      }\n    ]\n  }\n]\n```\n\n# Job Monitoring\n\n## Get summary information for protection and recovery jobs that are currently\n## running, scheduled to run, or completed in the last 24 hours.\nTo get summary information for protection and recovery jobs that are currently\nrunning, scheduled to run, or completed in the last 24 hours, send a GET request\nto [`/job_monitoring`](#operation/getJobMonitoringInfo) endpoint with optional\nquery parameters. The optional query parameters are job_event_status, job_type,\nis_first_full, nclude_log_related_job, object_type, object_name, node_name,\neffective_sla_domain_id, last_update_time, after_id, sort_by, sort_order\nand limit. The default sort sort_by is start time with sort_order as asc.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/job_monitoring?job_event_status=Active,Queued&limit=1&sort_by=StartTime&sort_order=asc\"\n```\n\nThe list of jobs matching the filters is returned.\n```bash\n{\n  \"jobMonitoringInfoList\": [\n    {\n      \"jobMonitoringState\": \"Active\",\n      \"jobStatus\": \"Queued\",\n      \"jobType\": \"Replication\",\n      \"objectId\": \"ObjectId,\n      \"objectType\": \"VmwareVirtualMachine\",\n      \"objectName\": \"object name\",\n      \"locationId\": \"location id\",\n      \"locationName\": \"location name\",\n      \"slaDomainId\": \"6d29f271-d706-47a5-a706-f4411ae5555a\",\n      \"slaDomainName\": \"Sla name\",\n      \"startTime\": \"2019-10-28T22:15:14.868Z\",\n      \"isFirstFullSnapshot\": false,\n      \"retryCount\": 0,\n      \"eventSeriesId\": \"b3a00c13-74de-4508-80cd-822d5f2960fe\",\n      \"duration\": 1802576,\n      \"nodeId\": \"node_id\",\n      \"warningCount\": 0,\n      \"lastUpdatedTime\": \"2019-10-28T22:15:15.088Z\"\n    }\n  ],\n  \"jobEventStatus\": [\"Active\",\"Queued\"],\n  \"shouldIncludeLogRelatedJob\": false,\n  \"afterId\": \"afterId\",\n  \"hasMore\": true\n}\n```\n## Get job summary information for protection and recovery jobs separated by\n## job type that have been scheduled, are currently running, or completed in\n## the past 24 hours.\nTo get job summary information for protection and recovery jobs separated by\njob type that have been scheduled, are currently running, or completed in the\npast 24 hours,send a GET request to\n[`/job_monitoring/summary_by_job_type`](#operation/getMonitoringJobCountByJobType)\nwith the required job_monitoring_state parameter.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/job_monitoring/summary_by_job_type?job_monitoring_state=Active\"\n```\n\nThe reponse is the the number of jobs for the given state separated by job_type.\n\n```bash\n{\n  \"jobMonitoringState\": \"Active\",\n  \"objectCounts\": {\n    \"total\": 37,\n    \"archival\": 10,\n    \"backup\": 15,\n    \"instantiate\": 0,\n    \"recovery\": 0,\n    \"replication\": 12,\n    \"logBackup\": 0,\n    \"logArchival\": 0,\n    \"logReplication\": 0,\n    \"logShipping\": 0\n  }\n}\n```\n## Get job summary information separated by job state for all running jobs,\n## jobs that have been scheduled, and jobs that are complete, for protection\n## and recovery jobs in the past 24 hours.\nTo get job summary information separated by job state for all running jobs,\njobs that have been scheduled, and jobs that are complete, for protection and\nrecovery jobs in the past 24 hours, send a GET request to\n[`/job_monitoring/get_summary_by_job_state`](#operation/getMonitoringJobCountByJobState)\nwith the optional parameter job_types to get the count only for a\nspecific state.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/job_monitoring/get_summary_by_job_state\"\n```\n\nThe response is the number of jobs in each state.\n\n```bash\n{\n  \"jobTypes\": [\n    \"Instantiate\",\n    \"LogReplication\",\n    \"Archival\",\n    \"Replication\",\n    \"LogBackup\",\n    \"LogShipping\",\n    \"Backup\",\n    \"Recovery\",\n    \"LogArchival\"\n  ],\n  \"objectCounts\": {\n    \"total\": 52,\n    \"failure\": 2,\n    \"active\": 15,\n    \"scheduled\": 10,\n    \"success\": 25\n  }\n}\n```\n\n## Get a link to to download the job summary information as a CSV file, with\n## the same filters as in the `GET /job_monitoring/` API.\nTo get a link to to download the job summary information as a CSV file, send a\nGET request to\n[`/job_monitoring/csv_download_link`](#operation/getJobMonitoringInfoCsvDownloadLink)\n with require parameter job_monitoring_state.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/job_monitoring/csv_download_link?job_monitoring_state=Active\"\n```\n\nThe link to the file is returned.\n\n```bash\n{\n  \"downloadLink\": \"https://$cluster_address/report_dir/name.csv\",\n  \"jobMonitoringState\": \"Active\"\n}\n```\n\n## Create an email subscription to the monitoring page with user-specified\n## job states.\nTo create an email subscription to the monitoring page, send a\nPOST request to\n[`/job_monitoring/subscription`](#operation/createMonitoringSubscription)\n with required parameter subscription_request.\n\n```bash\ncurl -X POST -d '{\n  \"timeAttributes\": \"$timeAttributes\",\n  \"emailAddresses\": \"$emailAddresses\",\n  \"attachments\": \"$attachments\",\n  \"jobStates\": \"$jobStates\"\n}' \"https://$cluster_address/api/v1/job_monitoring/subscription\"\n```\n\nThe summary of the created monitoring email subscription is returned.\n\n```bash\n{\n  \"timeAttributes\": {\"dailyScheduleHour\": 7},\n  \"emailAddresses\": [\"abcde@rubrik.com\"],\n  \"attachments\": [\"Csv\"],\n  \"jobStates\": [\"Active\"],\n  \"id\": \"b3a00c13-74de-4508-80cd-822d5f2960fe\",\n  \"status\": \"Active\",\n  \"owner\": {\n    \"userId\": \"6d29f271-d706-47a5-a706-f4411ae5555a\",\n    \"userName\": \"Owner\"\n  }\n}\n```\n\n## Get all monitoring page email subscriptions.\nTo get all email subscriptions to the monitoring page, send a\nGET request to [`/job_monitoring/subscription`]\n(#operation/getMonitoringSubscriptions)\n with no parameters.\n\n```bash\ncurl -X GET\n\"https://$cluster_address/api/v1/job_monitoring/subscription\"\n```\n\nA summary of all unarchived email subscriptions for monitoring\n  page in a list of summaries sorted by creation time (earliest\n  created first).\n  Each summary contains information for each subscription\n  -- Time attributes - when to send the email\n  -- Email addresses - who to send the email\n  -- Attachments - what attachments should the email include\n  -- Job states - which job states to include in the email\n      (Failure, Scheduled, Success, Active, Canceled).\n  -- Id - the tring that identifies the subscription\n  -- Status - the status of the subscription\n      (Active, Suspended, or Unknown)\n  -- Owner - information about the owner of the subscription\n    -- user id - unique id used to identify the owner\n    -- user name - human-readable name of user\n       the time schedule to send the subscription\n\n```bash\n[\n  {\n    \"timeAttributes\": {\"dailyScheduleHour\": 7},\n    \"emailAddresses\": [\"abcde@rubrik.com\"],\n    \"attachments\": [\"Csv\"],\n    \"jobStates\": [\"Active\"],\n    \"id\": \"b3a00c13-74de-4508-80cd-822d5f2960fe\",\n    \"status\": \"Suspended\",\n    \"owner\": {\n      \"userId\": \"6d29f271-d706-47a5-a706-f4411ae5555a\",\n      \"userName\": \"Owner\"\n    }\n  },\n  {\n    \"timeAttributes\": {\"dailyScheduleHour\": 20},\n    \"emailAddresses\": [\"dummy@rubrik.com\"],\n    \"attachments\": [\"Csv\"],\n    \"jobStates\": [\"Failure\", \"Canceled\"],\n    \"id\": \"b3a00c13-74de-4508-80cd-822d5f2960fe\",\n    \"status\": \"Active\",\n    \"owner\": {\n      \"userId\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",\n      \"userName\": \"Owner\"\n    }\n  },\n]\n```\n\n## Get a monitoring page email subscription.\nTo get an email subscription to the monitoring page, send a\nGET request to\n[`/job_monitoring/subscription/{subscription_id}`]\n(#operation/getMonitoringSubscription)\n with required parameter subscription_id.\n\n```bash\ncurl -X GET\n\"https://$cluster_address/api/v1/job_monitoring/subscription/$subscription_id\"\n```\n\nThe summary of the created monitoring email subscription is returned.\n\n```bash\n{\n  \"timeAttributes\": {\"dailyScheduleHour\": 7},\n  \"emailAddresses\": [\"abcde@rubrik.com\"],\n  \"attachments\": [\"Csv\"],\n  \"jobStates\": [\"Active\"],\n  \"id\": \"b3a00c13-74de-4508-80cd-822d5f2960fe\",\n  \"status\": \"Active\",\n  \"owner\": {\n    \"userId\": \"6d29f271-d706-47a5-a706-f4411ae5555a\",\n    \"userName\": \"Owner\"\n  }\n}\n```\n\n## Update an existing monitoring page email subscription.\nTo update an email subscription to the monitoring page, send a\nPATCH request to\n[`/job_monitoring/subscription/{subscription_id}`]\n(#operation/updateMonitoringSubscription)\n with required parameter subscription_id.\n\n```bash\ncurl -X PATCH -d '{\n  \"timeAttributes\": \"$timeAttributes\",\n  \"emailAddresses\": \"$emailAddresses\",\n  \"attachments\": \"$attachments\",\n  \"jobStates\": \"$jobStates\",\n  \"id\": \"$id\",\n  \"assumeOwnership\": \"$assumeOwnership\"\n}'\n\"https://$cluster_address/api/v1/job_monitoring/subscription/$subscription_id\"\n```\n\nThe summary of the updated monitoring email subscription is returned.\n\n```bash\n{\n  \"timeAttributes\": {\"dailyScheduleHour\": 7},\n  \"emailAddresses\": [\"abcde@rubrik.com\"],\n  \"attachments\": [\"Csv\"],\n  \"jobStates\": [\"Active\"],\n  \"id\": \"b3a00c13-74de-4508-80cd-822d5f2960fe\",\n  \"status\": \"Active\",\n  \"owner\": {\n    \"userId\": \"6d29f271-d706-47a5-a706-f4411ae5555a\",\n    \"userName\": \"Owner\"\n  }\n}\n```\n\n## Delete an existing monitoring page email subscription.\nTo delete an email subscription to the monitoring page, send a\nDELETE request to\n[`/job_monitoring/subscription/{subscription_id}`]\n(#operation/deleteMonitoringSubscription)\n with required parameter subscription_id.\n\n```bash\ncurl -X DELETE\n\"https://$cluster_address/api/v1/job_monitoring/subscription/$subscription_id\"\n```\n\n# Rubrik syslog management\n\nRubrik CDM clusters include the capability to add export rules to forward\nsyslog information to remote servers.\n\n# Managing the Rubrik cluster syslog settings\n\nTo view all the currently configured syslog export rules, send a GET request to\nthe [`/syslog/export`](#operation/getSyslogExportRules) endpoint.\n\n**Example:** Retrieving the currently configured syslog export rules for a\nRubrik cluster.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/syslog/export\"\n```\n\nTo add a new syslog export rule, send a POST request to the\n[`/syslog/export`](#operation/addSyslogExportRule) endpoint.\n\n**Example:** Adding a new syslog export rule for a Rubrik cluster\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/syslog/export\"\n```\n\nTo retrieve a syslog export rule, send a GET request with the export rule ID to\nthe [`/syslog/export/{id}`](#operation/getSyslogExportRule) endpoint.\n\nTo modify a syslog export rule, send a PATCH request with the export rule ID to\nthe [`/syslog/export/{id}`](#operation/updateSyslogExportRule) endpoint.\n\nTo remove a syslog export rule, send a DELETE request with the export rule ID to\nthe [`/syslog/export/{id}`](#operation/deleteSyslogExportRule) endpoint.\n\n**Example:** Managing individual syslog export rules for a Rubrik cluster\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/syslog/export/{id}\"\ncurl -X PATCH \"https://$cluster_address/api/v1/syslog/export/{id}\"\ncurl -X DELETE \"https://$cluster_address/api/v1/syslog/export/{id}\"\n```\n\nTo test a syslog export rule, send a POST request with the export rule\ninformation to the [`/syslog/export/test`](#operation/testSyslogExportRule)\nendpoint.\n\n**Example:** Testing a syslog export rule for a Rubrik cluster\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/syslog/export/test\"\n```\n\n# Rubrik user management\n\nRubrik CDM clusters include the capability to manage access to resources\nusing local users.\n\n# Managing the Rubrik local user account lockout\n\nTo view the current local user account lockout configuration, send a GET\nrequest to\nthe [`/user/lockout`](#operation/getUserAccountLockoutSettings) endpoint.\n\n**Example:** Retrieving the current local user account lockout configuration\nfor a Rubrik cluster\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/user/lockout\"\n```\n\nTo update the lockout configuration, send a PATCH request to the\n[`/user/lockout`](#operation/manageUserAccountLockoutSettings) endpoint.\n\n**Example:** Updating the local user account lockout configuration for a\nRubrik cluster.\n\n```bash\ncurl -X PATCH \"https://$cluster_address/api/v1/user/lockout\"\n```\n\n## Unlocking a locked user\nTo unlock a locked user, send a POST request to the\n[`/user/{id}/unlock`](#operation/unlockUser) endpoint\n\n**Example:** Unlocking a locked local user on CDM cluster\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/user/{id}/unlock\"\n```\n\n# Configuring users with TOTP as 2FA\n\nTo fetch the TOTP status for an account, send a GET request to the\n[`/user/{id}/totp/status`](#operation/getTotpStatus) endpoint.\n\n**Example:** Retrieving TOTP status\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/user/{id}/totp/status\"\n```\n\nTo configure and enable TOTP for an account, send a PUT request to the\n[`/user/{id}/totp/config`](#operation/setupTotp) endpoint.\n\n**Example:** Configure TOTP\n```bash\ncurl -X PUT \"https://$cluster_address/api/v1/user/{id}/totp/config\"\n```\n\nTo reset and disable TOTP for an account, send a DELETE request to the\n[`/user/{id}/totp/config`](#operation/resetTotp) endpoint.\n\n**Example:** Reset TOTP\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/user/{id}/totp/config\"\n```\n\nTo generate TOTP secret for an account, send a POST request to the\n[`/user/{id}/totp/new_secret`](#operation/generateTotpSecret) endpoint.\n\n**Example:** Generate TOTP secret\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/user/{id}/totp/new_secret\"\n```\n\n# MFA Servers\n\nAn MFA Server is a server that Rubrik can be configured with in order to support\nintegrations with external multi-factor authentication services.\n\n## Adding a server\nTo add an MFA Server to the cluster, send a POST request to the\n[`/mfa/rsa/server`](#operation/createRsaMfaServer) endpoint.\n\n```bash\ncurl -X POST -d \\\n  '\n  {\n  \"name\": \"string\",\n  \"timeout\": 0,\n  \"baseUrl\": \"string\",\n  \"clientId\": \"string\",\n  \"assurancePolicyName\": \"string\",\n  \"ldapUsernameAttribute\": \"string\",\n  \"certificateId\": \"string\",\n  \"restApiKey\": \"string\",\n  \"restApiAccessId\": \"string\"\n  }\n  ' \\\n  \"https://$cluster_address/api/v1/mfa/rsa/server\"\n```\n```bash\n{\n  \"name\": \"string\",\n  \"timeout\": 0,\n  \"baseUrl\": \"string\",\n  \"clientId\": \"string\",\n  \"assurancePolicyName\": \"string\",\n  \"ldapUsernameAttribute\": \"string\",\n  \"certificateId\": \"string\",\n  \"id\": \"string\"\n}\n```\n## Getting MFA Servers\nTo get all MFA Servers configured on the cluster, leverage a GET request on the\n[`/mfa/rsa/server`](#operation/queryRsaMfaServers) endpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mfa/rsa/server\"\n```\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"name\": \"string\",\n      \"timeout\": 0,\n      \"baseUrl\": \"string\",\n      \"clientId\": \"string\",\n      \"assurancePolicyName\": \"string\",\n      \"ldapUsernameAttribute\": \"string\",\n      \"certificateId\": \"string\",\n      \"id\": \"string\"\n    }\n  ],\n  \"total\": 0\n}\n```\n\n## Deleting MFA Server Integrations\nIn order to delete a specific MFA Server integration, make a DELETE call to the\n[`/mfa/rsa/server/{id}`](#operation/deleteRsaMfaServer) endpoint.\n\n```bash\ncurl -X DELETE \\\n  -d '{\n    \"id\": \"$server_id\" }' \\\n  \"https://$cluster_address/api/v1/mfa/rsa/server/{id}\"\n```\n\n## Getting an MFA Server\nIn order to retrieve a specific MFA server integration, make a GET call to the\n[`/mfa/rsa/server/{id}`](#operation/getRsaMfaServer) endpoint.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"id\": \"server_id\" }' \\\n  \"https://$cluster_address/api/v1/mfa/rsa/server/{id}\"\n```\n```bash\n{\n  \"name\": \"string\",\n  \"timeout\": 0,\n  \"baseUrl\": \"string\",\n  \"clientId\": \"string\",\n  \"assurancePolicyName\": \"string\",\n  \"ldapUsernameAttribute\": \"string\",\n  \"certificateId\": \"string\",\n  \"id\": \"string\"\n}\n```\n\n## Updating an MFA Server\nIn order to update a specific MFA Server integration, make a PATCH call to the\n[`/mfa/rsa/server/{id}`](#operation/updateRsaMfaServer) endpoint.\n\n```bash\ncurl -X PATCH \\\n  -d '{\n{\n  \"name\": \"string\",\n  \"timeout\": 0,\n  \"baseUrl\": \"string\",\n  \"restApiKey\": \"string\",\n  \"clientId\": \"string\",\n  \"assurancePolicyName\": \"string\",\n  \"restApiAccessId\": \"string\",\n  \"ldapUsernameAttribute\": \"string\",\n  \"certificateId\": \"string\"\n}\n    ' \\\n  \"https://$cluster_address/api/v1/mfa/rsa/server/{id}\"\n```\n```bash\n{\n  \"name\": \"string\",\n  \"timeout\": 0,\n  \"baseUrl\": \"string\",\n  \"clientId\": \"string\",\n  \"assurancePolicyName\": \"string\",\n  \"ldapUsernameAttribute\": \"string\",\n  \"certificateId\": \"string\",\n  \"id\": \"string\"\n}\n```\n\n# Legal\n\n## Copyright\n\nRubrik REST API - Copyright © 2017-2021 Rubrik Inc.\nAll rights reserved.\n\nThis documentation may be used free of charge. Selling without prior written consent is prohibited.\nObtain permission before redistributing. In all cases, this copyright notice and disclaimer must remain\nintact.\n\n\n## Disclaimer\n\nTHE CONTENTS OF THIS DOCUMENTATION ARE PROVIDED \"AS IS,\" AND COPYRIGHT HOLDERS MAKE NO\nREPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR\nTITLE; THAT THE CONTENTS OF THE DOCUMENTATION ARE SUITABLE FOR ANY PURPOSE; THAT THE\nIMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS,\nTRADEMARKS OR OTHER RIGHTS.\nCOPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL\nDAMAGES ARISING OUT OF ANY USE OF THE DOCUMENTATION OR THE PERFORMANCE OR IMPLEMENTATION OF\nTHE CONTENTS THEREOF.\n\n## Trademarks\n\nRubrik, the Rubrik logo, Rubrik Envision, and Rubrik Edge are trademarks or registered trademarks of Rubrik, Inc. in the U.S. and/or other countries. All other trademarks are the property of their respective owners.\n\n# Report Config\n\n## Update the config parameters related to Reports\nSend a PATCH request to [`/report/config`](#operation/setReportConfig)\nThis request updates the configuration parameters related to the reporting framework.\n`cleanupReportJobInstanceForLogJobs` specifies an interval in days. Log jobs in report job instances are retained for the specified interval.\n\n```bash\ncurl -X PATCH \"https://$cluster_address/api/v1/report/config\"\n```\n\n## Get summary information for backup compliance based on each 24 hour time period\nSend a GET request to [`/report/compliance_summary`](#operation/getComplianceSummaryV1)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/report/compliance_summary\"\n```\n\n## Get summary information for backup compliance based on snapshot range\nSend a GET request to\n [`/report/compliance_summary_sla`](#operation/getComplianceSummarySLAV1)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/report/compliance_summary_sla\"\n```\n\n#Database log backup report\n\n#Get the database log report summary\n\nTo get the database log report summary, send a GET request to the\n[`/database/log_report`](#operation/queryLogReport) end point\n\n**Example:** Retrieving the database log report summary\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/database/log_report\"\n```\n```bash\n{\n  \"total\": 1,\n  \"data\": [\n    {\n      \"effectiveSlaDomainName\": \"sla_name\",\n      \"id\": \"$db_id\",\n      \"name\": \"$db_name\",\n      \"location\": \"$location_name\",\n      \"databaseType\": \"$db_type\",\n      \"primaryClusterId\": \"$cluster_id\",\n      \"logBackupFrequency\": 3600,\n      \"lastSnapshotTime\": \"2020-11-10T22:21:43.000Z\",\n      \"effectiveSlaDomainId\": \"$sla_id\"\n    }\n  ],\n  \"hasMore\": false\n}\n```\n\n#Get the database log report properties\n\nTo get the database log report properties, send a GET request to the\n[`/database/log_report/defaults`](#operation/queryReportProperties) end point\n\n **Example:** Retrieving the database log report properties\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/database/log_report/defaults\"\n```\n```bash\n{\n  \"logDelayNotificationFrequencyInMin\": 720,\n  \"logDelayThresholdInMin\": 720,\n  \"enableDelayNotification\": false\n}\n```\n\n#Update the database log report properties\n\nTo update the database log report properties, send a PATCH request to the\n[`/database/log_report/defaults`](#operation/updateReportProperties) end point\n\n **Example:** Update the database log report properties\n\n```bash\ncurl -X PATCH \"https://$cluster_address/api/v1/database/log_report/defaults\" -d\\\n'{\n    \"logDelayNotificationFrequencyInMin\": 360,\n    \"logDelayThresholdInMin\": 120,\n    \"enableDelayNotification\": true\n }'\n```\n\n# Organization\n\n## Create a list of Rubrik Envoy objects\nTo create a list of Rubrik Envoy objects, send a POST request to the\n[`/organization/{id}/envoy/bulk`](#operation/bulkCreateEnvoys) endpoint. The\nrequest takes an ID for the Organization and the information about the Rubrik\nEnvoy objects.\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/organization/{id}/envoy/bulk\"\n```\n\nThe Rubrik REST API server responds with a `ListResponse` object.\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"string\",\n      \"ipAddress\": \"string\",\n      \"port\": 1234,\n      \"organizationId\": \"string\",\n      \"status\": \"Connected\",\n    },\n  ]\n}\n```\n\n## Remove a list of Rubrik Envoy objects\nTo remove a list of Rubrik Envoy objects, send a DELETE request to the\n[`/organization/{id}/envoy/bulk`](#operation/bulkDeleteEnvoys) endpoint. The\nrequest takes an ID for the Organization and a list of IDs for Rubrik Envoy\nobjects.\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/organization/{id}/envoy/bulk\"\n```\n\nThe Rubrik REST API server responds with HTTP response code 204. This indicates\nthe request succeeded and the response body is empty.\n\n## Update a list of Rubrik Envoy objects\nTo update a list of Rubrik Envoy objects, send a PATCH request to the\n[`/organization/{id}/envoy/bulk`](#operation/bulkUpdateEnvoys) endpoint. The\nrequest takes an ID for the Organization and the information about the Rubrik\nEnvoy objects.\n\n```bash\ncurl -X PATCH \"https://$cluster_address/api/v1/organization/{id}/envoy/bulk\"\n```\n\nThe Rubrik REST API server responds with a `ListResponse` object.\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"string\",\n      \"ipAddress\": \"string\",\n      \"port\": 1234,\n      \"organizationId\": \"string\",\n      \"status\": \"Connected\",\n    },\n  ]\n}\n```\n",
    "title": "Rubrik REST API",
    "version": "v1",
    "x-apisguru-categories": [
      "security",
      "storage"
    ],
    "x-logo": {
      "url": "https://www.rubrik.com/wp-content/uploads/2016/11/Rubrik-Snowflake-small.png"
    },
    "x-origin": [
      {
        "format": "swagger",
        "url": "https://rubrikinc.github.io/api-doc-v1-6.0/openapi.json",
        "version": "2.0"
      }
    ],
    "x-providerName": "rubrikinc.github.io"
  },
  "security": [
    {
      "BasicAuth": []
    },
    {
      "Bearer": []
    }
  ],
  "tags": [
    {
      "name": "Endpoint reference",
      "x-traitTag": true
    },
    {
      "description": "Archival.",
      "name": "/archive",
      "x-displayName": "/archive"
    },
    {
      "description": "Authorization.",
      "name": "/authorization",
      "x-displayName": "/authorization"
    },
    {
      "description": "Backup.",
      "name": "/backup",
      "x-displayName": "/backup"
    },
    {
      "description": "Blackout windows.",
      "name": "/blackout_window",
      "x-displayName": "/blackout_window"
    },
    {
      "description": "Certificates.",
      "name": "/certificate",
      "x-displayName": "/certificate"
    },
    {
      "description": "Cloud utilization.",
      "name": "/cloud_utilization",
      "x-displayName": "/cloud_utilization"
    },
    {
      "description": "Cluster configuration and health.",
      "name": "/cluster",
      "x-displayName": "/cluster"
    },
    {
      "description": "Configuration update history.",
      "name": "/config/history",
      "x-displayName": "/config/history"
    },
    {
      "description": "Certificate signing requests.",
      "name": "/csr",
      "x-displayName": "/csr"
    },
    {
      "description": "Database log backup report.",
      "name": "/database/log_report",
      "x-displayName": "/database/log_report"
    },
    {
      "description": "Data Sources.",
      "name": "/data_source",
      "x-displayName": "/data_source"
    },
    {
      "description": "Events.",
      "name": "/event",
      "x-displayName": "/event"
    },
    {
      "description": "Event Series.",
      "name": "/event_series",
      "x-displayName": "/event_series"
    },
    {
      "description": "Exclusion patterns.",
      "name": "/exclusion_pattern",
      "x-displayName": "/exclusion_pattern"
    },
    {
      "description": "Failover clusters.",
      "name": "/failover_cluster",
      "x-displayName": "/failover_cluster"
    },
    {
      "description": "Failover cluster apps.",
      "name": "/failover_cluster/failover_cluster_app",
      "x-displayName": "/failover_cluster/failover_cluster_app"
    },
    {
      "description": "Failover cluster hierarchy.",
      "name": "/failover_cluster/hierarchy",
      "x-displayName": "/failover_cluster/hierarchy"
    },
    {
      "description": "File system filesets.",
      "name": "/fileset",
      "x-displayName": "/fileset"
    },
    {
      "description": "File system fileset templates.",
      "name": "/fileset_template",
      "x-displayName": "/fileset_template"
    },
    {
      "description": "HDFS.",
      "name": "/hdfs",
      "x-displayName": "/hsfs"
    },
    {
      "description": "HDFS templates.",
      "name": "/hdfs_template",
      "x-displayName": "/hdfs_template"
    },
    {
      "description": "Health monitor operations.",
      "name": "/health_monitor",
      "x-displayName": "/health_monitor"
    },
    {
      "description": "Linux hosts and Windows hosts.",
      "name": "/host",
      "x-displayName": "/host"
    },
    {
      "description": "Network shares.",
      "name": "/host/share",
      "x-displayName": "/host/share"
    },
    {
      "description": "Host hierarchy.",
      "name": "/host/hierarchy",
      "x-displayName": "/host/hierarchy"
    },
    {
      "description": "IdP authentication domains.",
      "name": "/idp_auth_domain",
      "x-displayName": "/idp_auth_domain"
    },
    {
      "description": "Job monitoring.",
      "name": "/job_monitoring",
      "x-displayName": "/job_monitoring"
    },
    {
      "description": "LDAP services.",
      "name": "/ldap_service",
      "x-displayName": "/ldap_service"
    },
    {
      "description": "Legal Hold.",
      "name": "/legal_hold",
      "x-displayName": "/legal_hold"
    },
    {
      "description": "Managed volumes.",
      "name": "/managed_volume",
      "x-displayName": "/managed_volume"
    },
    {
      "description": "SQL Server instances and databases.",
      "name": "/mssql",
      "x-displayName": "/mssql"
    },
    {
      "description": "Oracle.",
      "name": "/oracle",
      "x-displayName": "/oracle"
    },
    {
      "description": "Organization.",
      "name": "/organization",
      "x-displayName": "/organization"
    },
    {
      "description": "Principal Actions.",
      "name": "/principal",
      "x-displayName": "/principal"
    },
    {
      "description": "Replication.",
      "name": "/replication",
      "x-displayName": "/replication"
    },
    {
      "description": "Report.",
      "name": "/reports",
      "x-displayName": "/reports"
    },
    {
      "description": "Role management.",
      "name": "/role",
      "x-displayName": "/role"
    },
    {
      "description": "SAML SSO Authentication.",
      "name": "/saml",
      "x-displayName": "/saml"
    },
    {
      "description": "SAP HANA.",
      "name": "/sap_hana",
      "x-displayName": "/sap_hana"
    },
    {
      "description": "User session management.",
      "name": "/session",
      "x-displayName": "/session"
    },
    {
      "description": "SLA Domains.",
      "name": "/sla_domain",
      "x-displayName": "/sla_domain"
    },
    {
      "description": "Unmanaged Objects.",
      "name": "/unmanaged_object",
      "x-displayName": "/unmanaged_object"
    },
    {
      "description": "User management.",
      "name": "/user",
      "x-displayName": "/user"
    },
    {
      "description": "User-defined resource tag management.",
      "name": "/user_defined_tag",
      "x-displayName": "/user_defined_tag"
    },
    {
      "description": "vCloud cluster.",
      "name": "/vcd/cluster",
      "x-displayName": "/vcd/cluster"
    },
    {
      "description": "vCloud hierarchy.",
      "name": "/vcd/hierarchy",
      "x-displayName": "/vcd/hierarchy"
    },
    {
      "description": "vCloud Director vApps.",
      "name": "/vcd/vapp",
      "x-displayName": "/vcd/vapp"
    },
    {
      "description": "VMware hypervisor hosts.",
      "name": "/vmware/host",
      "x-displayName": "/vmware/host"
    },
    {
      "description": "VMware vCenter.",
      "name": "/vmware/vcenter",
      "x-displayName": "/vmware/vcenter"
    },
    {
      "description": "VMware virtual machines.",
      "name": "/vmware/vm",
      "x-displayName": "/vmware/vm"
    },
    {
      "description": "VMware compute clusters.",
      "name": "/vmware/compute_cluster",
      "x-displayName": "/vmware/compute_cluster"
    },
    {
      "description": "VMware resource pool.",
      "name": "/vmware/resource_pool",
      "x-displayName": "/vmware/resource_pool"
    },
    {
      "description": "VMware hierarchy.",
      "name": "/vmware/hierarchy",
      "x-displayName": "/vmware/hierarchy"
    },
    {
      "description": "Volume Groups.",
      "name": "/volume_group",
      "x-displayName": "/volume_group"
    },
    {
      "description": "Windows clusters.",
      "name": "/windows_cluster",
      "x-displayName": "/windows_cluster"
    }
  ],
  "paths": {
    "/archive/aws/s3/{id}/account_id": {
      "get": {
        "description": "Get the AWS account ID of an AWS S3 archival location.",
        "operationId": "getAwsAccountId",
        "parameters": [
          {
            "description": "ID of an AWS archival location that uses the S3 protocol.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StringResponse"
                }
              }
            },
            "description": "Account ID of the AWS account of the archival location."
          }
        },
        "summary": "Get the AWS account ID of an AWS S3 archival location",
        "tags": [
          "/archive"
        ],
        "x-group": "archival"
      }
    },
    "/archive/location/{id}/owner/disable": {
      "post": {
        "description": "Disables archiving and any changes to the data for the specified archival location. This operation disables snapshot upload, snapshot expiration, consolidation, and garbage collection operations on the archival location.\n",
        "operationId": "disableArchivalLocation",
        "parameters": [
          {
            "description": "ID assigned to an archival location object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Archival location successfully disabled.\n"
          }
        },
        "summary": "Disable location for archival and modification operations",
        "tags": [
          "/archive"
        ],
        "x-group": "archival"
      }
    },
    "/archive/location/{id}/owner/enable": {
      "post": {
        "description": "Enable archiving and other operations that were previously disabled on the specified archival location.\n",
        "operationId": "enableArchivalLocation",
        "parameters": [
          {
            "description": "ID assigned to an archival location object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Archival location successfully enabled.\n"
          }
        },
        "summary": "Enable archival location for archival and modification operations",
        "tags": [
          "/archive"
        ],
        "x-group": "archival"
      }
    },
    "/archive/location/{location_id}/reader/refresh/data_sources": {
      "post": {
        "description": "Update the current Rubrik CDM cluster with information about the changes made to a list of data sources in an archival location by the Rubrik CDM cluster that owns the archival location.\n",
        "operationId": "refreshArchivalLocationDataSources",
        "parameters": [
          {
            "description": "ID assigned to an archival location object.",
            "in": "path",
            "name": "location_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReaderRefreshDataSourcesRequest"
              }
            }
          },
          "description": "A set of local and archival IDs for data sources to refresh. For a data source, either a local or archival data source ID should be specified. The operation will fail if `none` is specified.\n",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "The request ID for an asynchronous request to refresh archival information.\n"
          }
        },
        "summary": "Refresh archive information for a list of data sources",
        "tags": [
          "/archive"
        ],
        "x-group": "archival"
      }
    },
    "/authorization/cache": {
      "delete": {
        "description": "Clears the node of cached authorization information for the current user.",
        "operationId": "deleteAuthzCache",
        "responses": {
          "204": {
            "description": "Successfully deleted cached authorization information."
          }
        },
        "summary": "Clear cached authorization information",
        "tags": [
          "/authorization"
        ],
        "x-group": "role_authorization"
      }
    },
    "/backup/retry": {
      "post": {
        "description": "Create an asynchronous task for rescheduling unsuccessful backup tasks.\n",
        "operationId": "createBackupRemediationAsyncTask",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RemediationRequest"
              }
            }
          },
          "description": "Parameters required to reschedule unsuccessful backup tasks.\n",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RemediationResponse"
                }
              }
            },
            "description": "Status details of the async request."
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RequestFailedException"
                }
              }
            },
            "description": "The re-scheduling API failed."
          }
        },
        "summary": "Reschedule unsuccessful backup tasks",
        "tags": [
          "/backup"
        ],
        "x-group": "backup_remediation"
      }
    },
    "/backup/retry/{id}": {
      "get": {
        "description": "Retrieve the details of a specified asynchronous task to use for rescheduling unsuccessful tasks.\n",
        "operationId": "getBackupRemediationAsyncTaskStatus",
        "parameters": [
          {
            "description": "Async request id.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status details of async request."
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RequestFailedException"
                }
              }
            },
            "description": "The status API failed."
          }
        },
        "summary": "Get status of reschedule attempt",
        "tags": [
          "/backup"
        ],
        "x-group": "backup_remediation"
      }
    },
    "/backup/verify": {
      "post": {
        "description": "This REST API triggers the job \"BACKUP_INTEGRITY_VERIFICATION\", which verifies whether or not the specified snapshot is restorable.\n",
        "operationId": "verifySnapshot",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VerificationParameters"
              }
            }
          },
          "description": "Parameters needed to schedule a snapshot verification job.\n",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VerificationResponse"
                }
              }
            },
            "description": "Sucessfully scheduled the job to verify the snapshot."
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RequestFailedException"
                }
              }
            },
            "description": "The verification API failed."
          }
        },
        "summary": "Trigger a job for snapshot verification",
        "tags": [
          "/backup"
        ],
        "x-group": "backup_verification"
      }
    },
    "/backup/verify/{id}": {
      "get": {
        "description": "Get the details of an asynchronous request for a backup verification job.\n",
        "operationId": "getBackupVerificationAsyncRequestStatus",
        "parameters": [
          {
            "description": "ID of the asynchronous request.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VerificationResponse"
                }
              }
            },
            "description": "Status of the asynchronous request."
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RequestFailedException"
                }
              }
            },
            "description": "The status retrieval API failed."
          }
        },
        "summary": "Get asynchronous request details for Backup Verification",
        "tags": [
          "/backup"
        ],
        "x-group": "backup_verification"
      }
    },
    "/blackout_window": {
      "get": {
        "description": "Determine whether global blackout window is currently active.",
        "operationId": "getBlackoutWindowStatus",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalBlackoutWindowStatus"
                }
              }
            },
            "description": "Current status of blackout window."
          }
        },
        "summary": "Get current status of global blackout window",
        "tags": [
          "/blackout_window"
        ],
        "x-group": "blackout_window"
      },
      "patch": {
        "description": "Returns whether or not the system is in a blackout window.",
        "operationId": "toggleBlackoutWindow",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GlobalBlackoutWindowStatus"
              }
            }
          },
          "description": "Whether to start or stop the global blackout window.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalBlackoutWindowStatus"
                }
              }
            },
            "description": "Returned the updated blackout window status."
          }
        },
        "summary": "Starts or stops the global blackout window in local Rubrik cluster",
        "tags": [
          "/blackout_window"
        ],
        "x-group": "blackout_window"
      }
    },
    "/certificate": {
      "get": {
        "description": "Get all certificates.",
        "operationId": "queryCertificates",
        "parameters": [
          {
            "description": "Search by certificate name.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Search certificates by whether or not they contain a private key.\n",
            "in": "query",
            "name": "has_key",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Search certificates by description.",
            "in": "query",
            "name": "description",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Search certificates by expiration.",
            "in": "query",
            "name": "expiration",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Specifies whether to include expired certificates. The default is false.",
            "in": "query",
            "name": "include_expired",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Attribute by which the list of certificates is sorted.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "default": "Name",
              "enum": [
                "name",
                "description",
                "hasKey",
                "expiration"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort order, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "default": "asc",
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CertificateSummaryListResponse"
                }
              }
            },
            "description": "List of certificates."
          }
        },
        "summary": "Get all certificates",
        "tags": [
          "/certificate"
        ],
        "x-group": "certificate"
      },
      "post": {
        "description": "Import a certificate.",
        "operationId": "importCertificate",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CertificateImportRequest"
              }
            }
          },
          "description": "Request to import a certificate.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CertificateSummary"
                }
              }
            },
            "description": "Summary of the certificate."
          }
        },
        "summary": "Import a certificate",
        "tags": [
          "/certificate"
        ],
        "x-group": "certificate"
      }
    },
    "/certificate/agent": {
      "get": {
        "description": "Get all certificates that have been added to the cluster and qualify to be secondary cluster certificates for the Rubrik Backup Service. This call retrieves any certificates that are detected to be Rubrik cluster certificates.",
        "operationId": "queryAgentSecondaryCertificate",
        "parameters": [
          {
            "description": "Filter based on whether or not certificates have been marked for use by agents.",
            "in": "query",
            "name": "is_agent_enabled",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AgentSecondaryCertificateInfoListResponse"
                }
              }
            },
            "description": "List of certificates."
          }
        },
        "summary": "Get all potential agent secondary cluster certificates",
        "tags": [
          "/certificate/agent"
        ],
        "x-group": "certificate"
      },
      "post": {
        "description": "Mark a secondary cluster certificate to be asynchronously synced to all Rubrik Backup Service instances for which this cluster is the primary.",
        "operationId": "markAgentSecondaryCertificate",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "string"
              }
            }
          },
          "description": "ID of certificate to add.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AgentSecondaryCertificateInfo"
                }
              }
            },
            "description": "Information about the certificate"
          }
        },
        "summary": "Mark a certificate to be added to agents",
        "tags": [
          "/certificate/agent"
        ],
        "x-group": "certificate"
      }
    },
    "/certificate/agent/{id}": {
      "delete": {
        "description": "Unmark a previously marked secondary cluster certificate to be asynchronously removed from all Rubrik Backup Service instances for which this cluster is the primary.",
        "operationId": "unmarkAgentSecondaryCertificate",
        "parameters": [
          {
            "description": "ID of certificate to remove.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully removed the certificate."
          }
        },
        "summary": "Unmark a certificate that was previously marked",
        "tags": [
          "/certificate/agent"
        ],
        "x-group": "certificate"
      }
    },
    "/certificate/{id}": {
      "delete": {
        "description": "Deletes an imported certificate.",
        "operationId": "deleteCertificate",
        "parameters": [
          {
            "description": "The certificate ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully removed the certificate."
          }
        },
        "summary": "Delete imported certificate object",
        "tags": [
          "/certificate"
        ],
        "x-group": "certificate"
      },
      "get": {
        "description": "Get a certificate summary.",
        "operationId": "exportCertificate",
        "parameters": [
          {
            "description": "ID of certificate to export.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CertificateSummary"
                }
              }
            },
            "description": "Summary of the certificate to export."
          }
        },
        "summary": "Get a certificate summary to export",
        "tags": [
          "/certificate"
        ],
        "x-group": "certificate"
      },
      "patch": {
        "description": "Provide updated information for a certificate object.",
        "operationId": "updateCertificate",
        "parameters": [
          {
            "description": "ID of certificate object to update.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CertificatePatchRequest"
              }
            }
          },
          "description": "Patch request to update a certificate object.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CertificateSummary"
                }
              }
            },
            "description": "Updated certificate object."
          }
        },
        "summary": "Update a certificate entry",
        "tags": [
          "/certificate"
        ],
        "x-group": "certificate"
      }
    },
    "/cloud_utilization/cloud_out_forecast": {
      "post": {
        "description": "Forecast of the cloud storage and compute utilization on cloud archival location according to the SLA Domain parameters.",
        "operationId": "doCloudOutForecast",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CloudOutForecastRequest"
              }
            }
          },
          "description": "Object that contains the CloudOut forecast request.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CloudOutForecastSummary"
                }
              }
            },
            "description": "Object that contains the CloudOut forecast summary."
          }
        },
        "summary": "Forecast of the cloud utilization for CloudOut",
        "tags": [
          "/cloud_utilization"
        ],
        "x-group": "cloud_utilization"
      }
    },
    "/cluster/me/upgrade/monitor_events": {
      "get": {
        "description": "Gets notifications about events from a specified set of possible events.\n",
        "operationId": "monitorEvents",
        "parameters": [
          {
            "description": "Specifies a list of events to monitor for notifications.",
            "explode": false,
            "in": "query",
            "name": "event_notification_query",
            "required": true,
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/EventNotification"
                  },
                  "type": "array"
                }
              }
            },
            "description": "Name and timestamp of an event sent as a notification.\n"
          }
        },
        "summary": "Get event notifications",
        "tags": [
          "/cluster"
        ],
        "x-group": "cluster"
      }
    },
    "/cluster/{id}": {
      "get": {
        "description": "Retrieve public information about the Rubrik cluster.",
        "operationId": "getPublicClusterInfo",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClusterInfo"
                }
              }
            },
            "description": "Information about the cluster."
          }
        },
        "summary": "Get cluster details",
        "tags": [
          "/cluster"
        ],
        "x-group": "cluster"
      },
      "patch": {
        "description": "Change the properties of a specified Rubrik cluster. Changes to cluster name could take upto 10 minutes to be propagated to all nodes.",
        "operationId": "updateCluster",
        "parameters": [
          {
            "description": "ID of a Rubrik cluster object, or use *me* for the Rubrik cluster that is hosting the current API session.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ClusterUpdate"
              }
            }
          },
          "description": "Array that contains the changed information for the Rubrik cluster object.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClusterInfo"
                }
              }
            },
            "description": "Updated information for a specified Rubrik cluster."
          }
        },
        "summary": "Change Rubrik cluster properties",
        "tags": [
          "/cluster"
        ],
        "x-group": "cluster"
      }
    },
    "/cluster/{id}/api_version": {
      "get": {
        "description": "Retrieves software version of the Rubrik cluster.",
        "operationId": "getClusterApiVersion",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClusterApiVersion"
                }
              }
            },
            "description": "REST API version running on the cluster."
          }
        },
        "security": [],
        "summary": "Get cluster REST API version",
        "tags": [
          "/cluster"
        ],
        "x-group": "cluster",
        "x-unauthenticated": true
      }
    },
    "/cluster/{id}/certificate": {
      "get": {
        "description": "Returns the cluster certificate.",
        "operationId": "getClusterCertificate",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClusterCertificate"
                }
              }
            },
            "description": "Returns the cluster certificate."
          }
        },
        "summary": "Get the cluster certificate",
        "tags": [
          "/cluster"
        ],
        "x-group": "cluster"
      }
    },
    "/cluster/{id}/manual_discover": {
      "post": {
        "description": "Manually specifies mDNS discovery data. Output for this endpoint is identical to the output of the 'discover' endpoint.",
        "operationId": "manualDiscover",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ManualDiscoveryNodeInfo"
              }
            }
          },
          "description": "Manual discovery input data.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ManualDiscoveryNodeInfo"
                }
              }
            },
            "description": "List of nodes available to bootstrap into the specified cluster along with their IPv6 addresses."
          }
        },
        "summary": "Manually discover nodes",
        "tags": [
          "/cluster"
        ],
        "x-group": "cluster",
        "x-unauthenticated": true
      }
    },
    "/cluster/{id}/manual_discover_ipv4": {
      "post": {
        "description": "Manually specifies discovery data. This endpoint output is identical to the output of the 'discover' endpoint.",
        "operationId": "manualDiscoverIpv4",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster, or *me* for the current cluster.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ManualDiscoveryNodeIpv4Info"
              }
            }
          },
          "description": "Manual discovery input data.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ManualDiscoveryNodeIpv4Info"
                }
              }
            },
            "description": "List of nodes available to bootstrap into the specified cluster, including their link-local IPv4 addresses."
          }
        },
        "summary": "Manually discover nodes over IPv4 address",
        "tags": [
          "/cluster"
        ],
        "x-group": "cluster",
        "x-unauthenticated": true
      }
    },
    "/cluster/{id}/node_hostname": {
      "get": {
        "description": "Retrieve the ID to hostname mapping for all the nodes that belong to a specified Rubrik cluster.\n",
        "operationId": "getClusterNodeHostnames",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NodeHostnameInfoListResponse"
                }
              }
            },
            "description": "List of node ID to hostname mappings."
          }
        },
        "summary": "Get the node ID to hostname mapping for all the nodes in a Rubrik cluster\n",
        "tags": [
          "/cluster"
        ],
        "x-group": "cluster"
      },
      "post": {
        "description": "Change hostnames for multiple nodes at a time, for a specified Rubrik cluster.\n",
        "operationId": "changeClusterNodeHostnames",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/NodeHostnameInfo"
                },
                "type": "array"
              }
            }
          },
          "description": "Node ID to hostname mapping.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "Successfully changed hostnames for all the specified nodes in the Rubrik cluster.\n"
          }
        },
        "summary": "Change hostname for nodes in a Rubrik cluster",
        "tags": [
          "/cluster"
        ],
        "x-group": "cluster"
      }
    },
    "/cluster/{id}/node_id": {
      "get": {
        "description": "Retrieve the list of node IDs for the nodes in this Rubrik CDM cluster.",
        "operationId": "getClusterNodeIds",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/NodeId"
                  },
                  "type": "array"
                }
              }
            },
            "description": "List of node IDs."
          }
        },
        "summary": "Get the name of the nodes in the cluster",
        "tags": [
          "/cluster"
        ],
        "x-group": "cluster"
      }
    },
    "/cluster/{id}/rubrik_support_portal_credentials": {
      "get": {
        "description": "Check whether the specified Rubrik cluster has an existing set of credentials for the Rubrik support portal.\n",
        "operationId": "hasRubrikSupportPortalCredentials",
        "parameters": [
          {
            "description": "The ID of a Rubrik cluster, or use *me* for the Rubrik cluster that is hosting the current session.\n",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BooleanResponse"
                }
              }
            },
            "description": "Returns 'True' if the specified Rubrik cluster already has credentials for the Rubrik support portal.\n"
          }
        },
        "summary": "Check credentials to the Rubrik support portal",
        "tags": [
          "/cluster"
        ],
        "x-group": "cluster"
      },
      "post": {
        "description": "Update credentials for the specified Rubrik cluster to connect to the Rubrik support portal.\n",
        "operationId": "updateRubrikSupportPortalCredentials",
        "parameters": [
          {
            "description": "The ID of a Rubrik cluster, or use *me* for the Rubrik cluster that is hosting the current session.\n",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CommunityUserCredentials"
              }
            }
          },
          "description": "The credentials used to connect to the Rubrik support portal.\n",
          "required": true
        },
        "responses": {
          "204": {
            "description": "Successfully updated Rubrik support portal credentials.\n"
          }
        },
        "summary": "Update credentials to the Rubrik support portal",
        "tags": [
          "/cluster"
        ],
        "x-group": "cluster"
      }
    },
    "/cluster/{id}/security/cors": {
      "get": {
        "description": "Get the current CORS support configuration for a web server.",
        "operationId": "getCorsConfiguration",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CorsConfiguration"
                }
              }
            },
            "description": "The current CORS support configuration for a web server."
          }
        },
        "summary": "Get CORS configuration",
        "tags": [
          "/cluster"
        ],
        "x-group": "security"
      },
      "patch": {
        "description": "Update the CORS support configuration for a web server.",
        "operationId": "updateCorsConfiguration",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CorsConfigurationPatch"
              }
            }
          },
          "description": "CORS configuration.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CorsConfiguration"
                }
              }
            },
            "description": "The updated CORS support configuration for a web server."
          }
        },
        "summary": "Update CORS configuration",
        "tags": [
          "/cluster"
        ],
        "x-group": "security"
      }
    },
    "/cluster/{id}/security/encryption": {
      "get": {
        "description": "Get the current encryption at rest status of the cluster.",
        "operationId": "getEncryptionStatus",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EncryptionStatus"
                }
              }
            },
            "description": "The current encryption at rest status for the cluster."
          }
        },
        "summary": "Get encryption at rest status",
        "tags": [
          "/cluster"
        ],
        "x-group": "security"
      }
    },
    "/cluster/{id}/security/fips": {
      "get": {
        "description": "Returns the current status of FIPS on the specified cluster. When the status is true, FIPS is enabled.",
        "operationId": "getFips",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FipsStatus"
                }
              }
            },
            "description": "The current FIPS enablement status for a cluster."
          }
        },
        "summary": "Get FIPS enablement status",
        "tags": [
          "/cluster"
        ],
        "x-group": "security"
      },
      "patch": {
        "description": "Update the current FIPS enablement status for a cluster.",
        "operationId": "updateFips",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FipsStatusPatch"
              }
            }
          },
          "description": "Update FIPS enablement status.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FipsStatus"
                }
              }
            },
            "description": "The current FIPS enablement status for a cluster."
          }
        },
        "summary": "Update FIPS enablement status",
        "tags": [
          "/cluster"
        ],
        "x-group": "security"
      }
    },
    "/cluster/{id}/security/kmip/client": {
      "get": {
        "description": "Return the currently configured KMIP client information. The response object contains empty fields when KMIP is not configured.",
        "operationId": "getKmipClient",
        "parameters": [
          {
            "description": "ID assigned to a Rubrik cluster. Use *me* to refer to the Rubrik cluster that is hosting the current API session.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/KmipClientDetail"
                }
              }
            },
            "description": "Current KMIP client configuration detail."
          }
        },
        "summary": "Get the KMIP client configuration",
        "tags": [
          "/cluster"
        ],
        "x-group": "security"
      },
      "put": {
        "description": "Specify KMIP client credentials for each of the Rubrik cluster nodes.",
        "operationId": "setKmipClient",
        "parameters": [
          {
            "description": "ID assigned to a Rubrik cluster. Use *me* to refer to the Rubrik cluster that is hosting the current API session.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KmipClientConfiguration"
              }
            }
          },
          "description": "KMIP client configuration.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the request for setting client configuration."
          }
        },
        "summary": "Specify KMIP client credentials for nodes",
        "tags": [
          "/cluster"
        ],
        "x-group": "security"
      }
    },
    "/cluster/{id}/security/kmip/server": {
      "delete": {
        "description": "Remove the server with the specified server address from the set of active KMIP servers.",
        "operationId": "deleteKmipServer",
        "parameters": [
          {
            "description": "ID assigned to a Rubrik cluster. Use *me* to refer to the Rubrik cluster that is hosting the current API session.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          },
          {
            "description": "IPv4 address or FQDN (fully qualified domain name) of the KMIP server.",
            "in": "query",
            "name": "server_address",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the request for removing the KMIP server."
          }
        },
        "summary": "Remove the specified KMIP server",
        "tags": [
          "/cluster"
        ],
        "x-group": "security"
      },
      "get": {
        "description": "Returns the KMIP server information for the specified server address. When no server address is specified, this call returns information on all active KMIP servers. The response array is empty when KMIP is not configured or when the server address cannot be found.",
        "operationId": "getKmipServer",
        "parameters": [
          {
            "description": "ID assigned to a Rubrik cluster. Use *me* to refer to the Rubrik cluster that is hosting the current API session.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          },
          {
            "description": "The address of the KMIP server.",
            "in": "query",
            "name": "server_address",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/KmipServerDetail"
                  },
                  "type": "array"
                }
              }
            },
            "description": "Information for the specified KMIP server(s)."
          }
        },
        "summary": "Get KMIP server information",
        "tags": [
          "/cluster"
        ],
        "x-group": "security"
      },
      "put": {
        "description": "Add the specified KMIP server to the set of active KMIP servers.",
        "operationId": "addKmipServer",
        "parameters": [
          {
            "description": "ID assigned to a Rubrik cluster. Use *me* to refer to the Rubrik cluster that is hosting the current API session.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KmipServerConfiguration"
              }
            }
          },
          "description": "Object containing the configuration details for a KMIP server.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the request for setting configuration."
          }
        },
        "summary": "Add a KMIP server",
        "tags": [
          "/cluster"
        ],
        "x-group": "security"
      }
    },
    "/cluster/{id}/security/password_requirements": {
      "get": {
        "description": "Query user password requirements for a cluster.",
        "operationId": "queryPasswordRequirements",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PasswordRequirementsSummary"
                }
              }
            },
            "description": "Active password requirements."
          }
        },
        "summary": "Get password requirements",
        "tags": [
          "/cluster"
        ],
        "x-group": "security"
      },
      "patch": {
        "description": "Update user password requirements for a cluster.",
        "operationId": "patchPasswordRequirements",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PasswordRequirementsPatchRequest"
              }
            }
          },
          "description": "Password requirements.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PasswordRequirementsSummary"
                }
              }
            },
            "description": "Succesfully patched password requirements."
          }
        },
        "summary": "Set password requirements",
        "tags": [
          "/cluster"
        ],
        "x-group": "security"
      }
    },
    "/cluster/{id}/security/totp/setting": {
      "get": {
        "description": "Returns TOTP global setting, including whether TOTP is enforced or not.",
        "operationId": "getTotpGlobalSetting",
        "parameters": [
          {
            "description": "ID assigned to a Rubrik cluster. Use *me* to refer to the Rubrik cluster that is hosting the current API session.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TotpGlobalSetting"
                }
              }
            },
            "description": "TOTP global setting for the specified Rubrik cluster."
          }
        },
        "summary": "Get global TOTP setting",
        "tags": [
          "/cluster"
        ],
        "x-group": "security"
      },
      "put": {
        "description": "Update TOTP global setting, including whether TOTP is enforced or not.",
        "operationId": "updateTotpGlobalSetting",
        "parameters": [
          {
            "description": "ID assigned to a Rubrik cluster. Use *me* to refer to the Rubrik cluster that is hosting the current API session.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TotpGlobalSettingUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TotpGlobalSetting"
                }
              }
            },
            "description": "Updated TOTP global setting for the specified Rubrik cluster."
          }
        },
        "summary": "Update TOTP global setting",
        "tags": [
          "/cluster"
        ],
        "x-group": "security"
      }
    },
    "/cluster/{id}/security/truststore": {
      "delete": {
        "description": "Remove certificate associated with specified truststore.",
        "operationId": "unsetTruststoreCertificate",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          },
          {
            "description": "Comma separated list of truststore types.",
            "explode": false,
            "in": "query",
            "name": "truststores",
            "required": true,
            "schema": {
              "items": {
                "enum": [
                  "System",
                  "Gcp"
                ],
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          }
        ],
        "responses": {
          "204": {
            "description": "OK on success."
          }
        },
        "summary": "Remove certificate associated with specified truststore",
        "tags": [
          "/cluster"
        ],
        "x-group": "security"
      },
      "get": {
        "description": "Get summary of all truststores.",
        "operationId": "getTruststores",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TruststoreSummaryListResponse"
                }
              }
            },
            "description": "List of truststore summaries."
          }
        },
        "summary": "Get summary of all truststores",
        "tags": [
          "/cluster"
        ],
        "x-group": "security"
      },
      "patch": {
        "description": "Setting the given certificate for each node's truststores.",
        "operationId": "setTruststoreCertificate",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/TruststorePayload"
                },
                "type": "array"
              }
            }
          },
          "description": "Request to update certificate for truststore.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "OK on success."
          }
        },
        "summary": "Set certificates for one or more truststores",
        "tags": [
          "/cluster"
        ],
        "x-group": "security"
      }
    },
    "/cluster/{id}/security/web_signed_cert": {
      "delete": {
        "description": "Resetting the customer-given certificate for each node's web server.",
        "operationId": "resetWebSignedCertificate",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the request for resetting the certificate."
          }
        },
        "summary": "Reset the signed certificate for Web server",
        "tags": [
          "/cluster"
        ],
        "x-group": "security"
      },
      "get": {
        "description": "If the web server uses a signed certificate, fetch it.",
        "operationId": "getWebSignedCertificate",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebServerCertificateSummary"
                }
              }
            },
            "description": "Signed certificate of the web server."
          }
        },
        "summary": "Get the signed certificate for Web server",
        "tags": [
          "/cluster"
        ],
        "x-group": "security"
      },
      "put": {
        "description": "Setting the given certificate for each node's web server to use.",
        "operationId": "setWebSignedCertificate",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebServerCertificatePayload"
              }
            }
          },
          "description": "Request to update certificate for web server.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the request for setting certificate."
          }
        },
        "summary": "Set a signed certificate for Web server",
        "tags": [
          "/cluster"
        ],
        "x-group": "security"
      }
    },
    "/cluster/{id}/snmp_mib_link": {
      "get": {
        "description": "Retrieve the download link for the Rubrik SNMP MIB file. The retrieval is a synchronous operation.",
        "operationId": "getRubrikSnmpMibDownloadLink",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RubrikMibFileDownloadLink"
                }
              }
            },
            "description": "Download link for the Rubrik SNMP MIB file."
          }
        },
        "summary": "Get the link for Rubrik SNMP MIB file",
        "tags": [
          "/cluster"
        ],
        "x-group": "cluster"
      }
    },
    "/cluster/{id}/syslog_msg_mib_link": {
      "get": {
        "description": "Retrieve the download link for the SYSLOG-MSG-MIB file. The retrieval is a synchronous operation.",
        "operationId": "getSyslogMsgSnmpMibDownloadLink",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SyslogMsgMibFileDownloadLink"
                }
              }
            },
            "description": "Download link for the SYSLOG-MSG-MIB file."
          }
        },
        "summary": "Get the link for SYSLOG-MSG-MIB file",
        "tags": [
          "/cluster"
        ],
        "x-group": "cluster"
      }
    },
    "/cluster/{id}/syslog_tc_mib_link": {
      "get": {
        "description": "Retrieve the download link for the SYSLOG-TC-MIB file. The retrieval is a synchronous operation.",
        "operationId": "getSyslogTcSnmpMibDownloadLink",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SyslogTcMibFileDownloadLink"
                }
              }
            },
            "description": "Download link for the SYSLOG-TC-MIB file."
          }
        },
        "summary": "Get the link for SYSLOG-TC-MIB file",
        "tags": [
          "/cluster"
        ],
        "x-group": "cluster"
      }
    },
    "/cluster/{id}/upgrade/available_version": {
      "get": {
        "description": "Retrieve a list of Rubrik CDM versions available to upgrade the Rubrik cluster.",
        "operationId": "availableVersion",
        "parameters": [
          {
            "description": "The ID of the Rubrik cluster. To query the local cluster, use *me*.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          },
          {
            "description": "A string that filters the results based on the prefix. For example, the string \"5.1\" filters all releases in the 5.1 family. If more than one result is desired then this parameter can be used in conjunction with the `show_all` parameter.",
            "in": "query",
            "name": "filter_version",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Include a download URL for the single version passed in the 'filter_version' parameter. A link response will not be provided if the chosen version is locally available, or if 'filter_version' is not specified.\n",
            "in": "query",
            "name": "fetch_links",
            "required": false,
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "The source version of Rubrik CDM used for the upgradeability check if 'filter_upgradable' if specified. If 'filter_upgradable' is not specified, this parameter is ignored.\n",
            "in": "query",
            "name": "source_version",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "If specified, ignore locally available versions.",
            "in": "query",
            "name": "ignore_local",
            "required": false,
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "If specified, ignore versions available in the Rubrik remote central repository.\n",
            "in": "query",
            "name": "ignore_remote",
            "required": false,
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "If specified, ignore versions currently being downloaded.",
            "in": "query",
            "name": "ignore_downloading",
            "required": false,
            "schema": {
              "default": true,
              "type": "boolean"
            }
          },
          {
            "description": "If specified, filter results for downloading versions to the provided job instance ID.\n",
            "in": "query",
            "name": "download_job_instance_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "When this parameter is set, the query only returns versions of the Rubrik CDM that can be upgraded to from the version specified in the 'source_version' parameter. If 'source_version' is not specified, we use the cluster version as the source_version.\n",
            "in": "query",
            "name": "filter_upgradable",
            "required": false,
            "schema": {
              "default": true,
              "type": "boolean"
            }
          },
          {
            "description": "When this parameter is set, the query shows all patch releases including releases with a newer version released in the same family. When set to false, the query returns only the latest version from each release family.\n",
            "in": "query",
            "name": "show_all",
            "required": false,
            "schema": {
              "default": false,
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/AvailableVersionInfo"
                  },
                  "type": "array"
                }
              }
            },
            "description": "List of available software versions."
          }
        },
        "summary": "Retrieve CDM versions available for upgrade",
        "tags": [
          "/cluster"
        ],
        "x-group": "cluster"
      }
    },
    "/cluster/{id}/upgrade/precheck_status": {
      "get": {
        "description": "Get the result of the latest run of the upgrade prechecks.\n",
        "operationId": "getPeriodicUpgradePrechecksStatus",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          },
          {
            "description": "If specified, fetch information corresponding to next upgrade prechecks job instance. If an upgrade prechecks job instance is currently running, results corresponding to it are returned.\n",
            "in": "query",
            "name": "fetch_next_run_info",
            "required": false,
            "schema": {
              "default": false,
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PrecheckStatusResponse"
                }
              }
            },
            "description": "Returns the list of precheck failures during the latest run of the upgrade prechecks job.\n"
          }
        },
        "summary": "Get the result of the latest run of the upgrade prechecks",
        "tags": [
          "/cluster"
        ],
        "x-group": "cluster"
      },
      "post": {
        "description": "Start an on demand run of the prechecks.\n",
        "operationId": "runPeriodicUpgradePrechecks",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of an asynchronous request."
          }
        },
        "summary": "Start an on demand run of the prechecks",
        "tags": [
          "/cluster"
        ],
        "x-group": "cluster"
      }
    },
    "/cluster/{id}/upgrade/request/{request_id}": {
      "get": {
        "description": "Get asynchronous request details for an upgrade request.",
        "operationId": "getAsyncRequestStatusForUpgrade",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          },
          {
            "description": "ID of the request.",
            "in": "path",
            "name": "request_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of an asynchronous request."
          }
        },
        "summary": "Get asynchronous request details",
        "tags": [
          "/cluster"
        ],
        "x-group": "cluster"
      }
    },
    "/cluster/{id}/upgrade/stage_cdm_software": {
      "post": {
        "description": "Stage software corresponding to a given CDM version on the cluster, in preparation for an upgrade.",
        "operationId": "stageCdmSoftware",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StageCdmSoftwareInfo"
              }
            }
          },
          "description": "Information about the provided CDM software package.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "ID of the stage CDM software job."
          }
        },
        "summary": "Stage software on CDM for upgrade",
        "tags": [
          "/cluster"
        ],
        "x-group": "cluster"
      }
    },
    "/cluster/{id}/version": {
      "get": {
        "description": "Retrieves software version of the Rubrik cluster.",
        "operationId": "getClusterVersion",
        "parameters": [
          {
            "description": "ID of the Rubrik cluster or *me* for self.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClusterVersion"
                }
              }
            },
            "description": "Software version running on the cluster."
          }
        },
        "security": [],
        "summary": "Get cluster software version",
        "tags": [
          "/cluster"
        ],
        "x-group": "cluster",
        "x-unauthenticated": true
      }
    },
    "/config/history/list_updates": {
      "get": {
        "description": "View a list of cluster configuration options that have updated within a specified time window.",
        "operationId": "queryConfigurationHistoryUpdates",
        "parameters": [
          {
            "description": "Limit the number of matches returned.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Ignore these many matches in the beginning.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "The username of the account. Applies a filter to the configuration updates performed by the specified username.",
            "in": "query",
            "name": "api_user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The node ID. Applies a filter to the configuration updates for the specified node. When no node_id is specified, the filter shows both local and cluster-wide configurations. Specify 'cluster' for filtering out cluster-wide configuration updates.",
            "in": "query",
            "name": "node_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The configuration namespace. Applies a filter to the configuration updates for the specified namespace.",
            "in": "query",
            "name": "namespace",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Name of the configuration. Applies a filter to the configuration updates for the specified configuration name.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Source for configuration updates. Applies a filter to the configuration updates for the specified source.",
            "in": "query",
            "name": "source",
            "required": false,
            "schema": {
              "enum": [
                "Unknown",
                "CustomerApi",
                "Upgrade",
                "ResetNode",
                "Software",
                "Init"
              ],
              "type": "string"
            }
          },
          {
            "description": "The earliest time configuration history is needed. Applies a filter that only shows configuration updates after the specified time.",
            "in": "query",
            "name": "after_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "The latest time configuration history is needed. Applies filter to display only configuration updates prior to the specified time. The default value is the current time.",
            "in": "query",
            "name": "before_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConfigurationUpdateSummaryListResponse"
                }
              }
            },
            "description": "A summary of configuration updates that satisfy the filters in place."
          }
        },
        "summary": "View a list of filtered configuration updates",
        "tags": [
          "/config/history"
        ],
        "x-group": "config_history"
      }
    },
    "/config/history/ondate": {
      "get": {
        "description": "View a list of configurations and their values on a given date.",
        "operationId": "retrieveConfigurationValues",
        "parameters": [
          {
            "description": "Limit the number of matches returned.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Ignore these many matches in the beginning.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "The name of the node that require configuration values. Applies a filter specific to the name of node. When no node_id is specified, the filter shows both local and cluster-wide configurations.",
            "in": "query",
            "name": "node_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The configuration namespace. Applies a filter to the configuration updates for the specified namespace.",
            "in": "query",
            "name": "namespace",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The name of the configuration option. Applies a filter to the configuration updates for the specified option.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The timestamp for which to retrieve configuration values.",
            "in": "query",
            "name": "on_date",
            "required": true,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConfigurationSummaryListResponse"
                }
              }
            },
            "description": "Summary of the values of configuration options, as of a specified timestamp, that match the filters in place."
          }
        },
        "summary": "View a list of configurations and their values on a given date",
        "tags": [
          "/config/history"
        ],
        "x-group": "config_history"
      }
    },
    "/csr": {
      "get": {
        "description": "Returns a list of summaries for every outstanding certificate signing request (CSR).",
        "operationId": "getAllCsrs",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CsrSummaryListResponse"
                }
              }
            },
            "description": "List of certifcate signing requests."
          }
        },
        "summary": "Get all certificate signing requests",
        "tags": [
          "/csr"
        ],
        "x-group": "certificate"
      },
      "post": {
        "description": "Generates a new private key and returns a base64 encoded PKCS#10 certificate signing request (CSR).",
        "operationId": "generateCsr",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GenericCsrRequest"
              }
            }
          },
          "description": "Information for client certificate request.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CsrSummary"
                }
              }
            },
            "description": "Certificate signing request."
          }
        },
        "summary": "Generate a new private key and return a certificate signing request",
        "tags": [
          "/csr"
        ],
        "x-group": "certificate"
      }
    },
    "/csr/{id}": {
      "delete": {
        "description": "Deletes a certificate signing request corresponding to the provided ID.",
        "operationId": "deleteCsr",
        "parameters": [
          {
            "description": "Certificate signing request ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Returned if delete completes successfully."
          }
        },
        "summary": "Delete a certificate signing request",
        "tags": [
          "/csr"
        ],
        "x-group": "certificate"
      }
    },
    "/data_source/snapshot/bulk_delete": {
      "post": {
        "description": "This endpoint deletes all snapshots from all locations for the objects with the IDs specified by the 'objectIds' parameter. API returning success does not guarantee that the snapshots will be expired.\n",
        "operationId": "bulkDeleteSnapshots",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BulkDeleteSnapshotsConfig"
              }
            }
          },
          "description": "A list of object IDs.\n",
          "required": true
        },
        "responses": {
          "204": {
            "description": "OK on success, success doesn't imply all snapshots will be deleted.\n"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RequestFailedException"
                }
              }
            },
            "description": "Returned if delete API fails."
          }
        },
        "summary": "Bulk delete all snapshots for the given objects",
        "tags": [
          "/data_source"
        ],
        "x-group": "data_source"
      }
    },
    "/data_source/{id}/expired_custom_retention_snapshots": {
      "get": {
        "description": "Gets a list of the snapshots of a specified data source that have expired according to the snapshot-level SLA Domain assignments. This list does not include remote snapshots.\n",
        "operationId": "expiredCustomRetentionSnapshots",
        "parameters": [
          {
            "description": "The object ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExpiredCustomRetentionSnapshots"
                }
              }
            },
            "description": "Array containing information of snapshots which have been expired due to snapshot-level SLA Domain assignments.\n"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RequestFailedException"
                }
              }
            },
            "description": "The API call has failed."
          }
        },
        "summary": "Returns a list of snapshots that have expired according to their snapshot-level SLA Domain assignments\n",
        "tags": [
          "/data_source"
        ],
        "x-group": "data_source"
      }
    },
    "/data_source/{id}/snapshot/bulk_delete": {
      "post": {
        "description": "Bulk deletion of the snapshots specified by a list of snapshot IDs for a given object. Object type is required. Location ID is optional. API returning success does not guarantee that the snapshot will be expired.\n",
        "operationId": "bulkDeleteSnapshotsForObject",
        "parameters": [
          {
            "description": "ID of the object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BulkDeleteObjectSnapshotsConfig"
              }
            }
          },
          "description": "A list of snapshot IDs specifying snapshots to delete. Optionally specifies a location ID. Snapshot deletion is global when the location ID is absent.\n",
          "required": true
        },
        "responses": {
          "204": {
            "description": "OK on success, success doesn't imply all snapshots will be deleted.\n"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RequestFailedException"
                }
              }
            },
            "description": "Returned if delete API fails."
          }
        },
        "summary": "Bulk delete specified snapshots for the given object",
        "tags": [
          "/data_source"
        ],
        "x-group": "data_source"
      }
    },
    "/database/log_report": {
      "get": {
        "description": "Get the database log backup delay information.",
        "operationId": "queryLogReport",
        "parameters": [
          {
            "description": "Filter by effective SLA domain.",
            "in": "query",
            "name": "effective_sla_domain_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by the database name substring.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by the database type.",
            "in": "query",
            "name": "database_type",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by the database location.",
            "in": "query",
            "name": "location",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by the database log backup delay in seconds, greater than this value.",
            "in": "query",
            "name": "log_backup_delay",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Limit the number of matches returned.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Integer specifying the number of initial matches to ignore.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Specifies the attribute to use while sorting the summary information. Performs an ASCII sort using the specified attribute, in the order specified by sort_order.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "effectiveSlaDomainName",
                "name",
                "location",
                "databaseType",
                "logBackupFrequency",
                "lastSnapshotTime",
                "latestRecoveryTime",
                "logBackupDelay"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort order, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DbLogReportSummaryListResponse"
                }
              }
            },
            "description": "If the query was successful, Returns the array of DbLogReportSummary objects."
          }
        },
        "summary": "Get the database log backup delay information",
        "tags": [
          "/database/log_report"
        ],
        "x-group": "database_log_report"
      }
    },
    "/database/log_report/defaults": {
      "get": {
        "description": "Get the properties for the database (SQL and Oracle) log backup delay email notification creation. The properties are logDelayThresholdInMin and logDelayNotificationFrequencyInMin.",
        "operationId": "queryReportProperties",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DbLogReportProperties"
                }
              }
            },
            "description": "Returns the current properties of logDelayThresholdInMin and logDelayNotificationFrequencyInMin."
          }
        },
        "summary": "Get the database log backup report properties",
        "tags": [
          "/database/log_report"
        ],
        "x-group": "database_log_report"
      },
      "patch": {
        "description": "Update the properties for the database (SQL and Oracle) log backup delay email notification creation. The properties are logDelayThresholdInMin and logDelayNotificationFrequencyInMin.",
        "operationId": "updateReportProperties",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DbLogReportPropertiesUpdate"
              }
            }
          },
          "description": "Updated report properties.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DbLogReportProperties"
                }
              }
            },
            "description": "Returns the updated properties of logDelayThresholdInMin and logDelayNotificationFrequencyInMin."
          }
        },
        "summary": "Update the database log backup report properties",
        "tags": [
          "/database/log_report"
        ],
        "x-group": "database_log_report"
      }
    },
    "/event": {
      "get": {
        "description": "Returns information for all events. Only Global or Read Only Admins and Support users have authorization to use this endpoint. Accepts filters. For similar functionality to the previous /internal/event endpoint, use the /v1/event/latest endpoint.",
        "operationId": "queryEventV1",
        "parameters": [
          {
            "description": "Maximum number of events retrieved.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "An (event_id, time) tuple. When specified, returns all events with timestamps that come after the time value of after_id based on the sort order defined by the order_by_time parameter.",
            "in": "query",
            "name": "after_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter the events occurring after the specified date.",
            "in": "query",
            "name": "before_date",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "Filter the events occurring before the specified date.",
            "in": "query",
            "name": "after_date",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "The events are ordered by timestamp. Specify desc to show the latest entries first. Specify asc to show the oldest entries first. The default behavior is asc.",
            "in": "query",
            "name": "order_by_time",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          {
            "description": "A Boolean value that determines whether to include event series summary for every event. If set to 'true', a list of event series summary will be returned and each summary has an empty list of events. If set to 'false', an empty list of event series summary will be returned. The default value is 'false'. Setting it to 'true' will increase the response time.",
            "in": "query",
            "name": "should_include_event_series",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventsAndSeriesSummariesV1"
                }
              }
            },
            "description": "Returns information for the events that match the query parameters."
          }
        },
        "summary": "Get information for all events",
        "tags": [
          "/event"
        ],
        "x-group": "events"
      }
    },
    "/event/csv_download_link": {
      "get": {
        "description": "Download summary of the related events that match the value specified in the following categories: event type, status, object name or ID, eventSeriesId, object type, and limit events by dates.",
        "operationId": "getEventsCsvDownloadLink",
        "parameters": [
          {
            "description": "Maximum number of events to retrieve. Default value is 100.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Filter by the current status of the event series.",
            "in": "query",
            "name": "event_series_status",
            "required": false,
            "schema": {
              "enum": [
                "Success",
                "Failure",
                "Scheduled",
                "Active",
                "Canceling",
                "Canceled",
                "SuccessWithWarnings"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter by the status of the latest event in the event series.",
            "in": "query",
            "name": "event_status",
            "required": false,
            "schema": {
              "enum": [
                "Failure",
                "Warning",
                "Info",
                "Running",
                "Queued",
                "Success",
                "Canceled",
                "Canceling",
                "TaskSuccess"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter by the type of the latest event in the event series.",
            "in": "query",
            "name": "event_type",
            "required": false,
            "schema": {
              "enum": [
                "Archive",
                "Audit",
                "AuthDomain",
                "AwsEvent",
                "Backup",
                "Classification",
                "CloudNativeSource",
                "CloudNativeVm",
                "Configuration",
                "Connection",
                "Conversion",
                "Diagnostic",
                "Discovery",
                "Failover",
                "Fileset",
                "Hardware",
                "HostEvent",
                "HypervScvmm",
                "HypervServer",
                "Index",
                "Instantiate",
                "LegalHold",
                "Maintenance",
                "NutanixCluster",
                "Recovery",
                "Replication",
                "ResourceOperations",
                "Storage",
                "StorageArray",
                "StormResource",
                "Support",
                "System",
                "TestFailover",
                "Upgrade",
                "VCenter",
                "Vcd",
                "VolumeGroup",
                "UnknownEventType"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter by the severity of the latest event in the event series.",
            "in": "query",
            "name": "event_severity",
            "required": false,
            "schema": {
              "enum": [
                "Critical",
                "Warning",
                "Informational"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter the object IDs in the latest event series by matches to a comma-separated list of object IDs.",
            "explode": false,
            "in": "query",
            "name": "object_ids",
            "required": false,
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          },
          {
            "description": "Filter the events in the event series by a specified object type.",
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "enum": [
                "AggregateAhvVm",
                "AggregateAwsAzure",
                "AggregateHypervVm",
                "AggregateLinuxUnixHosts",
                "AggregateNasShares",
                "AggregateOracleDb",
                "AggregateSapHanaDb",
                "AggregateStorageArrays",
                "AggregateVcdVapps",
                "AggregateVsphereVm",
                "AggregateWindowsHosts",
                "AppBlueprint",
                "AppFlows",
                "AuthDomain",
                "AwsAccount",
                "AwsEventType",
                "Certificate",
                "Cluster",
                "ComputeInstance",
                "DataLocation",
                "Ec2Instance",
                "Envoy",
                "Host",
                "HypervScvmm",
                "HypervServer",
                "HypervVm",
                "JobInstance",
                "Ldap",
                "LinuxHost",
                "LinuxFileset",
                "ManagedVolume",
                "Mssql",
                "NasHost",
                "NutanixCluster",
                "NutanixVm",
                "OracleDb",
                "OracleHost",
                "OracleRac",
                "PublicCloudMachineInstance",
                "SamlSso",
                "SapHanaDb",
                "SapHanaSystem",
                "ShareFileset",
                "SlaDomain",
                "SmbDomain",
                "StorageArray",
                "StorageArrayVolumeGroup",
                "Storm",
                "SupportBundle",
                "UnknownObjectType",
                "Upgrade",
                "UserActionAudit",
                "Vcd",
                "VcdVapp",
                "Vcenter",
                "VmwareVm",
                "VolumeGroup",
                "WindowsHost",
                "WindowsFileset"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter latest events according to the provided name using prefix search for resources and exact search for usernames.",
            "in": "query",
            "name": "object_name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "An (event_series_id, time) tuple. When specified, returns all event series whose latest event timestamp comes after the time value of after_id based on the sort order defined by the order_by_time parameter.",
            "in": "query",
            "name": "after_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter out event series that have events occurring after the specified date.",
            "in": "query",
            "name": "before_date",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "Filter out event series that have events occurring before the specified date.",
            "in": "query",
            "name": "after_date",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "The events in a series are ordered by timestamp. Specify desc to show the latest entries first. Specify asc to show the oldest entries first. The default behavior is desc.",
            "in": "query",
            "name": "order_by_time",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventCsvDownloadResponse"
                }
              }
            },
            "description": "Returns the download link of the csv."
          }
        },
        "summary": "Download summary of events as a CSV file",
        "tags": [
          "/event"
        ],
        "x-group": "events"
      }
    },
    "/event/latest": {
      "get": {
        "description": "Get the latest event, event series status, and the number of warning events for all event series. This endpoint has similar/enhanced functionality to the previously deprecated /internal/event endpoint.",
        "operationId": "queryLatestEventsV1",
        "parameters": [
          {
            "description": "Maximum number of events retrieved.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Filter by the current status of the event series.",
            "in": "query",
            "name": "event_series_status",
            "required": false,
            "schema": {
              "enum": [
                "Success",
                "Failure",
                "Scheduled",
                "Active",
                "Canceling",
                "Canceled",
                "SuccessWithWarnings"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter by the status of the latest event in the event series.",
            "in": "query",
            "name": "event_status",
            "required": false,
            "schema": {
              "enum": [
                "Failure",
                "Warning",
                "Info",
                "Running",
                "Queued",
                "Success",
                "Canceled",
                "Canceling",
                "TaskSuccess"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter by the type of the latest event in the event series.",
            "in": "query",
            "name": "event_type",
            "required": false,
            "schema": {
              "enum": [
                "Archive",
                "Audit",
                "AuthDomain",
                "AwsEvent",
                "Backup",
                "Classification",
                "CloudNativeSource",
                "CloudNativeVm",
                "Configuration",
                "Connection",
                "Conversion",
                "Diagnostic",
                "Discovery",
                "Failover",
                "Fileset",
                "Hardware",
                "HostEvent",
                "HypervScvmm",
                "HypervServer",
                "Index",
                "Instantiate",
                "LegalHold",
                "Maintenance",
                "NutanixCluster",
                "Recovery",
                "Replication",
                "ResourceOperations",
                "Storage",
                "StorageArray",
                "StormResource",
                "Support",
                "System",
                "TestFailover",
                "Upgrade",
                "VCenter",
                "Vcd",
                "VolumeGroup",
                "UnknownEventType"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter by the severity of the latest event in the event series.",
            "in": "query",
            "name": "event_severity",
            "required": false,
            "schema": {
              "enum": [
                "Critical",
                "Warning",
                "Informational"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter the object IDs in the latest event series by matches to a comma-separated list of object IDs.",
            "explode": false,
            "in": "query",
            "name": "object_ids",
            "required": false,
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          },
          {
            "description": "Filter the events in the event series by a specified object type.",
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "enum": [
                "AggregateAhvVm",
                "AggregateAwsAzure",
                "AggregateHypervVm",
                "AggregateLinuxUnixHosts",
                "AggregateNasShares",
                "AggregateOracleDb",
                "AggregateSapHanaDb",
                "AggregateStorageArrays",
                "AggregateVcdVapps",
                "AggregateVsphereVm",
                "AggregateWindowsHosts",
                "AppBlueprint",
                "AppFlows",
                "AuthDomain",
                "AwsAccount",
                "AwsEventType",
                "Certificate",
                "Cluster",
                "ComputeInstance",
                "DataLocation",
                "Ec2Instance",
                "Envoy",
                "Host",
                "HypervScvmm",
                "HypervServer",
                "HypervVm",
                "JobInstance",
                "Ldap",
                "LinuxHost",
                "LinuxFileset",
                "ManagedVolume",
                "Mssql",
                "NasHost",
                "NutanixCluster",
                "NutanixVm",
                "OracleDb",
                "OracleHost",
                "OracleRac",
                "PublicCloudMachineInstance",
                "SamlSso",
                "SapHanaDb",
                "SapHanaSystem",
                "ShareFileset",
                "SlaDomain",
                "SmbDomain",
                "StorageArray",
                "StorageArrayVolumeGroup",
                "Storm",
                "SupportBundle",
                "UnknownObjectType",
                "Upgrade",
                "UserActionAudit",
                "Vcd",
                "VcdVapp",
                "Vcenter",
                "VmwareVm",
                "VolumeGroup",
                "WindowsHost",
                "WindowsFileset"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter latest events according to the provided name using prefix search for resources and exact search for usernames.",
            "in": "query",
            "name": "object_name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "An (event_series_id, time) tuple. When specified, returns all event series whose latest event timestamp comes after the time value of after_id based on the sort order defined by the order_by_time parameter.",
            "in": "query",
            "name": "after_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter out event series that have events occurring after the specified date.",
            "in": "query",
            "name": "before_date",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "Filter out event series that have events occurring before the specified date.",
            "in": "query",
            "name": "after_date",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "The events in a series are ordered by timestamp. Specify desc to show the latest entries first. Specify asc to show the oldest entries first. The default behavior is desc.",
            "in": "query",
            "name": "order_by_time",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          {
            "description": "A Boolean value that determines whether to include all events in the event series. The default value is 'false'. Setting it to 'true' will significantly increase the response time.",
            "in": "query",
            "name": "should_include_event_series",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ActivityLogSummaryV1ListResponse"
                }
              }
            },
            "description": "Returns information for the events that match the query parameters."
          }
        },
        "summary": "Get latest events with their associated event series information",
        "tags": [
          "/event"
        ],
        "x-group": "events"
      }
    },
    "/event_series/{id}": {
      "get": {
        "description": "Gets all events, event series, SLA Domain, and object information that is associated with a specified event series ID.",
        "operationId": "queryEventSeriesByIdV1",
        "parameters": [
          {
            "description": "The ID of the event series.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventSeriesSummaryV1"
                }
              }
            },
            "description": "Returns the list of events by event series ID and a summary of the event series."
          }
        },
        "summary": "Get all events and relevant information associated with an event series ID",
        "tags": [
          "/event_series"
        ],
        "x-group": "events"
      }
    },
    "/exclusion_pattern": {
      "get": {
        "description": "Get a summary of all exclusion patterns.",
        "operationId": "queryExclusionPattern",
        "parameters": [
          {
            "description": "Filter a response by making an infix comparison of the exclusion patttern in the response with the specified value.",
            "in": "query",
            "name": "pattern",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter a response based on the mutability of the pattern.",
            "in": "query",
            "name": "is_mutable",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Filter a response based on the protectable object to which the exclusion pattern applies.",
            "in": "query",
            "name": "source_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limit a response to the results that have the specified primary cluster value.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limit the summary information to a specified maximum number of matches. Optionally, use with offset to start the count at a specified point. Optionally, use with sort_by to perform sort on given attributes. Include sort_order to determine the ascending or descending direction of the sort.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Starting position in the list of matches. The response includes the specified numbered entry and all higher numbered entries. Use with limit to retrieve the response as smaller groups of entries, for example for paging of results.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Specifies a comma-separated list of attributes to use in sorting the matches. Performs an ASCII sort of the values in the response using each specified attribute, in the order specified.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "pattern"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort order, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "default": "asc",
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExclusionPatternDetailListResponse"
                }
              }
            },
            "description": "Successful query results for exclusion pattern."
          }
        },
        "summary": "Get a summary of all exclusion patterns",
        "tags": [
          "/exclusion_pattern"
        ],
        "x-group": "exclusion_pattern"
      },
      "post": {
        "description": "Create a exclusion pattern.",
        "operationId": "createExclusionPattern",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExclusionPatternCreateConfig"
              }
            }
          },
          "description": "Create configuration parameters for a exclusion pattern.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExclusionPatternDetail"
                }
              }
            },
            "description": "Details of the new exclusion pattern."
          },
          "404": {
            "description": "Failed to create exclusion pattern."
          },
          "422": {
            "description": "Failed to create exclusion pattern on replication target cluster."
          }
        },
        "summary": "Create an exclusion pattern",
        "tags": [
          "/exclusion_pattern"
        ],
        "x-group": "exclusion_pattern"
      }
    },
    "/exclusion_pattern/bulk": {
      "delete": {
        "description": "Bulk deletes the mutable patterns in a specified set of exclusion patterns.",
        "operationId": "bulkDeleteExclusionPattern",
        "parameters": [
          {
            "description": "The ID of each exclusion pattern to delete.",
            "explode": false,
            "in": "query",
            "name": "ids",
            "required": true,
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully deleted all the specified exclusion patterns."
          },
          "404": {
            "description": "The exclusion pattern deletion failed for at least one exclusion pattern."
          }
        },
        "summary": "Bulk delete the provided mutable exclusion patterns",
        "tags": [
          "/exclusion_pattern"
        ],
        "x-group": "exclusion_pattern"
      },
      "post": {
        "description": "Bulk create exclusion patterns.",
        "operationId": "bulkCreateExclusionPattern",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/ExclusionPatternCreateConfig"
                },
                "type": "array"
              }
            }
          },
          "description": "Create configuration parameters for a exclusion pattern.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExclusionPatternDetailList"
                }
              }
            },
            "description": "Details of new exclusion patterns."
          },
          "404": {
            "description": "Failed to create exclusion pattern."
          },
          "422": {
            "description": "Failed to create exclusion pattern on replication target cluster."
          }
        },
        "summary": "Bulk create exclusion patterns",
        "tags": [
          "/exclusion_pattern"
        ],
        "x-group": "exclusion_pattern"
      }
    },
    "/exclusion_pattern/{id}": {
      "delete": {
        "description": "Deletes an exclusion pattern if that pattern is mutable.",
        "operationId": "deleteExclusionPattern",
        "parameters": [
          {
            "description": "ID of the exclusion pattern.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully deleted the specified exclusion pattern."
          },
          "403": {
            "description": "Failed to delete a immutable exclusion pattern."
          },
          "404": {
            "description": "Failed to delete exclusion pattern."
          }
        },
        "summary": "Delete a mutable exclusion pattern",
        "tags": [
          "/exclusion_pattern"
        ],
        "x-group": "exclusion_pattern"
      },
      "get": {
        "description": "Get details of a exclusion pattern.",
        "operationId": "getExclusionPattern",
        "parameters": [
          {
            "description": "ID of the exclusion pattern.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExclusionPatternDetail"
                }
              }
            },
            "description": "Details about the exclusion pattern."
          },
          "404": {
            "description": "Failed to get exclusion pattern."
          }
        },
        "summary": "Get details of a exclusion pattern",
        "tags": [
          "/exclusion_pattern"
        ],
        "x-group": "exclusion_pattern"
      },
      "post": {
        "description": "Update mutable exclusion pattern with specified properties. The exclusion pattern which is mutable can be modified.",
        "operationId": "updateExclusionPattern",
        "parameters": [
          {
            "description": "ID of exclusion pattern.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExclusionPatternUpdateConfig"
              }
            }
          },
          "description": "Properties to update.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExclusionPatternDetail"
                }
              }
            },
            "description": "Return details about the exclusion pattern."
          },
          "403": {
            "description": "Failed to update a immutable exclusion pattern."
          },
          "404": {
            "description": "Failed to update exclusion pattern."
          }
        },
        "summary": "Update a mutable exclusion pattern",
        "tags": [
          "/exclusion_pattern"
        ],
        "x-group": "exclusion_pattern"
      }
    },
    "/failover_cluster": {
      "get": {
        "description": "Get a summary of all failover clusters.",
        "operationId": "queryFailoverCluster",
        "parameters": [
          {
            "description": "Filter a response by making an infix comparison of the failover cluster name in the response, with the specified value.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter a response based on the operating system type.",
            "in": "query",
            "name": "operating_system_type",
            "required": false,
            "schema": {
              "enum": [
                "ANY",
                "AIX",
                "HPUX",
                "Linux",
                "SunOS",
                "UnixLike",
                "Windows"
              ],
              "type": "string"
            }
          },
          {
            "description": "Limit a response to the results that have the specified SLA Domain assignment type.",
            "in": "query",
            "name": "sla_assignment",
            "required": false,
            "schema": {
              "enum": [
                "Derived",
                "Direct",
                "Unassigned"
              ],
              "type": "string"
            }
          },
          {
            "description": "Limit a response to the results that have the specified primary cluster value.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limit the summary information to a specified maximum number of matches. Optionally, use with offset to start the count at a specified point. Optionally, use with sort_by to perform sort on given attributes. Include sort_order to determine the ascending or descending direction of the sort.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Starting position in the list of matches. The response includes the specified numbered entry and all higher numbered entries. Use with limit to retrieve the response as smaller groups of entries, for example for paging of results.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Specifies a comma-separated list of attributes to use in sorting the matches. Performs an ASCII sort of the values in the response using each specified attribute, in the order specified.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "name"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort order, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "default": "asc",
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FailoverClusterSummaryListResponse"
                }
              }
            },
            "description": "Successful query results for failover cluster."
          }
        },
        "summary": "Get a summary of all failover clusters",
        "tags": [
          "/failover_cluster"
        ],
        "x-group": "failover_cluster"
      },
      "post": {
        "description": "Create a failover cluster.",
        "operationId": "createFailoverCluster",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FailoverClusterConfig"
              }
            }
          },
          "description": "Create configuration parameters for a failover cluster.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FailoverClusterDetail"
                }
              }
            },
            "description": "Details of the new failover cluster."
          }
        },
        "summary": "Create a failover cluster",
        "tags": [
          "/failover_cluster"
        ],
        "x-group": "failover_cluster"
      }
    },
    "/failover_cluster/bulk": {
      "delete": {
        "description": "Delete the provided failover clusters.",
        "operationId": "bulkDeleteFailoverCluster",
        "parameters": [
          {
            "description": "The ID of each failover cluster to delete.",
            "explode": false,
            "in": "query",
            "name": "ids",
            "required": true,
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          },
          {
            "description": "Specifies whether to preserve the snapshots of the fileset which belong to a failover cluster application. When this value is 'true,' the snapshots are preserved. The default value is 'true'.",
            "in": "query",
            "name": "preserve_snapshots",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully deleted all the specified failover clusters."
          },
          "404": {
            "description": "The failover cluster deletion failed for at least one failover cluster."
          }
        },
        "summary": "Delete the provided failover clusters",
        "tags": [
          "/failover_cluster"
        ],
        "x-group": "failover_cluster"
      }
    },
    "/failover_cluster/failover_cluster_app": {
      "get": {
        "description": "Get a summary of all failover cluster apps.",
        "operationId": "queryFailoverClusterApp",
        "parameters": [
          {
            "description": "Filter the response by comparing the failover cluster app name with the specified value.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limit a response to the results that have the specified SLA Domain assignment type.",
            "in": "query",
            "name": "sla_assignment",
            "required": false,
            "schema": {
              "enum": [
                "Derived",
                "Direct",
                "Unassigned"
              ],
              "type": "string"
            }
          },
          {
            "description": "Limit a response to the results that have the specified primary cluster value.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter a response based on the failover cluster operating system type.",
            "in": "query",
            "name": "operating_system_type",
            "required": false,
            "schema": {
              "enum": [
                "ANY",
                "AIX",
                "HPUX",
                "Linux",
                "SunOS",
                "UnixLike",
                "Windows"
              ],
              "type": "string"
            }
          },
          {
            "description": "Limit the summary information to a specified maximum number of matches. Optionally, use with offset to start the count at a specified point. Optionally, use with sort_by to perform sort on given attributes. Include sort_order to determine the ascending or descending direction of the sort.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Starting position in the list of matches. The response includes the specified numbered entry and all higher numbered entries. Use with limit to retrieve the response as smaller groups of entries, for example for paging of results.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Specifies a comma-separated list of attributes to use in sorting the matches. Performs an ASCII sort of the values in the response using each specified attribute, in the order specified.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "name"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort order, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "default": "asc",
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FailoverClusterAppSummaryListResponse"
                }
              }
            },
            "description": "Successful query results for failover cluster app."
          }
        },
        "summary": "Get a summary of all failover cluster apps",
        "tags": [
          "/failover_cluster/failover_cluster_app"
        ],
        "x-group": "failover_cluster_app"
      },
      "post": {
        "description": "Create a failover cluster app.",
        "operationId": "createFailoverClusterApp",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FailoverClusterAppConfig"
              }
            }
          },
          "description": "Create configuration parameters for a failover cluster app.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FailoverClusterAppSummary"
                }
              }
            },
            "description": "Details of the new failover cluster app."
          }
        },
        "summary": "Create a failover cluster app",
        "tags": [
          "/failover_cluster/failover_cluster_app"
        ],
        "x-group": "failover_cluster_app"
      }
    },
    "/failover_cluster/failover_cluster_app/bulk": {
      "delete": {
        "description": "Delete failover cluster applications from Rubrik cluster.",
        "operationId": "bulkDeleteFailoverClusterApp",
        "parameters": [
          {
            "description": "The ID of each failover cluster application to delete.",
            "explode": false,
            "in": "query",
            "name": "ids",
            "required": true,
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          },
          {
            "description": "Specifies whether to preserve the snapshots of the fileset that belongs to a failover cluster application. When this value is 'true,' the snapshots are preserved. The default value is 'true'.",
            "in": "query",
            "name": "preserve_snapshots",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully deleted all the specified failover cluster applications."
          },
          "404": {
            "description": "The failover cluster application deletion failed for at least one failover cluster application."
          }
        },
        "summary": "Delete failover cluster applications",
        "tags": [
          "/failover_cluster/failover_cluster_app"
        ],
        "x-group": "failover_cluster_app"
      }
    },
    "/failover_cluster/failover_cluster_app/{id}": {
      "delete": {
        "description": "Delete a failover cluster app.",
        "operationId": "deleteFailoverClusterApp",
        "parameters": [
          {
            "description": "ID of the failover cluster app.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A Boolean that specifies whether to preserve the snapshots of the fileset which belong to a failover cluster application. When this value is 'true,' the snapshots are preserved. The default value is 'true'.",
            "in": "query",
            "name": "preserve_snapshots",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully deleted the specified failover cluster app."
          }
        },
        "summary": "Delete a failover cluster app",
        "tags": [
          "/failover_cluster/failover_cluster_app"
        ],
        "x-group": "failover_cluster_app"
      },
      "get": {
        "description": "Get details of a failover cluster app.",
        "operationId": "getFailoverClusterApp",
        "parameters": [
          {
            "description": "ID of the failover cluster app.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FailoverClusterAppDetail"
                }
              }
            },
            "description": "Details about the failover cluster app."
          }
        },
        "summary": "Get details of a failover cluster app",
        "tags": [
          "/failover_cluster/failover_cluster_app"
        ],
        "x-group": "failover_cluster_app"
      },
      "patch": {
        "description": "Update the failover cluster app with specified properties.",
        "operationId": "updateFailoverClusterApp",
        "parameters": [
          {
            "description": "ID of failover cluster app.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FailoverClusterAppConfig"
              }
            }
          },
          "description": "Properties to update.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FailoverClusterAppSummary"
                }
              }
            },
            "description": "Return details about the failover cluster app."
          }
        },
        "summary": "Update a failover cluster app",
        "tags": [
          "/failover_cluster/failover_cluster_app"
        ],
        "x-group": "failover_cluster_app"
      }
    },
    "/failover_cluster/hierarchy/{id}": {
      "get": {
        "description": "Retrieve details for the specified hierarchy object.",
        "operationId": "getFailoverClusterHierarchyObject",
        "parameters": [
          {
            "description": "ID of the hierarchy object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FailoverClusterHierarchyObjectSummary"
                }
              }
            },
            "description": "Details of the hierarchy object."
          }
        },
        "summary": "Get summary of a hierarchy object",
        "tags": [
          "/failover_cluster/hierarchy"
        ],
        "x-group": "failover_cluster_hierarchy"
      }
    },
    "/failover_cluster/hierarchy/{id}/children": {
      "get": {
        "description": "Retrieve the list of immediate descendant objects for the specified parent.",
        "operationId": "getFailoverClusterHierarchyChildren",
        "parameters": [
          {
            "description": "Filter a response by making an infix comparison of the failover cluster name or failover cluster app name.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter a response based on the failover cluster operating system type.",
            "in": "query",
            "name": "operating_system_type",
            "required": false,
            "schema": {
              "enum": [
                "ANY",
                "AIX",
                "HPUX",
                "Linux",
                "SunOS",
                "UnixLike",
                "Windows"
              ],
              "type": "string"
            }
          },
          {
            "description": "ID of the parent failover cluster hierarchy object. To get top-level nodes, use **root** as the ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by node object type.",
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "enum": [
                "FailoverClusterApp",
                "Fileset",
                "HostFailoverCluster",
                "WindowsCluster"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter by primary cluster ID, or **local**.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "An integer that specifies the maximum number of matches to return.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "An integer that specifies a number of initial matches to ignore.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Filter by configured SLA domain.",
            "in": "query",
            "name": "configured_sla_domain_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by SLA assignment type.",
            "in": "query",
            "name": "sla_assignment",
            "required": false,
            "schema": {
              "enum": [
                "Derived",
                "Direct",
                "Unassigned"
              ],
              "type": "string"
            }
          },
          {
            "description": "Attribute to sort the results on.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "name",
                "effectiveSlaDomainName"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort order, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FailoverClusterHierarchyObjectSummaryListResponse"
                }
              }
            },
            "description": "Summary list of descendant objects."
          }
        },
        "summary": "Get list of immediate descendant objects",
        "tags": [
          "/failover_cluster/hierarchy"
        ],
        "x-group": "failover_cluster_hierarchy"
      }
    },
    "/failover_cluster/hierarchy/{id}/descendants": {
      "get": {
        "description": "Retrieve the list of descendant objects for the specified parent.",
        "operationId": "getFailoverClusterHierarchyDescendants",
        "parameters": [
          {
            "description": "Filter a response by making an infix comparison of the failover cluster name or failover cluster app name.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter a response based on the failover cluster operating system type.",
            "in": "query",
            "name": "operating_system_type",
            "required": false,
            "schema": {
              "enum": [
                "ANY",
                "AIX",
                "HPUX",
                "Linux",
                "SunOS",
                "UnixLike",
                "Windows"
              ],
              "type": "string"
            }
          },
          {
            "description": "ID of the parent failover cluster hierarchy object. To get top-level nodes, use **root** as the ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by node object type.",
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "enum": [
                "FailoverClusterApp",
                "Fileset",
                "HostFailoverCluster",
                "WindowsCluster"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter by primary cluster ID, or **local**.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "An integer that specifies the maximum number of matches to return.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "An integer that specifies a number of initial matches to ignore.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Filter by configured SLA domain.",
            "in": "query",
            "name": "configured_sla_domain_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by SLA assignment type.",
            "in": "query",
            "name": "sla_assignment",
            "required": false,
            "schema": {
              "enum": [
                "Derived",
                "Direct",
                "Unassigned"
              ],
              "type": "string"
            }
          },
          {
            "description": "Attribute to sort the results on.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "name",
                "effectiveSlaDomainName"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort order, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FailoverClusterHierarchyObjectSummaryListResponse"
                }
              }
            },
            "description": "Summary list of descendant objects."
          }
        },
        "summary": "Get list of descendant objects",
        "tags": [
          "/failover_cluster/hierarchy"
        ],
        "x-group": "failover_cluster_hierarchy"
      }
    },
    "/failover_cluster/{id}": {
      "delete": {
        "description": "Delete a failover cluster.",
        "operationId": "deleteFailoverCluster",
        "parameters": [
          {
            "description": "ID of the failover cluster.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A Boolean that specifies whether to preserve the snapshots of the fileset which belong to a failover cluster application. When this value is 'true,' the snapshots are preserved. The default value is 'true'.",
            "in": "query",
            "name": "preserve_snapshots",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully deleted the specified failover cluster."
          }
        },
        "summary": "Delete a failover cluster",
        "tags": [
          "/failover_cluster"
        ],
        "x-group": "failover_cluster"
      },
      "get": {
        "description": "Get details of a failover cluster.",
        "operationId": "getFailoverCluster",
        "parameters": [
          {
            "description": "ID of the failover cluster.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FailoverClusterDetail"
                }
              }
            },
            "description": "Details about the failover cluster."
          }
        },
        "summary": "Get details of a failover cluster",
        "tags": [
          "/failover_cluster"
        ],
        "x-group": "failover_cluster"
      },
      "patch": {
        "description": "Update failover cluster with specified properties.",
        "operationId": "updateFailoverCluster",
        "parameters": [
          {
            "description": "ID of failover cluster.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FailoverClusterConfig"
              }
            }
          },
          "description": "Properties to update.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FailoverClusterDetail"
                }
              }
            },
            "description": "Return details about the failover cluster."
          }
        },
        "summary": "Update a failover cluster",
        "tags": [
          "/failover_cluster"
        ],
        "x-group": "failover_cluster"
      }
    },
    "/fileset": {
      "get": {
        "description": "Retrieve summary information for each fileset. Optionally, filter the retrieved information.",
        "operationId": "queryFileset",
        "parameters": [
          {
            "description": "Filter the summary information based on the primary_cluster_id of the primary Rubrik cluster.\nUse **_local_** as the primary_cluster_id of the Rubrik cluster that is hosting the current REST API session.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter the summary information based on the ID of the host referenced by the fileset.",
            "in": "query",
            "name": "host_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter the summary information based on the ID of the host share referenced by the fileset.\nUse **_NONE_** to only return information for filesets that were not created based on a host share.\nUse **_ANY_** to only return information for filesets that were created based on a host share.",
            "in": "query",
            "name": "share_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter the summary information based on the relic status of the fileset. Returns both relic and non relic if the parameter is not set.",
            "in": "query",
            "name": "is_relic",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Filter the summary information based on the ID of the effective SLA Domain inherited by a fileset.\nUse **_UNPROTECTED_** to only return information for filesets that do not have an effective SLA Domain.\nUse **_PROTECTED_** to only return information for filesets that do have an effective SLA Domain.",
            "in": "query",
            "name": "effective_sla_domain_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter the summary information based on the ID of a fileset template.\n\nUse **_NONE_** to only return information for filesets that were not created from a fileset template.\n\nUse **_ANY_** to only return information for filesets that were created from a fileset template.",
            "in": "query",
            "name": "template_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limit the summary information to a specified maximum number of filesets.\n\nOptionally, use with **_offset_** to start the count at a specified point.\n\nOptionally, use with **_sort_by_** to perform sort on given attributes. Include **_sort_order_** to determine the ascending or descending direction of sort.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Starting position in the list of fileset entries contained in the response. The summary information includes the specified numbered entry and all higher numbered entries. Use with **_limit_** to retrieve the summary information as smaller groups of entries, e.g. for paging of results.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Retrieve filesets with a name matching the provided name. The search is performed as a case-insensitive infix search.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Retrieve filesets with a host name matching the provided name. The search is performed as a case-insensitive infix search.",
            "in": "query",
            "name": "host_name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Specifies a comma-separated list of fileset attributes to use in sorting the fileset summary information. Performs an ASCII sort of the summary information using each specified attribute, in the order specified.\n\nValid attributes are: **_name_**, **_hostName_**, **_templateType_**, **_slaName_**, **_includes_**, **_excludes_**, and **_exceptions_**. Requires **_sort_order_**.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "name",
                "hostName",
                "templateId",
                "effectiveSlaDomainName",
                "includes",
                "excludes",
                "exceptions"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort order, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FilesetSummaryListResponse"
                }
              }
            },
            "description": "Summary information for filesets."
          }
        },
        "summary": "Get summary information for all filesets",
        "tags": [
          "/fileset"
        ],
        "x-group": "fileset"
      },
      "post": {
        "description": "Create a fileset for a network host. A fileset is a fileset template applied to a host.",
        "operationId": "createFileset",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FilesetCreate"
              }
            }
          },
          "description": "Specify a template ID and either a host ID or a share ID. When a share ID is provided, the host ID is derived from the host share. Also specify whether or not this backup is a direct archive backup.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FilesetDetail"
                }
              }
            },
            "description": "Details of the new fileset."
          }
        },
        "summary": "Create one fileset for a host",
        "tags": [
          "/fileset"
        ],
        "x-group": "fileset"
      }
    },
    "/fileset/request/{id}": {
      "get": {
        "description": "Get details about a fileset related async request.",
        "operationId": "getFilesetAsyncRequestStatus",
        "parameters": [
          {
            "description": "ID of the request.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status for the async request."
          }
        },
        "summary": "Get details about an async request",
        "tags": [
          "/fileset"
        ],
        "x-group": "fileset"
      }
    },
    "/fileset/snapshot/{id}": {
      "delete": {
        "description": "Delete a fileset snapshot. A snapshot is deleted only if it is an on-demand snapshot, a snapshot of an unprotected fileset or a local snapshot that was downloaded from an archive location.",
        "operationId": "deleteFilesetSnapshot",
        "parameters": [
          {
            "description": "ID of snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Snapshot location to delete. Use **_local_** to delete all local snapshots and **_all_** to delete the snapshot in all locations.",
            "in": "query",
            "name": "location",
            "required": true,
            "schema": {
              "enum": [
                "all",
                "local"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Snapshot sucessfully deleted."
          }
        },
        "summary": "Delete a fileset snapshot",
        "tags": [
          "/fileset"
        ],
        "x-group": "fileset"
      },
      "get": {
        "description": "Retrieve summary information for a fileset snapshot by specifying the snapshot ID.",
        "operationId": "getFilesetSnapshot",
        "parameters": [
          {
            "description": "ID of snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Whether or not to fetch verbose fileset snapshot information. The performance of this endpoint will decrease if set to true.",
            "in": "query",
            "name": "verbose",
            "required": false,
            "schema": {
              "default": false,
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FilesetSnapshotDetail"
                }
              }
            },
            "description": "Detailed information for the specified fileset snapshot."
          }
        },
        "summary": "Get information for a fileset snapshot",
        "tags": [
          "/fileset"
        ],
        "x-group": "fileset"
      }
    },
    "/fileset/snapshot/{id}/browse": {
      "get": {
        "description": "Lists all files and directories in a given path.",
        "operationId": "browseFilesetSnapshot",
        "parameters": [
          {
            "description": "ID of snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The absolute path of the starting point for the directory listing.",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Starting position in the list of path entries contained in the query results, sorted by lexicographical order. The response includes the specified numbered entry and all higher numbered entries.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "type": "integer"
            }
          },
          {
            "description": "Maximum number of entries in the response.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BrowseResponseListResponse"
                }
              }
            },
            "description": "List of files and directories at the specified path."
          }
        },
        "summary": "Lists all files and directories in a given path",
        "tags": [
          "/fileset"
        ],
        "x-group": "fileset"
      }
    },
    "/fileset/snapshot/{id}/download": {
      "post": {
        "description": "Create a download fileset snapshot from archival request.",
        "operationId": "createDownloadFilesetSnapshotFromCloud",
        "parameters": [
          {
            "description": "ID of snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status for the download request."
          }
        },
        "summary": "Create a download fileset snapshot from archival request",
        "tags": [
          "/fileset"
        ],
        "x-group": "fileset"
      }
    },
    "/fileset/snapshot/{id}/download_file": {
      "post": {
        "description": "Initiate a job to download a file from a backup of a fileset. Returns a job instance ID.\nAn email notification will be sent out when the download is ready. When the download is ready, the file can be downloaded from the corresponding event which includes the job instance ID as the value of **jobInstanceId**.",
        "operationId": "createFilesetDownloadFileJob",
        "parameters": [
          {
            "description": "ID of snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FilesetDownloadFileJobConfig"
              }
            }
          },
          "description": "Configuration for a download job.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status for the download request."
          }
        },
        "summary": "Create a file download job from a fileset backup",
        "tags": [
          "/fileset"
        ],
        "x-group": "fileset"
      }
    },
    "/fileset/snapshot/{id}/export_file": {
      "post": {
        "description": "Initiate a job to copy a file or folder from a fileset backup to a destination host other than the source host. Returns the job instance ID.",
        "operationId": "createFilesetExportFileJob",
        "parameters": [
          {
            "description": "ID of snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FilesetExportFileJobConfig"
              }
            }
          },
          "description": "Configuration for job to export a file or folder from a fileset backup.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status for the export request."
          }
        },
        "summary": "Create export job",
        "tags": [
          "/fileset"
        ],
        "x-group": "fileset"
      }
    },
    "/fileset/snapshot/{id}/restore_file": {
      "post": {
        "description": "Initiate a job to copy a file or folder from a fileset backup to the source host. Returns the job instance ID.",
        "operationId": "createFilesetRestoreFileJob",
        "parameters": [
          {
            "description": "ID of snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FilesetRestoreFileJobConfig"
              }
            }
          },
          "description": "Configuration for job to restore a file or folder from a fileset backup.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status for the restore request."
          }
        },
        "summary": "Create restore job",
        "tags": [
          "/fileset"
        ],
        "x-group": "fileset"
      }
    },
    "/fileset/{id}": {
      "delete": {
        "description": "Delete a fileset by specifying the fileset ID.",
        "operationId": "deleteFileset",
        "parameters": [
          {
            "description": "Provide a fileset ID to delete.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Flag to indicate whether to preserve snapshots of the fileset or to delete them. Default behavior is to preserve them.",
            "in": "query",
            "name": "preserve_snapshots",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted the specified fileset."
          },
          "404": {
            "description": "Fileset deletion failed."
          }
        },
        "summary": "Delete a fileset",
        "tags": [
          "/fileset"
        ],
        "x-group": "fileset"
      },
      "get": {
        "description": "Retrieve summary information for a fileset by specifying the fileset ID.",
        "operationId": "getFileset",
        "parameters": [
          {
            "description": "Specify the fileset ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FilesetDetail"
                }
              }
            },
            "description": "Detailed information for the specified fileset."
          }
        },
        "summary": "Get information for a single fileset",
        "tags": [
          "/fileset"
        ],
        "x-group": "fileset"
      },
      "patch": {
        "description": "Update a Fileset with the specified properties.",
        "operationId": "updateFileset",
        "parameters": [
          {
            "description": "ID of the Fileset. to update.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FilesetUpdate"
              }
            }
          },
          "description": "Properties to update.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FilesetDetail"
                }
              }
            },
            "description": "Returned if the update was successful."
          }
        },
        "summary": "Update a Fileset",
        "tags": [
          "/fileset"
        ],
        "x-group": "fileset"
      }
    },
    "/fileset/{id}/missed_snapshot": {
      "get": {
        "description": "Retrieve summary information about all missed snapshots for a fileset.",
        "operationId": "getMissedFilesetSnapshots",
        "parameters": [
          {
            "description": "ID of the fileset.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MissedSnapshotListResponse"
                }
              }
            },
            "description": "Summary information about missed snapshots for the specified fileset."
          }
        },
        "summary": "Get missed snapshots for a fileset",
        "tags": [
          "/fileset"
        ],
        "x-group": "fileset"
      }
    },
    "/fileset/{id}/search": {
      "get": {
        "description": "Search for a file within the fileset. Search via full path prefix or filename prefix.",
        "operationId": "searchFileset",
        "parameters": [
          {
            "description": "Fileset ID to search.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The path query. Either path prefix or filename prefix.",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Maximum number of entries in the response.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "type": "integer"
            }
          },
          {
            "description": "Pagination cursor returned by the previous request.",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResponseListResponse"
                }
              }
            },
            "description": "Search results."
          }
        },
        "summary": "Search for a file within the fileset",
        "tags": [
          "/fileset"
        ],
        "x-group": "fileset"
      }
    },
    "/fileset/{id}/snapshot": {
      "delete": {
        "description": "Delete all snapshots that were created based on a fileset by providing the fileset ID.\nRequires an unprotected fileset. Remove the fileset from all SLA Domains.",
        "operationId": "deleteFilesetSnapshots",
        "parameters": [
          {
            "description": "ID of the fileset.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully removed all snapshots for the fileset."
          }
        },
        "summary": "Delete all snapshots of a fileset",
        "tags": [
          "/fileset"
        ],
        "x-group": "fileset"
      },
      "post": {
        "description": "Create an on-demand backup request for the given fileset.",
        "operationId": "createFilesetBackupJob",
        "parameters": [
          {
            "description": "ID of the Fileset.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/BaseOnDemandSnapshotConfig"
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status for the backup request."
          }
        },
        "summary": "Initiate an on-demand backup for a fileset",
        "tags": [
          "/fileset"
        ],
        "x-group": "fileset"
      }
    },
    "/fileset_template": {
      "get": {
        "description": "Retrieve summary information for all fileset templates, including: ID and name of the fileset template, fileset template creation timestamp, array of the included filepaths, array of the excluded filepaths.",
        "operationId": "queryFilesetTemplate",
        "parameters": [
          {
            "description": "Filter the summary information based on the primary_cluster_id of the primary Rubrik cluster.\nUse **_local_** as the primary_cluster_id of the Rubrik cluster that is hosting the current REST API session.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter the summary information based on the operating system type of the fileset. Accepted values: 'Windows', 'UnixLike', 'ANY', 'NONE'.\nUse **_NONE_** to only return information for fileset templates that do not have operating system type set.\nUse **_ANY_** to only return information for fileset templates that have operating system type set.",
            "in": "query",
            "name": "operating_system_type",
            "required": false,
            "schema": {
              "enum": [
                "UnixLike",
                "Windows",
                "ANY",
                "NONE"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter the summary information based on the share type where the fileset is assigned to. Accepted values: 'NFS', 'SMB', 'ANY', 'NONE'.\nUse **_NONE_** to only return information for fileset templates that do not have share type set.\nUse **_ANY_** to only return information for fileset templates that have share type set.",
            "in": "query",
            "name": "share_type",
            "required": false,
            "schema": {
              "enum": [
                "NFS",
                "SMB",
                "ANY",
                "NONE"
              ],
              "type": "string"
            }
          },
          {
            "description": "Retrieve fileset templates with a name matching the provided name. The search is performed as a case-insensitive infix search.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Specifies a comma-separated list of fileset attributes to use in sorting the fileset summary information. Performs an ASCII sort of the summary information using each specified attribute, in the order specified.\n\nValid attributes are: **_name_**, **_includes_**, **_excludes_**, **_exceptions_**, **_hostCount_**, **_shareType_**. Default sort_order is ascending.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "name",
                "hostCount",
                "includes",
                "excludes",
                "exceptions",
                "shareType"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort order, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FilesetTemplateDetailListResponse"
                }
              }
            },
            "description": "Summary information for all fileset templates."
          }
        },
        "summary": "Get summary information for all fileset templates",
        "tags": [
          "/fileset_template"
        ],
        "x-group": "fileset"
      },
      "post": {
        "description": "Create a fileset template. The template is applied to the host.  Each template is a set of paths on the host.\n\nA template uses full paths and wildcards to define the objects to include, exclude, and exempt from exclusion.\n\nThe **_exceptions_** value specifies paths that should not be excluded from the fileset by the **_exclude_** value.\n\nSpecify an array of full path descriptions for each property **_include_**, **_exclude_**, and **_exceptions_**.\n\nAcceptable wildcard characters are.\n+ **_\\*_** Single asterisk matches zero or more characters up to a path deliminator.\n+ **_\\*\\*_** Double asterisk matches zero or more characters.\n\nThe following rules apply to path descriptions.\n+ Accepts UTF-8 characters.\n+ Case sensitive.\n+ Forward slash character **_/_** is the path deliminator.\n+ Symbolic links must point to a subset of a non symbolic link path.\n+ Paths that do not start with **_/_** are modified to start with **_\\*\\*/_**.\n+ Paths that do not end with **_\\*_** are modified to end with **_/\\*\\*_**.",
        "operationId": "createFilesetTemplate",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FilesetTemplateCreate"
              }
            }
          },
          "description": "Provide an object with the fileset template definition.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FilesetTemplateDetail"
                }
              }
            },
            "description": "Summary information for the created fileset template."
          }
        },
        "summary": "Create a fileset template",
        "tags": [
          "/fileset_template"
        ],
        "x-group": "fileset"
      }
    },
    "/fileset_template/{id}": {
      "delete": {
        "description": "Deletes the specfied fileset template. All associated filesets are deleted.",
        "operationId": "deleteFilesetTemplate",
        "parameters": [
          {
            "description": "ID of the fileset template to remove.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Flag to indicate whether to convert snapshots of all filesets of this template to relics or to delete them.  Default is true.",
            "in": "query",
            "name": "preserve_snapshots",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully removed the specified fileset template."
          }
        },
        "summary": "Delete a fileset template",
        "tags": [
          "/fileset_template"
        ],
        "x-group": "fileset"
      },
      "get": {
        "description": "Retrieve summary information for a specified fileset template.",
        "operationId": "getFilesetTemplate",
        "parameters": [
          {
            "description": "The ID of the fileset template.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FilesetTemplateDetail"
                }
              }
            },
            "description": "Summary information for the specified fileset template."
          }
        },
        "summary": "Get information for a fileset template",
        "tags": [
          "/fileset_template"
        ],
        "x-group": "fileset"
      },
      "patch": {
        "description": "Modify the values of specified fileset template.",
        "operationId": "updateFilesetTemplate",
        "parameters": [
          {
            "description": "ID of the fileset template to update.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FilesetTemplatePatch"
              }
            }
          },
          "description": "Provide an object with the fileset template definition.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FilesetTemplateDetail"
                }
              }
            },
            "description": "Detailed information for modified fileset template."
          }
        },
        "summary": "Modify a fileset template",
        "tags": [
          "/fileset_template"
        ],
        "x-group": "fileset"
      }
    },
    "/hdfs": {
      "get": {
        "description": "Retrieve summary information for each HDFS directory. Optionally, filter the retrieved information.",
        "operationId": "queryHdfs",
        "parameters": [
          {
            "description": "Filter the summary information based on the primary_cluster_id of the primary Rubrik cluster.\nUse **_local_** as the primary_cluster_id of the Rubrik cluster that is hosting the current REST API session.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter the summary information based on the ID of the host referenced by the HDFS directory (name node).",
            "in": "query",
            "name": "host_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter the summary information based on the relic status of the HDFS directory. When this parameter is not set, the returned HDFS directory summary information is not filtered by relic status.",
            "in": "query",
            "name": "is_relic",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Filter the summary information based on the ID of the effective SLA Domain inherited by a HDFS directory.\nUse **_UNPROTECTED_** to only return information for HDFS directories that do not have an effective SLA Domain.\nUse **_PROTECTED_** to only return information for HDFS directories that have an effective SLA Domain.",
            "in": "query",
            "name": "effective_sla_domain_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter the summary information based on the ID of a HDFS directory template.\nUse **_NONE_** to only return information for HDFS directories that were not created from a HDFS directory template.\nUse **_ANY_** to only return information for HDFS directories that were created from a HDFS directory template.",
            "in": "query",
            "name": "template_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limit the summary information to a specified maximum number of HDFS directories.\nOptionally, use with **_offset_** to start the count at a specified point.\nOptionally, use with **_sort_by_** to perform sort on given attributes. Include **_sort_order_** to determine the ascending or descending direction of sort.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Starting position in the list of HDFS directory entries contained in the response. The summary information includes the specified numbered entry and all higher numbered entries. Use with **_limit_** to retrieve the summary information as a collection of grouped entries for paging.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Retrieve HDFS directories with a name matching the provided name. The search is performed as a case-insensitive infix search.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Retrieve HDFS directories with a host name (name node) matching the provided name. The search is performed as a case-insensitive infix search.",
            "in": "query",
            "name": "host_name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Specifies a comma-separated list of HDFS directory attributes to use in sorting the HDFS directory summary information. Performs an ASCII sort of the summary information using each specified attribute, in the order specified.\nValid attributes are: **_name_**, **_hostName_**, **_templateType_**, **_slaName_**, **_includes_**, **_excludes_**, and **_exceptions_**. Requires **_sort_order_**.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "default": "name",
              "enum": [
                "name",
                "hostName",
                "templateId",
                "effectiveSlaDomainName",
                "includes",
                "excludes",
                "exceptions"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort order, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "default": "asc",
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HdfsSummaryListResponse"
                }
              }
            },
            "description": "Summary information for HDFS directories."
          }
        },
        "summary": "Get summary information for all HDFS directories",
        "tags": [
          "/hdfs"
        ],
        "x-group": "hdfs"
      },
      "post": {
        "description": "Create a HDFS directory for a network host. A HDFS directory is a HDFS directory template applied to a host.",
        "operationId": "createHdfs",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HdfsCreate"
              }
            }
          },
          "description": "Specify a template ID and a host ID.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HdfsDetail"
                }
              }
            },
            "description": "Details of the new HDFS directory."
          }
        },
        "summary": "Create one HDFS directory for a host",
        "tags": [
          "/hdfs"
        ],
        "x-group": "hdfs"
      }
    },
    "/hdfs/request/{id}": {
      "get": {
        "description": "Get details about a hdfs related asynchronous request.",
        "operationId": "getHdfsAsyncRequestStatus",
        "parameters": [
          {
            "description": "ID of the request.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status for the asynchronous request."
          }
        },
        "summary": "Get details about an asynchronous request",
        "tags": [
          "/hdfs"
        ],
        "x-group": "hdfs"
      }
    },
    "/hdfs/snapshot/{id}": {
      "delete": {
        "description": "Delete a HDFS directory snapshot. A snapshot is deleted only if it is an on-demand snapshot, or a snapshot of an unprotected HDFS directory.",
        "operationId": "deleteHdfsSnapshot",
        "parameters": [
          {
            "description": "ID of snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Snapshot sucessfully deleted."
          }
        },
        "summary": "Delete a HDFS directory snapshot",
        "tags": [
          "/hdfs"
        ],
        "x-group": "hdfs"
      },
      "get": {
        "description": "Retrieve summary information for a HDFS directory snapshot by specifying the snapshot ID.",
        "operationId": "getHdfsSnapshot",
        "parameters": [
          {
            "description": "ID of snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HdfsSnapshotDetail"
                }
              }
            },
            "description": "Detailed information for the specified HDFS directory snapshot."
          }
        },
        "summary": "Get information for a HDFS directory snapshot",
        "tags": [
          "/hdfs"
        ],
        "x-group": "hdfs"
      }
    },
    "/hdfs/snapshot/{id}/browse": {
      "get": {
        "description": "Lists all files and directories in a given path.",
        "operationId": "browseHdfsSnapshot",
        "parameters": [
          {
            "description": "ID of snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The absolute path of the starting point for the directory listing.",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Starting position in the list of path entries contained in the query results, sorted by lexicographical order. The response includes the specified numbered entry and all higher numbered entries.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "type": "integer"
            }
          },
          {
            "description": "Maximum number of entries in the response.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BrowseResponseListResponse"
                }
              }
            },
            "description": "List of files and directories at the specified path."
          }
        },
        "summary": "Lists all files and directories in a given path",
        "tags": [
          "/hdfs"
        ],
        "x-group": "hdfs"
      }
    },
    "/hdfs/snapshot/{id}/export_file": {
      "post": {
        "description": "Initiate a job to copy a file or folder from a hdfs backup to a destination host other than the source host. Returns the job instance ID.",
        "operationId": "createHdfsExportFileJob",
        "parameters": [
          {
            "description": "ID of snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HdfsExportFileJobConfig"
              }
            }
          },
          "description": "Configuration for job to export a file or folder from a hdfs backup.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status for the export request."
          }
        },
        "summary": "Create export job",
        "tags": [
          "/hdfs"
        ],
        "x-group": "hdfs"
      }
    },
    "/hdfs/snapshot/{id}/restore_file": {
      "post": {
        "description": "Initiate a job to copy a file or folder from a HDFS directory backup to the source host. Returns the job instance ID.",
        "operationId": "createHdfsRestoreFileJob",
        "parameters": [
          {
            "description": "ID of snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HdfsRestoreFileJobConfig"
              }
            }
          },
          "description": "Configuration for job to restore a file or folder from a HDFS directory backup.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status for the restore request."
          }
        },
        "summary": "Create restore job",
        "tags": [
          "/hdfs"
        ],
        "x-group": "hdfs"
      }
    },
    "/hdfs/{id}": {
      "delete": {
        "description": "Delete a HDFS directory by specifying the HDFS directory ID.",
        "operationId": "deleteHdfs",
        "parameters": [
          {
            "description": "Provide a HDFS directory ID to delete.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A flag that indicates whether the snapshots of the HDFS directory are preserved or deleted. By default, snapshots are preserved.",
            "in": "query",
            "name": "preserve_snapshots",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted the specified HDFS directory."
          },
          "404": {
            "description": "HDFS directory deletion failed."
          }
        },
        "summary": "Delete a HDFS directory",
        "tags": [
          "/hdfs"
        ],
        "x-group": "hdfs"
      },
      "get": {
        "description": "Retrieve summary information for a HDFS directory by specifying the HDFS directory ID.",
        "operationId": "getHdfs",
        "parameters": [
          {
            "description": "Specify the HDFS directory ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HdfsDetail"
                }
              }
            },
            "description": "Detailed information for the specified HDFS directory."
          }
        },
        "summary": "Get information for a single HDFS directory",
        "tags": [
          "/hdfs"
        ],
        "x-group": "hdfs"
      },
      "patch": {
        "description": "Update a HDFS directory with the specified properties.",
        "operationId": "updateHdfs",
        "parameters": [
          {
            "description": "ID of the HDFS directory to update.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HdfsUpdate"
              }
            }
          },
          "description": "Properties to update.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HdfsDetail"
                }
              }
            },
            "description": "Returned if the update was successful."
          }
        },
        "summary": "Update a HDFS directory",
        "tags": [
          "/hdfs"
        ],
        "x-group": "hdfs"
      }
    },
    "/hdfs/{id}/missed_snapshot": {
      "get": {
        "description": "Retrieve summary information about all missed snapshots for a HDFS directory.",
        "operationId": "getMissedHdfsSnapshots",
        "parameters": [
          {
            "description": "ID of the HDFS directory.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MissedSnapshotListResponse"
                }
              }
            },
            "description": "Summary information about missed snapshots for the specified HDFS directory."
          }
        },
        "summary": "Get missed snapshots for a HDFS directory",
        "tags": [
          "/hdfs"
        ],
        "x-group": "hdfs"
      }
    },
    "/hdfs/{id}/search": {
      "get": {
        "description": "Search for a file within the HDFS directory. Search using full path prefix or filename prefix.",
        "operationId": "searchHdfs",
        "parameters": [
          {
            "description": "HDFS directory ID to search.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The path query. The query can be a path refix or a filename prefix.",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Maximum number of entries in the response.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "type": "integer"
            }
          },
          {
            "description": "Pagination cursor returned by the previous request.",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResponseListResponse"
                }
              }
            },
            "description": "Search results."
          }
        },
        "summary": "Search for a file within the HDFS directory",
        "tags": [
          "/hdfs"
        ],
        "x-group": "hdfs"
      }
    },
    "/hdfs/{id}/snapshot": {
      "delete": {
        "description": "Delete all snapshots that were created based on a hdfs by providing the HDFS directory ID.\nRequires an unprotected HDFS directory. Remove the HDFS directory from all SLA Domains.",
        "operationId": "deleteHdfsSnapshots",
        "parameters": [
          {
            "description": "ID of the HDFS directory.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully removed all snapshots for the HDFS directory."
          }
        },
        "summary": "Delete all snapshots of a HDFS directory",
        "tags": [
          "/hdfs"
        ],
        "x-group": "hdfs"
      },
      "post": {
        "description": "Create on-demand backup request for HDFS directory.",
        "operationId": "createHdfsBackupJob",
        "parameters": [
          {
            "description": "ID of the HDFS directory.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/BaseOnDemandSnapshotConfig"
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status for the backup request."
          }
        },
        "summary": "Initiate an on-demand backup for a HDFS directory",
        "tags": [
          "/hdfs"
        ],
        "x-group": "hdfs"
      }
    },
    "/hdfs_template": {
      "get": {
        "description": "Retrieve summary information for all HDFS directory templates, including: ID and name of the HDFS directory template, HDFS directory template creation timestamp, array of the included filepaths, array of the excluded filepaths.",
        "operationId": "queryHdfsTemplate",
        "parameters": [
          {
            "description": "Filter the summary information based on the primary_cluster_id of the primary Rubrik cluster.\nUse **_local_** as the primary_cluster_id of the Rubrik cluster that is hosting the current REST API session.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Retrieve HDFS directory templates with a name matching the provided name. The search is performed as a case-insensitive infix search.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Specifies a comma-separated list of HDFS directory attributes to use in sorting the HDFS directory summary information. Performs an ASCII sort of the summary information using each specified attribute, in the order specified.\nValid attributes are: **_name_**, **_includes_**, **_excludes_**, **_exceptions_**, **_hostCount_**. Default sort_order is ascending.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "default": "name",
              "enum": [
                "name",
                "hostCount",
                "includes",
                "excludes",
                "exceptions"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort order, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "default": "asc",
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HdfsTemplateDetailListResponse"
                }
              }
            },
            "description": "Summary information for all HDFS directory templates."
          }
        },
        "summary": "Get summary information for all HDFS directory templates",
        "tags": [
          "/hdfs_template"
        ],
        "x-group": "hdfs"
      },
      "post": {
        "description": "Create a HDFS directory template. The template is applied to the host.  Each template is a set of paths on the host.\nA template uses full paths and wildcards to define the objects to include, exclude, and exempt from exclusion.\nThe **_exceptions_** value specifies paths that should not be excluded from the HDFS directory by the **_exclude_** value.\nSpecify an array of full path descriptions for each property **_include_**, **_exclude_**, and **_exceptions_**.\nAcceptable wildcard characters are.\n+ **_\\*_** Single asterisk matches zero or more characters up to a path deliminator.\n+ **_\\*\\*_** Double asterisk matches zero or more characters.\nThe following rules apply to path descriptions.\n+ Accepts UTF-8 characters.\n+ Case sensitive.\n+ Forward slash character **_/_** is the path deliminator.\n+ Symbolic links must point to a subset of a non symbolic link path.\n+ Paths that do not start with **_/_** are modified to start with **_\\*\\*/_**.\n+ Paths that do not end with **_\\*_** are modified to end with **_/\\*\\*_**.",
        "operationId": "createHdfsTemplate",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HdfsTemplateCreate"
              }
            }
          },
          "description": "Provide an object with the HDFS directory template definition.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HdfsTemplateDetail"
                }
              }
            },
            "description": "Summary information for the created HDFS directory template."
          }
        },
        "summary": "Create a HDFS directory template",
        "tags": [
          "/hdfs_template"
        ],
        "x-group": "hdfs"
      }
    },
    "/hdfs_template/{id}": {
      "delete": {
        "description": "Deletes the specfied HDFS directory template. All associated HDFS directories are deleted.",
        "operationId": "deleteHdfsTemplate",
        "parameters": [
          {
            "description": "ID of the HDFS directory template to remove.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A flag that indicates whether the snapshots of the HDFS directories of this template are converted to relics or deleted. By default, snapshots are converted. Set this flag to 'false' to delete the snapshots.",
            "in": "query",
            "name": "preserve_snapshots",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully removed the specified HDFS directory template."
          }
        },
        "summary": "Delete a HDFS directory template",
        "tags": [
          "/hdfs_template"
        ],
        "x-group": "hdfs"
      },
      "get": {
        "description": "Retrieve summary information for a specified HDFS directory template.",
        "operationId": "getHdfsTemplate",
        "parameters": [
          {
            "description": "The ID of the HDFS directory template.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HdfsTemplateDetail"
                }
              }
            },
            "description": "Summary information for the specified HDFS directory template."
          }
        },
        "summary": "Get information for a HDFS directory template",
        "tags": [
          "/hdfs_template"
        ],
        "x-group": "hdfs"
      },
      "patch": {
        "description": "Modify the values of specified HDFS directory template.",
        "operationId": "updateHdfsTemplate",
        "parameters": [
          {
            "description": "ID of the HDFS directory template to update.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HdfsTemplatePatch"
              }
            }
          },
          "description": "Provide an object with the HDFS directory template definition.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HdfsTemplateDetail"
                }
              }
            },
            "description": "Detailed information for modified HDFS directory template."
          }
        },
        "summary": "Modify a HDFS directory template",
        "tags": [
          "/hdfs_template"
        ],
        "x-group": "hdfs"
      }
    },
    "/health_monitor/policies": {
      "get": {
        "description": "Retrieves the details of all the health monitor policies when policy IDs are not specified in the query parameter. If the request includes a list of policy IDs in the query parameter, the response will include the details of the specified policies.",
        "operationId": "getPolicies",
        "parameters": [
          {
            "description": "Optional list of policy IDs.",
            "explode": false,
            "in": "query",
            "name": "policy_ids",
            "required": false,
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/HealthMonitorPolicy"
                  },
                  "type": "array"
                }
              }
            },
            "description": "List of health monitor policies."
          }
        },
        "summary": "Get details of health monitor policies",
        "tags": [
          "/health_monitor"
        ],
        "x-group": "health_monitor"
      }
    },
    "/health_monitor/policy_status": {
      "get": {
        "description": "Retrieves the status of the policy enforcement for a list of nodes if specified. If nodes are not specified, the response includes the policy enforcement status for all the nodes on the Rubrik cluster.",
        "operationId": "getPolicyStatus",
        "parameters": [
          {
            "description": "Optional list of policy IDs. If not provided, the response includes the status of all the policies.",
            "explode": false,
            "in": "query",
            "name": "policy_ids",
            "required": false,
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          },
          {
            "description": "Optional list of Node IDs. If not provided, the response includes the status of all the nodes.",
            "explode": false,
            "in": "query",
            "name": "node_ids",
            "required": false,
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          },
          {
            "description": "Indicates if the policy enforcement status should include expanded result for each policy.",
            "in": "query",
            "name": "has_detailed_status",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/NodePolicyCheckResult"
                  },
                  "type": "array"
                }
              }
            },
            "description": "Enforcement status of policies."
          }
        },
        "summary": "Get the status of health monitor policy enforcement",
        "tags": [
          "/health_monitor"
        ],
        "x-group": "health_monitor"
      }
    },
    "/health_monitor/run_policy": {
      "post": {
        "description": "Triggers on-demand enforcement of the set of policies specified in the request body. If a list of nodes is provided, policies are run against these nodes, otherwise the policies are run on all active nodes of the Rubrik cluster.",
        "operationId": "runPolicies",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RunPolicyArg"
              }
            }
          },
          "description": "The request object.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/NodePolicyCheckResult"
                  },
                  "type": "array"
                }
              }
            },
            "description": "Policy enforcement result."
          }
        },
        "summary": "Enforce health monitor policies",
        "tags": [
          "/health_monitor"
        ],
        "x-group": "health_monitor"
      }
    },
    "/hierarchy/bulk_sla_conflicts": {
      "post": {
        "description": "Retrieve the list of descendant objects with an explicitly configured SLA domain, or inherit an SLA domain from a different parent for each managed ID.",
        "operationId": "bulkHierarchySlaConflictsV1",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HierarchyObjectIds"
              }
            }
          },
          "description": "List of hierarchy object IDs.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkSlaConflictsSummary"
                }
              }
            },
            "description": "List of SLA domain conflict summaries for the specified managed IDs.\n"
          }
        },
        "summary": "Retrieve the list of descendant objects with SLA conflicts in bulk",
        "tags": [
          "/hierarchy"
        ],
        "x-group": "hierarchy_v1"
      }
    },
    "/host": {
      "get": {
        "description": "Retrieve summary information for all hosts that are registered with a Rubrik cluster.",
        "operationId": "queryHost",
        "parameters": [
          {
            "description": "Filter the summary information based on the operating system type. Accepted values are 'Windows', 'UnixLike', 'ANY', 'NONE'.\nUse **_NONE_** to only return information for hosts templates that do not have operating system type set.\nUse **_ANY_** to only return information for hosts that have operating system type set.",
            "in": "query",
            "name": "operating_system_type",
            "required": false,
            "schema": {
              "enum": [
                "ANY",
                "NONE",
                "UnixLike",
                "Windows"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter the summary information based on the operating system.\nUse **_AIX_**, **_Linux_** or **_Solaris_** to restrict the returned information to hosts with operating systems within the specified operating system family.\nUse a specific operating system release version to restrict the returned information to hosts with operating systems that match the specified version.",
            "in": "query",
            "name": "operating_system",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filters the summary information based on the Rubrik cluster specified by the value of primary_cluster_id. Use 'local' for the Rubrik cluster that is hosting the current REST API session.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Retrieve hosts with a host name matching the provided name. The search type is infix.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "(Deprecated) Retrieve hosts with a host name matching the provided name. The search type is infix.",
            "in": "query",
            "name": "hostname",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Specifies the host attribute to use in sorting the host summary information. Performs an ASCII sort of the summary information using the specified attribute, in the order specified.\nValid attributes are 'hostname'.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "hostname"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort order, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          {
            "description": "Determines whether to fetch hosts with additional privilege checks.",
            "in": "query",
            "name": "snappable_status",
            "required": false,
            "schema": {
              "enum": [
                "Protectable"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HostSummaryListResponse"
                }
              }
            },
            "description": "Summary information for registered hosts."
          }
        },
        "summary": "Get summary information for hosts",
        "tags": [
          "/host"
        ],
        "x-group": "hosts"
      },
      "post": {
        "description": "Register a host.",
        "operationId": "registerHost",
        "requestBody": {
          "$ref": "#/components/requestBodies/HostRegister"
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HostDetail"
                }
              }
            },
            "description": "Summary information from registration of the host."
          }
        },
        "summary": "Register a host",
        "tags": [
          "/host"
        ],
        "x-group": "hosts"
      }
    },
    "/host/background": {
      "post": {
        "description": "Register a host and perform discovery for databases and Microsoft SQL Server instances. When called, this API returns a success message, but completes the host registration in the background. Monitor the status of the background host discovery with the \"status\" field in GET API on /hosts. The POST API on /hosts can take longer for discovery, depending on the number of hosts on the system. POST on this API can be used instead to perform the discovery in the background and quickly register the host. Doing this requires that you install RBS for Linux and Windows hosts, similar to regular register using POST on /hosts.",
        "operationId": "registerHostAsync",
        "requestBody": {
          "$ref": "#/components/requestBodies/HostRegister"
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HostDetail"
                }
              }
            },
            "description": "Summary host registration information."
          }
        },
        "summary": "Register a host",
        "tags": [
          "/host"
        ],
        "x-group": "hosts"
      }
    },
    "/host/bulk_background": {
      "post": {
        "description": "Register multiple hosts and perform discovery for databases and Microsoft SQL Server instances. When called, this API returns a success message, but completes the host registration in the background. Monitor the status of the background host discovery with the \"status\" field in GET API on /hosts. The POST API on /hosts can take longer for discovery, depending on the number of hosts on the system. POST on this API can be used instead to perform the discovery in the background and quickly register the host. Doing this requires that you install RBS for Linux and Windows hosts, similar to regular register using POST on /hosts.",
        "operationId": "bulkRegisterHostAsync",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/HostRegister"
                },
                "type": "array"
              }
            }
          },
          "description": "Registration definition for each host.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/HostDetail"
                  },
                  "type": "array"
                }
              }
            },
            "description": "Summary information from host registration."
          }
        },
        "summary": "Register hosts",
        "tags": [
          "/host"
        ],
        "x-group": "hosts"
      }
    },
    "/host/certificate/{id}": {
      "put": {
        "description": "Provide an updated certificate for a specified host.",
        "operationId": "updateCertificateHost",
        "parameters": [
          {
            "description": "ID of the host.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HostDetail"
                }
              }
            },
            "description": "Returns a detailed view of the update host."
          }
        },
        "summary": "Update certificate",
        "tags": [
          "/host"
        ],
        "x-group": "hosts"
      }
    },
    "/host/hierarchy/{id}": {
      "get": {
        "description": "Retrieve details for the specified object in the host/share hierarchy.\n",
        "operationId": "getHostHierarchyObject",
        "parameters": [
          {
            "description": "ID of the host hierarchy object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HostHierarchyObjectSummary"
                }
              }
            },
            "description": "Details of the hierarchy object."
          }
        },
        "summary": "Get summary of a host/share hierarchy object",
        "tags": [
          "/host/hierarchy"
        ],
        "x-group": "host_hierarchy"
      }
    },
    "/host/hierarchy/{id}/children": {
      "get": {
        "description": "Retrieve the list of immediate descendant objects for the specified parent.",
        "operationId": "getHostHierarchyChildren",
        "parameters": [
          {
            "description": "ID of the parent host hierarchy object. To get top-level nodes, use **root** as the ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Search object by object name.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by node object type.",
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "enum": [
                "Host",
                "Share"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter by ID of effective SLA domain.",
            "in": "query",
            "name": "effective_sla_domain_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by primary cluster ID, or **local**.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limit a response to the results that have the specified SLA Domain assignment type.",
            "in": "query",
            "name": "sla_assignment",
            "required": false,
            "schema": {
              "enum": [
                "Derived",
                "Direct",
                "Unassigned"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter by fileset template ID.",
            "in": "query",
            "name": "template_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by NAS vendor.",
            "in": "query",
            "name": "vendor_type",
            "required": false,
            "schema": {
              "enum": [
                "Isilon",
                "NetApp",
                "FlashBlade"
              ],
              "type": "string"
            }
          },
          {
            "description": "Search object by export point.",
            "in": "query",
            "name": "export_point",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter the summary information based on the operating system type. Accepted values are 'Windows', 'UnixLike', 'ANY', 'NONE'.\nUse **_NONE_** to only return information for hosts templates that do not have operating system type set.\nUse **_ANY_** to only return information for hosts that have operating system type set.",
            "in": "query",
            "name": "operating_system_type",
            "required": false,
            "schema": {
              "enum": [
                "ANY",
                "NONE",
                "UnixLike",
                "Windows"
              ],
              "type": "string"
            }
          },
          {
            "description": "Attribute to sort the results on.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "Status",
                "Name",
                "ExportPoint",
                "ShareType",
                "Hostname"
              ],
              "type": "string"
            }
          },
          {
            "description": "Order for sorting the results, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "default": "asc",
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          {
            "description": "Limit the number of matches returned.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Number of matches to ignore from the beginning of the results.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HostHierarchyObjectSummaryListResponse"
                }
              }
            },
            "description": "Summary list of immediate descendant objects."
          }
        },
        "summary": "Get immediate descendant objects",
        "tags": [
          "/host/hierarchy"
        ],
        "x-group": "host_hierarchy"
      }
    },
    "/host/make_primary": {
      "post": {
        "description": "Migrate the primary cluster with which the agent is able to perform regular operations (backup, restore etc). This can be done on a specified set of hosts or for all hosts that currently have a specified primary cluster for disaster recovery. Specify exactly one of `ids` or `oldPrimaryClusterUuid`.",
        "operationId": "hostMakePrimary",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HostMakePrimaryRequest"
              }
            }
          },
          "description": "Description of hosts to migrate.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Asynchronous request for making this cluster primary."
          }
        },
        "summary": "Make this cluster the primary for agents on a set of hosts",
        "tags": [
          "/host"
        ],
        "x-group": "hosts"
      }
    },
    "/host/rbs": {
      "get": {
        "description": "Get the details of the Rubrik Backup Service (RBS) installed on a specific host. Specify the details of the host to check whether RBS is installed on the host or not. If RBS is installed, the response will include the RBS details.",
        "operationId": "getRbsHostInfo",
        "parameters": [
          {
            "description": "IP address or hostname of the host.",
            "in": "query",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Name of the user account that has sudo/admin privileges on the RBS host. This is required to install/uninstall/upgrade RBS packages on the RBS host.",
            "in": "query",
            "name": "username",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Password associated with the username that has access to the host.",
            "in": "query",
            "name": "password",
            "required": true,
            "schema": {
              "type": "string"
            },
            "x-secret": true
          },
          {
            "description": "Number of seconds after which the operation is terminated if it has not completed execution. Default value is 600 seconds.",
            "in": "query",
            "name": "operation_timeout",
            "required": false,
            "schema": {
              "default": 600,
              "format": "int64",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RbsHostSummary"
                }
              }
            },
            "description": "Rubrik Backup Service details for the specified host."
          },
          "404": {
            "description": "Rubrik Backup Service is not installed on the host."
          },
          "422": {
            "description": "Failed to get Rubrik Backup Service details for the specified host."
          }
        },
        "summary": "Get the Rubrik Backup Service details for a host",
        "tags": [
          "/host"
        ],
        "x-group": "hosts"
      }
    },
    "/host/rbs/install": {
      "post": {
        "description": "Install Rubrik Backup Service on a host.",
        "operationId": "rbsInstall",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RbsHostOperationRequest"
              }
            }
          },
          "description": "Configuration parameters to install RBS on a host.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RbsHostOperationResponse"
                }
              }
            },
            "description": "Response for the Rubrik Backup Service installation request."
          },
          "408": {
            "description": "Rubrik Backup Service install operation timed out on the host."
          },
          "422": {
            "description": "Failed to install Rubrik Backup Service on the host."
          }
        },
        "summary": "Install Rubrik Backup Service on a host",
        "tags": [
          "/host"
        ],
        "x-group": "hosts"
      }
    },
    "/host/rbs/uninstall": {
      "post": {
        "description": "Uninstall Rubrik Backup Service from a host.",
        "operationId": "rbsUninstall",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RbsHostOperationRequest"
              }
            }
          },
          "description": "Configuration parameters to uninstall RBS from a host.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RbsHostOperationResponse"
                }
              }
            },
            "description": "Successfully uninstalled RBS from the host."
          },
          "408": {
            "description": "Rubrik Backup Service uninstall operation timed out on the host."
          },
          "422": {
            "description": "Failed to uninstall Rubrik Backup Service from the host."
          }
        },
        "summary": "Uninstall Rubrik Backup Service from a host",
        "tags": [
          "/host"
        ],
        "x-group": "hosts"
      }
    },
    "/host/rbs/upgrade": {
      "post": {
        "description": "Upgrade Rubrik Backup Service on a host.",
        "operationId": "rbsUpgrade",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RbsHostOperationRequest"
              }
            }
          },
          "description": "Configuration parameters to upgrade RBS on a host.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RbsHostOperationResponse"
                }
              }
            },
            "description": "Rubrik Backup Service upgrade response."
          },
          "408": {
            "description": "Rubrik Backup Service upgrade operation timed out on the host."
          },
          "422": {
            "description": "Failed to upgrade Rubrik Backup Service on the host."
          }
        },
        "summary": "Upgrade Rubrik Backup Service on a host",
        "tags": [
          "/host"
        ],
        "x-group": "hosts"
      }
    },
    "/host/share/bulk": {
      "patch": {
        "description": "Update the properties of the objects that represent the specified network share.",
        "operationId": "bulkUpdateHostShare",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/HostShareUpdate"
                },
                "type": "array"
              }
            }
          },
          "description": "Properties to use for the update of network share objects.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/HostShareDetail"
                  },
                  "type": "array"
                }
              }
            },
            "description": "Returns a detailed view of all updated network share objects."
          }
        },
        "summary": "Update network shares",
        "tags": [
          "/host/share"
        ],
        "x-group": "hosts"
      },
      "post": {
        "description": "Add NAS shares for a NAS host to the Rubrik cluster in bulk. This operation does not validate share credentials. If the default share credentials are incorrect, the share status on shares UI displays as \"Wrong credential\". Use the PATCH /v1/host/share/bulk endpoint to enter the correct credentials when this status displays.",
        "operationId": "bulkAddHostShares",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NasSharesToAdd"
              }
            }
          },
          "description": "The properties used to add the NAS Shares to the Rubrik cluster.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkShareAddResponse"
                }
              }
            },
            "description": "Returns a detailed view of all added network share objects and status of the job that validates the default credentials added to each object."
          }
        },
        "summary": "Add NAS shares in bulk",
        "tags": [
          "/host/share"
        ],
        "x-group": "hosts"
      }
    },
    "/host/{id}": {
      "delete": {
        "description": "Delete host by specifying the host ID.",
        "operationId": "deleteHost",
        "parameters": [
          {
            "description": "ID of the host to delete.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted specified host."
          }
        },
        "summary": "Delete a registered host",
        "tags": [
          "/host"
        ],
        "x-group": "hosts"
      },
      "get": {
        "description": "Retrieve summary information for a registered host.",
        "operationId": "getHost",
        "parameters": [
          {
            "description": "ID of the registered host.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HostDetail"
                }
              }
            },
            "description": "Summary information for the specified host."
          }
        },
        "summary": "Get summary information for a host",
        "tags": [
          "/host"
        ],
        "x-group": "hosts"
      },
      "patch": {
        "description": "Change the FQDN and IPv4 address that is assigned to a host object. Enable or disable pre-transfer data compression. Enable or disable change block tracking (CBT) for backups of SQL Server databases on Windows hosts. Enable or disable volume filter driver (VFD) for volume backups on Windows hosts. Set an Oracle user with sysdba privileges to permit Oracle discovery queries.",
        "operationId": "updateHost",
        "parameters": [
          {
            "description": "ID of the registered host.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HostUpdate"
              }
            }
          },
          "description": "Properties of host to update.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HostDetail"
                }
              }
            },
            "description": "Summary information for the specified host."
          }
        },
        "summary": "Modify information for a registered host",
        "tags": [
          "/host"
        ],
        "x-group": "hosts"
      }
    },
    "/host/{id}/nas_share_discover": {
      "get": {
        "description": "Discover and return all shares on the identified NAS host.",
        "operationId": "discoverNasShares",
        "parameters": [
          {
            "description": "The discoverable NAS host ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/DiscoveredNasShare"
                  },
                  "type": "array"
                }
              }
            },
            "description": "The discovered NAS shares."
          }
        },
        "summary": "Discover and return all shares on a NAS host",
        "tags": [
          "/host"
        ],
        "x-group": "hosts"
      }
    },
    "/host/{id}/refresh": {
      "post": {
        "description": "Refresh the properties of a host object when changes on the host are not seen in the Rubrik web UI.",
        "operationId": "refreshHost",
        "parameters": [
          {
            "description": "ID assigned to a host object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HostDetail"
                }
              }
            },
            "description": "Refreshed the properties shown for the specified host."
          }
        },
        "summary": "Refresh a host",
        "tags": [
          "/host"
        ],
        "x-group": "hosts"
      }
    },
    "/host/{id}/search": {
      "get": {
        "description": "Search for a file within the host. Search via full path prefix or filename prefix.",
        "operationId": "searchHost",
        "parameters": [
          {
            "description": "ID of the host to search.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The path query. Either path prefix or filename prefix.",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResponseListResponse"
                }
              }
            },
            "description": "Search results."
          }
        },
        "summary": "Search for a file within the host",
        "tags": [
          "/host"
        ],
        "x-group": "hosts"
      }
    },
    "/host/{id}/volume": {
      "get": {
        "description": "Retrieve summary information for each volume on a specified Volume Group host.",
        "operationId": "queryHostVolume",
        "parameters": [
          {
            "description": "The ID of the host.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HostVolumeSummaryListResponse"
                }
              }
            },
            "description": "Get volume summary from the host."
          }
        },
        "summary": "Get list of Volume Group volumes",
        "tags": [
          "/host"
        ],
        "x-group": "volume_group"
      }
    },
    "/hyperv/vm/{id}/request/force_full_snapshot": {
      "get": {
        "description": "Retrieve the configuration created to force a full snapshot for a Hyper-V Virtual Machine.",
        "operationId": "getHypervVirtualMachineForceFullSpec",
        "parameters": [
          {
            "description": "The ID of the Hyper-V virtual machine.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HypervVirtualMachineForceFullResponse"
                }
              }
            },
            "description": "Return the configuration created to force a full snapshot on the Hyper-V virtual machine."
          }
        },
        "summary": "Retrieve the configuration which has been set for forcing a full snapshot for a Hyper-V Virtual Machine",
        "tags": [
          "/hyperv/vm"
        ],
        "x-group": "hyperv_vm"
      },
      "post": {
        "description": "Request a full snapshot during the next backup job of a Hyper-V virtual machine.",
        "operationId": "requestHypervVirtualMachineForceFullSnapshot",
        "parameters": [
          {
            "description": "ID of the Hyper-V virtual machine.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HypervVirtualMachineForceFullRequest"
              }
            }
          },
          "description": "Configuration created to force a full snapshot on the Hyper-V virtual machine.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HypervVirtualMachineForceFullResponse"
                }
              }
            },
            "description": "Returns the Hyper-V virtual machine force full response containing the configuration for each virtual disk that requested a forced full snapshot."
          }
        },
        "summary": "Request a full snapshot during next backup job of a Hyper-V virtual machine",
        "tags": [
          "/hyperv/vm"
        ],
        "x-group": "hyperv_vm"
      }
    },
    "/idp_auth_domain": {
      "get": {
        "description": "Get a list of IdP authentication domains.",
        "operationId": "queryIdProviderAuthDomain",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdProviderAuthDomainSummaryListResponse"
                }
              }
            },
            "description": "Returns the list of IdP authentication domains."
          }
        },
        "summary": "Get a list of IdP authentication domains",
        "tags": [
          "/idp_auth_domain"
        ],
        "x-group": "idp_auth_domain"
      },
      "post": {
        "description": "Add a new IdP authentication domain.",
        "operationId": "createIdProviderAuthDomain",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IdProviderAuthDomainInfo"
              }
            }
          },
          "description": "Information for joining an IdP authentication domain.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdProviderAuthDomainSummary"
                }
              }
            },
            "description": "Returns a summary of the newly created IdP authentication domain."
          }
        },
        "summary": "Add a new IdP authentication domain",
        "tags": [
          "/idp_auth_domain"
        ],
        "x-group": "idp_auth_domain",
        "x-rk-block-api-tokens": true
      }
    },
    "/idp_auth_domain/{id}": {
      "delete": {
        "description": "Delete an IdP authentication domain for the given ID.",
        "operationId": "deleteIdProviderAuthDomain",
        "parameters": [
          {
            "description": "ID of the IdP authentication domain to be deleted.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete Successful."
          }
        },
        "summary": "Delete an IdP authentication domain for the given ID",
        "tags": [
          "/idp_auth_domain"
        ],
        "x-group": "idp_auth_domain",
        "x-rk-block-api-tokens": true
      },
      "get": {
        "description": "Get an IdP authentication domain for the given id.",
        "operationId": "getIdProviderAuthDomain",
        "parameters": [
          {
            "description": "ID of the IdP Authentication Domain to be retrieved.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdProviderAuthDomainSummary"
                }
              }
            },
            "description": "Returns a summary of the requested IdP authentication domain."
          }
        },
        "summary": "Get an IdP authentication domain for the given id",
        "tags": [
          "/idp_auth_domain"
        ],
        "x-group": "idp_auth_domain"
      },
      "patch": {
        "description": "Update an existing IdP authentication domain.",
        "operationId": "updateIdProviderAuthDomain",
        "parameters": [
          {
            "description": "ID of the IdP authentication domain to be updated.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IdProviderAuthDomainInfoUpdate"
              }
            }
          },
          "description": "Information for updating an IdP authentication domain.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdProviderAuthDomainSummary"
                }
              }
            },
            "description": "Returns a summary of the newly updated IdP authentication domain."
          }
        },
        "summary": "Update an existing IdP authentication domain",
        "tags": [
          "/idp_auth_domain"
        ],
        "x-group": "idp_auth_domain",
        "x-rk-block-api-tokens": true
      }
    },
    "/job_monitoring": {
      "get": {
        "description": "Get the job summary for protection and recovery jobs that are currently running, scheduled to run, or completed in the past 24 hours.",
        "operationId": "getJobMonitoringInfo",
        "parameters": [
          {
            "description": "Maximum number of entries to retrieve. The default value is 25. Value needs to be a positive number.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "type": "integer"
            }
          },
          {
            "description": "Filters results by the current event status of the job. The filters should be separated by ','.",
            "explode": false,
            "in": "query",
            "name": "job_event_status",
            "required": false,
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          },
          {
            "description": "Filters results by job type.",
            "in": "query",
            "name": "job_type",
            "required": false,
            "schema": {
              "enum": [
                "Archival",
                "Backup",
                "Conversion",
                "Recovery",
                "Replication",
                "Index",
                "LogBackup",
                "LogArchival",
                "LogReplication",
                "LogShipping"
              ],
              "type": "string"
            }
          },
          {
            "description": "A Boolean that specifies whether or not to include log- related jobs. Default value is 'false'.",
            "in": "query",
            "name": "should_include_log_related_job",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Filter results by first full status.",
            "in": "query",
            "name": "is_first_full",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Filters results by a specified object type.",
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "enum": [
                "AppBlueprint",
                "Ec2Instance",
                "Hdfs",
                "HypervVirtualMachine",
                "LinuxFileset",
                "ManagedVolume",
                "Mssql",
                "NutanixVirtualMachine",
                "OracleDatabase",
                "SapHanaDatabase",
                "ShareFileset",
                "StorageArrayVolumeGroup",
                "VcdVapp",
                "VmwareVirtualMachine",
                "WindowsFileset",
                "WindowsVolumeGroup"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filters results by the provided value for object_name, using infix search.",
            "in": "query",
            "name": "object_name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter results by node name.",
            "in": "query",
            "name": "node_name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filters results by the provided sla doimain id.",
            "in": "query",
            "name": "effective_sla_domain_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filters results according to their on-demand status.",
            "in": "query",
            "name": "is_on_demand",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "All rows updated at or after this time will be returned.",
            "in": "query",
            "name": "last_update_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "Fetches all rows after given row cursor.",
            "in": "query",
            "name": "after_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The column by which to sort the entries.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "StartTime",
                "JobStatus",
                "JobType",
                "ObjectType",
                "SlaDomainName",
                "EndTime",
                "ObjectLogicalSize",
                "DataTransferred",
                "Duration",
                "ObjectName"
              ],
              "type": "string"
            }
          },
          {
            "description": "The sorting order.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobMonitoringResponse"
                }
              }
            },
            "description": "Returns job information."
          }
        },
        "summary": "Get job monitoring information",
        "tags": [
          "/job_monitoring"
        ],
        "x-group": "job_monitoring"
      }
    },
    "/job_monitoring/csv_download_link": {
      "get": {
        "description": "Download the job summary for protection and recovery jobs that are currently running, scheduled to run, or completed in the past 24 hours as a CSV file. This is a synchronous operation.",
        "operationId": "getJobMonitoringInfoCsvDownloadLink",
        "parameters": [
          {
            "description": "State of the jobs in the CSV.",
            "in": "query",
            "name": "job_monitoring_state",
            "required": true,
            "schema": {
              "enum": [
                "Failure",
                "Scheduled",
                "Success",
                "Active",
                "Canceled"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filters results by the current event status of the job.",
            "in": "query",
            "name": "job_event_status",
            "required": false,
            "schema": {
              "enum": [
                "Failure",
                "Success",
                "Queued",
                "Scheduled",
                "Active",
                "Canceling",
                "Canceled",
                "SuccessfulWithWarnings",
                "CancelingScheduled"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filters results by job type.",
            "in": "query",
            "name": "job_type",
            "required": false,
            "schema": {
              "enum": [
                "Archival",
                "Backup",
                "Conversion",
                "Recovery",
                "Replication",
                "Index",
                "LogBackup",
                "LogArchival",
                "LogReplication",
                "LogShipping"
              ],
              "type": "string"
            }
          },
          {
            "description": "A Boolean that specifies whether or not to include log- related jobs. Default value is 'false'.",
            "in": "query",
            "name": "should_include_log_related_job",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Filters results by a specified object type.",
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "enum": [
                "AppBlueprint",
                "Ec2Instance",
                "Hdfs",
                "HypervVirtualMachine",
                "LinuxFileset",
                "ManagedVolume",
                "Mssql",
                "NutanixVirtualMachine",
                "OracleDatabase",
                "SapHanaDatabase",
                "ShareFileset",
                "StorageArrayVolumeGroup",
                "VcdVapp",
                "VmwareVirtualMachine",
                "WindowsFileset",
                "WindowsVolumeGroup"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filters results by the provided value for object_name, using infix search.",
            "in": "query",
            "name": "object_name",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobMonitoringCsvDownloadResponse"
                }
              }
            },
            "description": "Download link of the requested CSV file."
          }
        },
        "summary": "Download job monitoring information as a CSV file",
        "tags": [
          "/job_monitoring"
        ],
        "x-group": "job_monitoring"
      }
    },
    "/job_monitoring/subscription": {
      "get": {
        "description": "Return all unarchived email subscriptions for monitoring page in a list of summaries sorted by creation time (earliest created first). Each summary contains information for each subscription -- Time attributes - when to send the email -- Email addresses - who to send the email -- Attachments - what attachments should the email include -- Job states - which job states to include in the email (Failure, Scheduled, Success, Active, Canceled). -- Id - the tring that identifies the subscription -- Status - the status of the subscription (Active, Suspended, or Unknown) -- Owner - information about the owner of the subscription -- user id - unique id used to identify the owner -- user name - human-readable name of user the time schedule to send the subscription.",
        "operationId": "getMonitoringSubscriptions",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/MonitoringSubscriptionSummary"
                  },
                  "type": "array"
                }
              }
            },
            "description": "Summary of email subscriptions for the monitoring page."
          }
        },
        "summary": "Returns all email subscriptions for the monitoring page",
        "tags": [
          "/job_monitoring"
        ],
        "x-group": "job_monitoring"
      },
      "post": {
        "description": "Creates an email subscription to the job monitoring page, which provides information on jobs based on their type (active, in progress, canceled, scheduled, or succeeded). Users can choose which job states to include in the subscription. The email summarizes the job counts by type in the body, and includes the option to include CSV attachments for every job state selected.",
        "operationId": "createMonitoringSubscription",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MonitoringEmailSubscriptionRequest"
              }
            }
          },
          "description": "All information required to create a job-monitoring email subscription.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MonitoringSubscriptionSummary"
                }
              }
            },
            "description": "Summary of the email subscription."
          }
        },
        "summary": "Create an email subscription to the job monitoring page",
        "tags": [
          "/job_monitoring"
        ],
        "x-group": "job_monitoring"
      }
    },
    "/job_monitoring/subscription/{subscription_id}": {
      "delete": {
        "description": "Deletes the specified monitoring page email subscription.",
        "operationId": "deleteMonitoringSubscription",
        "parameters": [
          {
            "description": "ID of the monitoring subscription to delete.",
            "in": "path",
            "name": "subscription_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Monitoring email subscription was successfully deleted."
          }
        },
        "summary": "Delete a monitoring page email subscription",
        "tags": [
          "/job_monitoring"
        ],
        "x-group": "job_monitoring"
      },
      "get": {
        "description": "Returns a summary of the provided monitoring subscription.",
        "operationId": "getMonitoringSubscription",
        "parameters": [
          {
            "description": "ID of the monitoring subscription to acquire.",
            "in": "path",
            "name": "subscription_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MonitoringSubscriptionSummary"
                }
              }
            },
            "description": "Summary of the email subscription."
          }
        },
        "summary": "Get a specific monitoring email subscription by id",
        "tags": [
          "/job_monitoring"
        ],
        "x-group": "job_monitoring"
      },
      "patch": {
        "description": "Updates the monitoring email subscription with the subscription ID provided.",
        "operationId": "updateMonitoringSubscription",
        "parameters": [
          {
            "description": "ID of the monitoring subscription.",
            "in": "path",
            "name": "subscription_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MonitoringEmailSubscriptionUpdate"
              }
            }
          },
          "description": "Information required to update a monitoring subscription.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MonitoringSubscriptionSummary"
                }
              }
            },
            "description": "Summary of the email subscription."
          }
        },
        "summary": "Update a monitoring email subscription",
        "tags": [
          "/job_monitoring"
        ],
        "x-group": "job_monitoring"
      }
    },
    "/job_monitoring/summary_by_job_state": {
      "get": {
        "description": "Get job summary separated by job state for all running jobs, jobs that have been scheduled and jobs that are complete, for protection and recovery jobs in the past 24 hours.",
        "operationId": "getMonitoringJobCountByJobState",
        "parameters": [
          {
            "description": "Filter by a comma separated list of job types.",
            "explode": false,
            "in": "query",
            "name": "job_types",
            "required": false,
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobMonitoringSummaryByState"
                }
              }
            },
            "description": "Returns information about the job counts for the events that match the query parameters."
          }
        },
        "summary": "Get job monitoring summary information separated by job state",
        "tags": [
          "/job_monitoring"
        ],
        "x-group": "job_monitoring"
      }
    },
    "/job_monitoring/summary_by_job_type": {
      "get": {
        "description": "Get job summaries for protection and recovery jobs, separated by job type, that have been scheduled, are currently running, or completed in the past 24 hours.",
        "operationId": "getMonitoringJobCountByJobType",
        "parameters": [
          {
            "description": "Filter by job state.",
            "in": "query",
            "name": "job_monitoring_state",
            "required": true,
            "schema": {
              "enum": [
                "Failure",
                "Scheduled",
                "Success",
                "Active",
                "Canceled"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobMonitoringSummaryByType"
                }
              }
            },
            "description": "Returns information about the job counts for the events that match the query parameters."
          }
        },
        "summary": "Get job monitoring summary information separated by job type",
        "tags": [
          "/job_monitoring"
        ],
        "x-group": "job_monitoring"
      }
    },
    "/ldap_service": {
      "get": {
        "description": "Get a list of LDAP services.",
        "operationId": "queryLdapService",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LdapServiceSummaryListResponse"
                }
              }
            },
            "description": "Returns the list of authentication domains."
          }
        },
        "summary": "Get a list of LDAP services",
        "tags": [
          "/ldap_service"
        ],
        "x-group": "ldap_service"
      },
      "post": {
        "description": "Add a new authentication domain.",
        "operationId": "createLdapService",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LdapServiceInfo"
              }
            }
          },
          "description": "Information for joining an authentication domain.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LdapServiceSummary"
                }
              }
            },
            "description": "Returns a summary of the newly created authentication. domain."
          }
        },
        "summary": "Add a new authentication domain",
        "tags": [
          "/ldap_service"
        ],
        "x-group": "ldap_service",
        "x-rk-block-api-tokens": true
      }
    },
    "/ldap_service/{id}": {
      "delete": {
        "description": "Delete an authentication domain for the given ID.",
        "operationId": "deleteLdapService",
        "parameters": [
          {
            "description": "ID of the authentication domain to be deleted.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successful."
          }
        },
        "summary": "Delete an authentication domain for the given ID",
        "tags": [
          "/ldap_service"
        ],
        "x-group": "ldap_service",
        "x-rk-block-api-tokens": true
      },
      "get": {
        "description": "Get a LDAP service for the given ID.",
        "operationId": "getLdapService",
        "parameters": [
          {
            "description": "ID of the authentication domain to be retrieved.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LdapServiceSummary"
                }
              }
            },
            "description": "Returns a summary of the requested authentication domain."
          }
        },
        "summary": "Get a LDAP service for the given ID",
        "tags": [
          "/ldap_service"
        ],
        "x-group": "ldap_service"
      },
      "patch": {
        "description": "Modify the values of a specified authentication domain object.",
        "operationId": "patchLdapService",
        "parameters": [
          {
            "description": "ID of the authentication domain to be updated.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/LdapServiceInfoUpdate"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LdapServiceSummary"
                }
              }
            },
            "description": "Returns a summary of the newly updated authentication domain."
          }
        },
        "summary": "Update an existing authentication domain",
        "tags": [
          "/ldap_service"
        ],
        "x-group": "ldap_service",
        "x-rk-block-api-tokens": true
      },
      "put": {
        "description": "Replace the values of a specified authentication domain object.",
        "operationId": "putLdapService",
        "parameters": [
          {
            "description": "ID of the authentication domain to be updated.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/LdapServiceInfoUpdate"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LdapServiceSummary"
                }
              }
            },
            "description": "Returns a summary of the newly updated authentication domain."
          }
        },
        "summary": "Replace the values of an authentication domain",
        "tags": [
          "/ldap_service"
        ],
        "x-group": "ldap_service",
        "x-rk-block-api-tokens": true
      }
    },
    "/legal_hold/object": {
      "get": {
        "description": "Returns the object details for object with snapshots under legal hold.",
        "operationId": "getLegalHoldObjects",
        "parameters": [
          {
            "description": "Limit the list to a particular object.",
            "in": "query",
            "name": "object_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limit the number of matches returned.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Specifies a number of initial matches to ignore.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Limits the list to objects that match a specified value for the object name.",
            "in": "query",
            "name": "object_name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limits the list to objects that match a specified type.",
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The attribute used to sort summary information. The optional parameter _sort_order_ specifies ascending or descending sort order.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "objectName",
                "objectType",
                "numberOfSnapshotsHeld"
              ],
              "type": "string"
            }
          },
          {
            "description": "Specifies ascending or descending sort order. Summary results are sorted in ascending order when this parameter is not specified.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "default": "asc",
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObjectHoldSummaryListResponse"
                }
              }
            },
            "description": "List of details for objects with snasphots in a legal hold status."
          }
        },
        "summary": "Get objects part of Legal Hold",
        "tags": [
          "/legal_hold"
        ],
        "x-group": "legal_hold"
      }
    },
    "/legal_hold/object/{id}/dissolve": {
      "post": {
        "description": "Dissolve a collection of snapshots of specified data source from Legal Hold.",
        "operationId": "dissolveLegalHoldSnapshots",
        "parameters": [
          {
            "description": "ID of the data source.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DissolveLegalHoldDefinition"
              }
            }
          },
          "description": "An object that contains the IDs of the snapshots to remove from legal hold status.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DissolveLegalHoldResponse"
                }
              }
            },
            "description": "List of snapshots whose legal holds have been successfully dissolved."
          }
        },
        "summary": "Dissolve a collection of snapshots of specified data source from Legal Hold",
        "tags": [
          "/legal_hold"
        ],
        "x-group": "legal_hold"
      }
    },
    "/legal_hold/snapshot": {
      "get": {
        "description": "Get summary for snapshots under legal hold. If object_id is passed, return summary information only for snapshots of the object under legal hold else return summary for all snapshots under legal hold.",
        "operationId": "queryLegalHold",
        "parameters": [
          {
            "description": "Limit the list to snapshot for the particular object.",
            "in": "query",
            "name": "object_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limit the number of matches returned.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "An integer that specifies a number of initial matches to ignore.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Limits the list to objects that match a specified value for the object name.",
            "in": "query",
            "name": "object_name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limits the list to objects that match a specified type.",
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limits the list to snapshots with holds created before a specified date.",
            "in": "query",
            "name": "before_date",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "Limits the list to snapshots with holds created after a specified date.",
            "in": "query",
            "name": "after_date",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "Limits the list to snapshots which were placed on legal hold before a specified date.",
            "in": "query",
            "name": "placed_on_hold_before_date",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "Limits the list to snapshots which were placed on legal hold after a specified date.",
            "in": "query",
            "name": "placed_on_hold_after_date",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "The attribute used to sort summary information. The optional parameter **_sort_order_** specifies ascending or descending sort order.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "SnapshotTime",
                "PlaceOnHoldTime",
                "SnapshotType"
              ],
              "type": "string"
            }
          },
          {
            "description": "Specifies ascending or descending sort order. Summary results are sorted in ascending order when this parameter is not specified.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "default": "asc",
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          {
            "description": "Specifies the type of snapshots to be returned.",
            "in": "query",
            "name": "snapshot_type",
            "required": false,
            "schema": {
              "enum": [
                "OnDemand",
                "Scheduled",
                "Protected",
                "Unprotected"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegalHoldSummaryListResponse"
                }
              }
            },
            "description": "Summary information for legal holds."
          }
        },
        "summary": "Get snasphots held under legal hold",
        "tags": [
          "/legal_hold"
        ],
        "x-group": "legal_hold"
      },
      "post": {
        "description": "Places a snapshot on legal hold by specifying the hold requirements.",
        "operationId": "applyLegalHold",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ApplyLegalHoldDefinition"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegalHoldSummary"
                }
              }
            },
            "description": "Summary of the hold which has just been created."
          }
        },
        "summary": "Apply a Legal Hold",
        "tags": [
          "/legal_hold"
        ],
        "x-group": "legal_hold"
      }
    },
    "/managed_volume/snapshot/export/{id}/script": {
      "post": {
        "description": "Start an asynchronous job to generate and download a script to unify export paths across channels in managed volume export.",
        "operationId": "createManagedVolumeGenerateScriptJob",
        "parameters": [
          {
            "description": "ID of snapshot export.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of an asynchronous job to generate unified view script."
          }
        },
        "summary": "Generate and download unified view script",
        "tags": [
          "/managed_volume"
        ],
        "x-group": "managed_volume"
      }
    },
    "/mfa/rsa/server": {
      "get": {
        "description": "Get RSA server configuration.",
        "operationId": "queryRsaMfaServers",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RsaMfaServerDetailListResponse"
                }
              }
            },
            "description": "Configuration summary of known RSA servers."
          }
        },
        "summary": "Get RSA server configuration",
        "tags": [
          "/mfa/rsa"
        ],
        "x-group": "mfa"
      },
      "post": {
        "description": "Register a new RSA server using specified configuration.",
        "operationId": "createRsaMfaServer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RsaMfaServerConfig"
              }
            }
          },
          "description": "Configuration of RSA server.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RsaMfaServerDetail"
                }
              }
            },
            "description": "Added a new RSA server."
          }
        },
        "summary": "Register a new RSA server",
        "tags": [
          "/mfa/rsa"
        ],
        "x-group": "mfa"
      }
    },
    "/mfa/rsa/server/{id}": {
      "delete": {
        "description": "Delete RSA server configuration.",
        "operationId": "deleteRsaMfaServer",
        "parameters": [
          {
            "description": "ID of the RSA server.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "RSA server configuration removed."
          }
        },
        "summary": "Delete RSA server"<<MASK>>
        "parameters": [
          {
            "description": "ID of the RSA server.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RsaMfaServerDetail"
                }
              }
            },
            "description": "Configuration summary of known RSA servers."
          }
        },
        "summary": "Get RSA server configuration",
        "tags": [
          "/mfa/rsa"
        ],
        "x-group": "mfa"
      },
      "patch": {
        "description": "Update an existing RSA server using specified configuration.",
        "operationId": "updateRsaMfaServer",
        "parameters": [
          {
            "description": "ID of the RSA server.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RsaMfaServerConfigUpdate"
              }
            }
          },
          "description": "Configuration of RSA server.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RsaMfaServerDetail"
                }
              }
            },
            "description": "Updated RSA server configuration."
          }
        },
        "summary": "Update RSA server configuration",
        "tags": [
          "/mfa/rsa"
        ],
        "x-group": "mfa",
        "x-rk-block-api-tokens": true
      }
    },
    "/mssql/availability_group": {
      "get": {
        "description": "Returns a list of summary information for Microsoft SQL availability groups.",
        "operationId": "queryMssqlAvailabilityGroupV1",
        "parameters": [
          {
            "description": "Filter by primary cluster.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlAvailabilityGroupSummaryListResponse"
                }
              }
            },
            "description": "Returned if the query was successful."
          }
        },
        "summary": "Returns summary information for Microsoft SQL availability groups",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql_availability_group"
      }
    },
    "/mssql/availability_group/{id}": {
      "get": {
        "description": "Returns a detailed view of a Microsoft SQL availability group.",
        "operationId": "getMssqlAvailabilityGroupV1",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL availability group to fetch.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlAvailabilityGroupDetail"
                }
              }
            },
            "description": "Returned if the query was successful."
          }
        },
        "summary": "Returns detailed information for a Microsoft SQL availability group",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql_availability_group"
      },
      "patch": {
        "description": "Update a Microsoft SQL availability group with the specified properties.",
        "operationId": "updateMssqlAvailabilityGroupV1",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL availability group to update.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MssqlAvailabilityGroupUpdate"
              }
            }
          },
          "description": "Properties to update.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlAvailabilityGroupDetail"
                }
              }
            },
            "description": "Returned if the update was successful."
          }
        },
        "summary": "Update a Microsoft SQL availability group",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql_availability_group"
      }
    },
    "/mssql/db": {
      "get": {
        "description": "Returns a list of summary information for Microsoft SQL databases.",
        "operationId": "queryMssqlDb",
        "parameters": [
          {
            "description": "Filter by Microsoft SQL instance.",
            "in": "query",
            "name": "instance_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by the `id` of an Always On Availability Group.",
            "in": "query",
            "name": "availability_group_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by effective SLA domain.",
            "in": "query",
            "name": "effective_sla_domain_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by primary cluster.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by a substring of the database name.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "SLA Assignment of the database.",
            "in": "query",
            "name": "sla_assignment",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limit the number of matches returned.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "An integer that specifies a number of initial matches to ignore.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Filter database summary information by the value of the `isRelic` field.",
            "in": "query",
            "name": "is_relic",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Filter database summary information by the value of the `isLiveMount` field.",
            "in": "query",
            "name": "is_live_mount",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Filter database summary information by the value of the `isLogShippingSecondary` field.",
            "in": "query",
            "name": "is_log_shipping_secondary",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Specifies the SQL Server Database attribute to use in sorting the summary information. Performs an ASCII sort using the specified attribute, in the order specified by sort_order.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "copyOnly",
                "effectiveSlaDomainName",
                "logBackupRetentionHours",
                "name"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort order, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          {
            "description": "Include backup task information in response.",
            "in": "query",
            "name": "include_backup_task_info",
            "required": false,
            "schema": {
              "default": false,
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlDbSummaryListResponse"
                }
              }
            },
            "description": "Returned if the query was successful."
          }
        },
        "summary": "Get summary information for SQL Server databases",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/bulk": {
      "patch": {
        "description": "Update multiple Microsoft SQL databases with the specified properties.",
        "operationId": "bulkUpdateMssqlDbV1",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/MssqlDbUpdateId"
                },
                "type": "array"
              }
            }
          },
          "description": "Properties to update for each database.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/MssqlDbDetail"
                  },
                  "type": "array"
                }
              }
            },
            "description": "Returns a detailed view of all updated databases."
          }
        },
        "summary": "Update multiple Microsoft SQL databases",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/bulk/snapshot": {
      "post": {
        "description": "Take an on-demand backup of one or more Microsoft SQL databases. Set the forceFullSnapshot property to true to force a full snapshot for every database that is specified. Only one snapshot will be taken for each database, even if a database is included multiple times in the fields of the request body. To check the result of the request, poll /mssql/request/{id}.",
        "operationId": "createOnDemandMssqlBatchBackupV1",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MssqlBatchBackupJobConfig"
              }
            }
          },
          "description": "Configuration for the on-demand backups.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Returns the async request for the initiated on-demand backups."
          }
        },
        "summary": "Take an on-demand backup of multiple Microsoft SQL databases",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/bulk/snapshot/{id}": {
      "get": {
        "description": "Returns the details for an on-demand backup of multiple Microsoft SQL databases. This only returns details for requests that have finished successfully. To check the status of the request, poll /mssql/request/{id}.",
        "operationId": "getOnDemandMssqlBatchBackupResultV1",
        "parameters": [
          {
            "description": "ID of the on-demand backup request.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlBatchBackupSummary"
                }
              }
            },
            "description": "Result of the on-demand backup request."
          }
        },
        "summary": "Returns details for an on-demand backup of multiple Microsoft SQL databases",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/count": {
      "get": {
        "description": "Returns a count of Microsoft SQL databases.",
        "operationId": "countMssqlDbV1",
        "parameters": [
          {
            "description": "Include only instances that belong to this root.",
            "in": "query",
            "name": "root_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProtectedObjectsCount"
                }
              }
            },
            "description": "Returned if the query was successful."
          }
        },
        "summary": "Returns a count of Microsoft SQL databases",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/defaults": {
      "get": {
        "description": "The default properties are Log Backup Frequency (in seconds), Log Retention Time (in hours) and CBT status. New databases added to the Rubrik cluster are provided the log backup frequency value and log backup retention value by default. New hosts added to the Rubrik cluster are provided the CBT status by default.",
        "operationId": "getDefaultDbPropertiesV1",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlDbDefaults"
                }
              }
            },
            "description": "Returns the current default properties."
          }
        },
        "summary": "Returns the current default properties for Microsoft SQL databases",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      },
      "patch": {
        "description": "The default properties are Log Backup Frequency (in seconds), Log Retention Time (in hours) and CBT status. New databases added to the Rubrik cluster are provided the log backup frequency value and log backup retention value by default. New hosts added to the Rubrik cluster are provided the CBT status by default.",
        "operationId": "updateDefaultDbPropertiesV1",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MssqlDbDefaultsUpdate"
              }
            }
          },
          "description": "Updated default properties.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlDbDefaults"
                }
              }
            },
            "description": "Returns the updated default properties."
          }
        },
        "summary": "Update the default properties for Microsoft SQL databases",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/log_shipping": {
      "get": {
        "description": "Retrieves all log shipping configuration objects. Results can be filtered and sorted.",
        "operationId": "queryLogShippingConfigurations",
        "parameters": [
          {
            "description": "ID of a primary database object.",
            "in": "query",
            "name": "primary_database_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter log shipping configuration objects by performing an infix search using the name of a primary database.",
            "in": "query",
            "name": "primary_database_name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter log shipping configuration objects by performing an infix search using the name of a secondary database.",
            "in": "query",
            "name": "secondary_database_name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter log shipping configuration objects by performing an infix search using the location string value (host/instance) for a secondary database.",
            "in": "query",
            "name": "location",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter log shipping configuration objects based on the status value for the secondary database.",
            "in": "query",
            "name": "status",
            "required": false,
            "schema": {
              "enum": [
                "OK",
                "Broken",
                "Initializing",
                "Stale"
              ],
              "type": "string"
            }
          },
          {
            "description": "Limit the summary information to a specified maximum number of results.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Starting position in the list of results contained in the response. The summary information includes the specified numbered result and all higher numbered results.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Specifies an attribute used to ASCII-sort the results. Sorting by the last_applied attribute represents the timestamp as an ISO 8601-encoded string.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "secondaryDatabaseName",
                "primaryDatabaseName",
                "lastAppliedPoint",
                "location"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort order, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlLogShippingSummaryListResponse"
                }
              }
            },
            "description": "Summary list of descendant objects."
          }
        },
        "summary": "Get log shipping configurations",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql_log_shipping"
      }
    },
    "/mssql/db/log_shipping/{id}": {
      "delete": {
        "description": "Deletes the specified log shipping configuration.",
        "operationId": "deleteLogShippingConfiguration",
        "parameters": [
          {
            "description": "ID of a log shipping configuration object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Boolean value that determines whether to attempt to delete the secondary database associated with the specified log shipping configuration. The default value is false. When set to false, no attempt is made to delete the secondary database. When set to true, starts an asynchronous job to delete the secondary database.",
            "in": "query",
            "name": "delete_secondary_database",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Returns with the request ID of an async job to delete a log shipping configuration object and, if specified, a secondary database."
          }
        },
        "summary": "Delete a specified log shipping configuration",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql_log_shipping"
      },
      "get": {
        "description": "Retrieves a particular log shipping configuration with all the details of the configuration.",
        "operationId": "getLogShippingConfiguration",
        "parameters": [
          {
            "description": "ID of a log shipping configuration.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlLogShippingDetail"
                }
              }
            },
            "description": "Returned when the request for the log shipping configuration details is successful."
          }
        },
        "summary": "Get a log shipping configuration",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql_log_shipping"
      },
      "patch": {
        "description": "Updates a specified log shipping configuration.",
        "operationId": "updateLogShippingConfiguration",
        "parameters": [
          {
            "description": "ID of a log shipping configuration object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MssqlLogShippingUpdate"
              }
            }
          },
          "description": "Configuration parameters for the update operation.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Returns the request ID of an asynchronous job that updates a log shipping configuration object."
          }
        },
        "summary": "Update a specified log shipping configuration",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql_log_shipping"
      }
    },
    "/mssql/db/log_shipping/{id}/reseed": {
      "post": {
        "description": "Starts an asynchronous job to reseed a secondary database. Reseeding restores the data in the secondary database based on a log shipping configuration.",
        "operationId": "reseedSecondary",
        "parameters": [
          {
            "description": "ID of the log shipping configuration object for the specified secondary database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MssqlLogShippingReseedConfig"
              }
            }
          },
          "description": "Configuration parameters for the reseed operation.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Returns with a request ID for the async job to reseed a secondary database."
          }
        },
        "summary": "Reseed a secondary database",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql_log_shipping"
      }
    },
    "/mssql/db/mount": {
      "get": {
        "description": "Returns a list with summary information for all Live Mount SQL Server databases.",
        "operationId": "queryMssqlMount",
        "parameters": [
          {
            "description": "Filters by the ID of the source SQL Server database.",
            "in": "query",
            "name": "source_database_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filters by the name of the source SQL Server database using infix search.",
            "in": "query",
            "name": "source_database_name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filters by the ID of the target SQL Server instance.",
            "in": "query",
            "name": "target_instance_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filters by the name of the mounted SQL Server database using infix search.",
            "in": "query",
            "name": "mounted_database_name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Specifies the SQL Server Live Mount attribute to use in sorting the summary information. Performs an ASCII sort using the specified attribute, in the order specified by sort_order.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "sourceDatabaseName",
                "sourceRecoveryPoint",
                "mountedDatabaseName",
                "creationDate"
              ],
              "type": "string"
            }
          },
          {
            "description": "Specifies the sort order, either ascending or descending. Default order is ascending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          {
            "description": "Returns the portion of the ordered list that starts after the element specified by the offset number.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Sets the maximum number of a elements to include in the data array of the response.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlMountSummaryListResponse"
                }
              }
            },
            "description": "Returns summary information for all Live Mounts."
          }
        },
        "summary": "Get summary information for all Live Mounts SQL Server databases",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql_mount"
      }
    },
    "/mssql/db/mount/{id}": {
      "delete": {
        "description": "Create an async request to delete a Live Mount of a SQL Server database. Poll the task status by using /mssql/request/{id}.",
        "operationId": "createMssqlUnmount",
        "parameters": [
          {
            "description": "ID of the Live Mount to delete.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Remove all data within the Rubrik cluster related to the Live Mount, even if the SQL Server database cannot be contacted. Default value is false.",
            "in": "query",
            "name": "force",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Returns the task object for the async request to delete the Live Mount of a SQL Server database."
          }
        },
        "summary": "Delete a Live Mount of a SQL Server database",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql_mount"
      },
      "get": {
        "description": "Returns detailed information for the specified Live Mount of a SQL Server database.",
        "operationId": "getMssqlMount",
        "parameters": [
          {
            "description": "ID of the Live Mount to fetch.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlMountDetail"
                }
              }
            },
            "description": "Returns detailed information for a specified Live Mount of a SQL Server database."
          }
        },
        "summary": "Get detailed information for a Live Mount of a SQL Server database",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql_mount"
      }
    },
    "/mssql/db/recoverable_range/download/{id}": {
      "get": {
        "description": "Get the details of the progress made in deleting recoverable ranges. The recoverable ranges to delete are those specified by the DELETE request to /mssql/db/{id}/recoverable_range/download which yielded the response with the job id.",
        "operationId": "getDeleteMssqlDbRecoverableRangesStatusV1",
        "parameters": [
          {
            "description": "Job ID of the deletion for which to check progress.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalJobInstanceDetail"
                }
              }
            },
            "description": "Returns the progress made in deleting the recoverable ranges."
          }
        },
        "summary": "Get the deletion status of downloaded recoverable ranges",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/snapshot/{id}": {
      "get": {
        "description": "Returns detailed information about a Microsoft SQL database snapshot.",
        "operationId": "getMssqlDbSnapshot",
        "parameters": [
          {
            "description": "ID of the snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlDbSnapshotDetail"
                }
              }
            },
            "description": "Returns details about a Microsoft SQL database snapshot."
          }
        },
        "summary": "Get details information about a Microsoft SQL database snapshot",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/{id}": {
      "get": {
        "description": "Returns a detailed view of a Microsoft SQL database.",
        "operationId": "getMssqlDb",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL database to fetch.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlDbDetail"
                }
              }
            },
            "description": "Returned if the query was successful."
          }
        },
        "summary": "Get detailed information for a Microsoft SQL database",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      },
      "patch": {
        "description": "Update a Microsoft SQL database with the specified properties.",
        "operationId": "updateMssqlDb",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL database to update.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MssqlDbUpdate"
              }
            }
          },
          "description": "Properties to update.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlDbDetail"
                }
              }
            },
            "description": "Returned if the update was successful."
          }
        },
        "summary": "Update a Microsoft SQL database",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/{id}/browse": {
      "post": {
        "description": "When a recovery point is set, this API endpoint returns the snapshot and list of logs needed to restore the database to the recovery point. When a time range or LSN range is specified, this API endpoint returns the snapshots and logs that overlap the specified range.\nSpecify only a recovery point or a range. Specify only LSNs or times.\nThis endpoint is only used to fetch data, but uses POST instead of GET due to limitations on parameters used in the body of a GET request. The parameter set for this endpoint is shared with the download_file endpoint.\n",
        "operationId": "browseMssqlBackupFiles",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MssqlBackupSelection"
              }
            }
          },
          "description": "Configuration for the browse request.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlBackups"
                }
              }
            },
            "description": "List of backups requested."
          }
        },
        "summary": "List snapshots and logs from a Microsoft SQL database",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/{id}/compatible_instance": {
      "get": {
        "description": "Returns all compatible instances for export for the specified recovery time.",
        "operationId": "getCompatibleMssqlInstancesV1",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Time, in ISO8601 format, to recover to. For example \"2016-01-01T01:23:45.678Z\". If this is not specified, the latest recoverable time is used.",
            "in": "query",
            "name": "recovery_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "Recovery type.",
            "in": "query",
            "name": "recovery_type",
            "required": true,
            "schema": {
              "enum": [
                "Mount",
                "Export",
                "Restore"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlInstanceSummaryListResponse"
                }
              }
            },
            "description": "Returns summary information for all compatible Microsoft SQL instances for export."
          }
        },
        "summary": "Get compatible instances for the recovery of a Microsoft SQL database",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/{id}/download": {
      "post": {
        "description": "Starts an asynchronous request to download snapshots and logs from archival for a given database and recovery point.\nIf the specified point in time is already available locally, this endpoint throws an error.\n",
        "operationId": "downloadFromArchive",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MssqlDownloadFromArchiveConfig"
              }
            }
          },
          "description": "Configuration for the archive download request.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the download request."
          }
        },
        "summary": "Download snapshots and log backups from archival",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/{id}/download_files": {
      "post": {
        "description": "Starts an asynchronous request to download a set of backup files as a single compressed zipfile.\nWhen a recovery point is set, this API endpoint returns the snapshot and list of logs that Rubrik CDM would use to restore the database to the recovery point. When a time range or LSN range is specified, this API endpoint returns the snapshots and logs that overlap the specified range.\nSpecify only a point in time or a range. Specify only LSNs or times.\n",
        "operationId": "createDownloadMssqlBackupFiles",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MssqlBackupSelection"
              }
            }
          },
          "description": "Configuration for a download files job.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the download request."
          }
        },
        "summary": "Download snapshots and logs backups from a Microsoft SQL Database",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/{id}/download_files_by_id": {
      "post": {
        "description": "Downloads a list of snapshot and log backups from a Microsoft SQL database.",
        "operationId": "createDownloadMssqlBackupFilesById",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DownloadMssqlBackupFilesByIdJobConfig"
              }
            }
          },
          "description": "Configuration for a download files by id job.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the download request."
          }
        },
        "summary": "Downloads a list of snapshot and log backups from a Microsoft SQL database",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/{id}/export": {
      "post": {
        "description": "Create a request to export a Microsoft SQL database. To check the result of the request, poll /mssql/request/{id}.",
        "operationId": "createExportMssqlDb",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExportMssqlDbJobConfig"
              }
            }
          },
          "description": "Configuration for the export.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Returns the async request for the initiated export."
          }
        },
        "summary": "Export a Microsoft SQL database to a new location",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/{id}/log_backup": {
      "post": {
        "description": "Take an on-demand log backup for a Microsoft SQL database.",
        "operationId": "createOnDemandMssqlLogBackup",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Returns the async request for the initiated on-demand log backup."
          }
        },
        "summary": "Take an on-demand log backup for a Microsoft SQL database",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/{id}/log_shipping": {
      "post": {
        "description": "Create a log shipping configuration between a specified primary database and a specified secondary database. The transaction logs from the primary database are regularly restored to the secondary database in order to maintain the secondary database as a point-in-time copy of the primary database. The primary database must have log backups configured, and it must be in the full or bulk-logged recovery model.",
        "operationId": "createLogShippingConfiguration",
        "parameters": [
          {
            "description": "ID of the primary database object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MssqlLogShippingCreateConfig"
              }
            }
          },
          "description": "Object containing the values of a log shipping configuration.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Returned when the specified log shipping configuration is successfully applied."
          }
        },
        "summary": "Create a log shipping configuration",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql_log_shipping"
      }
    },
    "/mssql/db/{id}/missed_recoverable_range": {
      "get": {
        "description": "Retrieve a list of missed recoverable ranges for a Microsoft SQL database. For each run of one type of error, the first and last occurrence of the error are given.",
        "operationId": "getMssqlDbMissedRecoverableRanges",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter the missed ranges to end after this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\".",
            "in": "query",
            "name": "after_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "Filter the missed ranges to start before this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\".",
            "in": "query",
            "name": "before_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlMissedRecoverableRangeListResponse"
                }
              }
            },
            "description": "Returns the missed recoverable ranges for the Microsoft SQL database."
          }
        },
        "summary": "Get missed recoverable ranges of a Microsoft SQL database",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/{id}/missed_snapshot": {
      "get": {
        "description": "Returns a list of summary information for the missed snapshots of a Microsoft SQL database, including the time of day and the locations where the snapshot was missed.",
        "operationId": "getMissedMssqlDbSnapshots",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter snapshots to those missed on or after this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\".",
            "in": "query",
            "name": "after_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "Filter snapshots to those missed on or before this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\".",
            "in": "query",
            "name": "before_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MissedSnapshotListResponse"
                }
              }
            },
            "description": "Returns details about the missed snapshots."
          }
        },
        "summary": "Get summary information for missed snapshots of a SQL database",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/{id}/mount": {
      "post": {
        "description": "Create an asynchronous request to create a Live Mount SQL Server database. Poll the task status by using /mssql/request/{id}.",
        "operationId": "createMssqlMount",
        "parameters": [
          {
            "description": "ID of the SQL Server database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MountMssqlDbConfig"
              }
            }
          },
          "description": "Configuration for the Live Mount.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Returns the asynchronous task object for the Live Mount request."
          }
        },
        "summary": "Live Mount SQL Server database from a point in time copy",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql_mount"
      }
    },
    "/mssql/db/{id}/recoverable_range": {
      "get": {
        "description": "Retrieve the recoverable ranges for a specified Microsoft SQL database. A begin and/or end timestamp can be provided to retrieve only the ranges that fall within the window.",
        "operationId": "getMssqlDbRecoverableRanges",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter ranges to end after this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678Z\".",
            "in": "query",
            "name": "after_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "Filter ranges to start before this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\".",
            "in": "query",
            "name": "before_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlRecoverableRangeListResponse"
                }
              }
            },
            "description": "Returns the recoverable ranges for the Microsoft SQL database."
          }
        },
        "summary": "Get recoverable ranges of a Microsoft SQL database",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/{id}/recoverable_range/download": {
      "delete": {
        "description": "Deletes all local snapshots and logs that have previously been downloaded. Provide a begin or end time to delete only the downloaded snapshots and logs that fall within this time frame. The time is relative to when the snapshot or log backup was originally taken, not downloaded. Parts of the window may not be deleted if certain log files must be kept to preserve times outside the window. Data is deleted in the background. To check the status of the deletion, poll /mssql/db/recoverable_range/download/{id}.",
        "operationId": "deleteDownloadedMssqlDbRecoverableRangesV1",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Delete only the downloaded snapshots and logs taken after this time. The date-time string should be in ISO8601 format. For example, \"2016-01-01T01:23:45.678\".",
            "in": "query",
            "name": "after_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "Delete only the downloaded snapshots and logs taken before this time. The date-time string should be in ISO8601 format. For example, \"2016-01-01T01:23:45.678\".",
            "in": "query",
            "name": "before_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobScheduledResponse"
                }
              }
            },
            "description": "Returns the job ID to check the progress of deleting the downloaded snapshots and logs."
          }
        },
        "summary": "Delete downloaded recoverable ranges of a Microsoft SQL database",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/{id}/restore": {
      "post": {
        "description": "Create a request to restore a SQL Server database. To check the result of the request, poll /mssql/request/{id}.",
        "operationId": "createRestoreMssqlDb",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RestoreMssqlDbJobConfig"
              }
            }
          },
          "description": "Restore configuration.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Returns the async request for the initiated restore."
          }
        },
        "summary": "Restore a Microsoft SQL database",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/{id}/restore_estimate": {
      "get": {
        "description": "Provides an estimate of resources needed for the specified restore or export operation.",
        "operationId": "mssqlRestoreEstimateV1",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Time, in ISO8601 date-time format, to recover to. For example, \"2016-01-01T01:23:45.678\". This value or the LSN are required.",
            "in": "query",
            "name": "time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "LSN to recover to. This value or the LSN are required.",
            "in": "query",
            "name": "lsn",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Recovery fork GUID of LSN to recover to. Meaningful only when lsn is specified.",
            "in": "query",
            "name": "recovery_fork_guid",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlRestoreEstimateResult"
                }
              }
            },
            "description": "Returns the esimate for a restore or export to the specified recovery point."
          }
        },
        "summary": "Returns a size estimate for a restore or export",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/{id}/restore_files": {
      "get": {
        "description": "Provides a list of database files to be restored for the specified restore or export operation.",
        "operationId": "mssqlGetRestoreFilesV1",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Time, in ISO8601 date-time format, to recover to. For example, \"2016-01-01T01:23:45.678\". This value or the LSN are required.",
            "in": "query",
            "name": "time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "LSN to recover to. This value or the time are required.",
            "in": "query",
            "name": "lsn",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Recovery fork GUID of LSN to recover to. Meaningful only when lsn is specified.",
            "in": "query",
            "name": "recovery_fork_guid",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/MssqlRestoreFile"
                  },
                  "type": "array"
                }
              }
            },
            "description": "Database files to be restored."
          }
        },
        "summary": "Returns a list all database files to be restored",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/{id}/snappable_id": {
      "get": {
        "description": "Returns the snappableId for a Microsoft SQL database.",
        "operationId": "mssqlGetSnappableIdV1",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlSnappableId"
                }
              }
            },
            "description": "Returns the snappableId."
          }
        },
        "summary": "Returns the snappableId for a Microsoft SQL database",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/db/{id}/snapshot": {
      "delete": {
        "description": "Deletes all snapshots of a Microsoft SQL database. The database must be unprotected for the operation to succeed.",
        "operationId": "deleteMssqlDbSnapshots",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Returned if all snapshots for the Microsoft SQL database were successfully removed."
          }
        },
        "summary": "Delete all snapshots of a Microsoft SQL database",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      },
      "get": {
        "description": "Returns a list of summary information for snapshots of a Microsoft SQL database.",
        "operationId": "queryMssqlDbSnapshot",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter snapshots to those taken on or after this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\".",
            "in": "query",
            "name": "after_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "Filter snapshots to those taken before or on this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\".",
            "in": "query",
            "name": "before_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlDbSnapshotSummaryListResponse"
                }
              }
            },
            "description": "Returns summary information for snapshots."
          }
        },
        "summary": "Get summary information for snapshots of a Microsoft SQL database",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      },
      "post": {
        "description": "Take an on-demand backup of a Microsoft SQL database. The forceFullSnapshot property can be set to true to force a full snapshot. To check the result of the request, poll /mssql/request/{id}.",
        "operationId": "createOnDemandMssqlBackup",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MssqlBackupJobConfig"
              }
            }
          },
          "description": "Configuration for the on-demand backup.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Returns the async request for the initiated on-demand backup."
          }
        },
        "summary": "Take an on-demand backup of a Microsoft SQL database",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/hierarchy/{id}": {
      "get": {
        "description": "Retrieve details for the specified object in the SQL Server hierarchy.\n",
        "operationId": "getMssqlHierarchyObject",
        "parameters": [
          {
            "description": "ID of the SQL Server hierarchy object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlHierarchyObjectSummary"
                }
              }
            },
            "description": "Details of the hierarchy object."
          }
        },
        "summary": "Get summary of a SQL Server hierarchy object",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/hierarchy/{id}/children": {
      "get": {
        "description": "Retrieve the list of immediate descendant objects for the specified parent.",
        "operationId": "getMssqlHierarchyChildren",
        "parameters": [
          {
            "description": "ID of the parent SQL Server hierarchy object. To get top-level nodes, use **root** as the ID.\n",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by the ID of the effective SLA Domain.",
            "in": "query",
            "name": "effective_sla_domain_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by a comma-separated list of node object types.\n",
            "explode": false,
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "items": {
                "enum": [
                  "Host",
                  "MssqlInstance",
                  "MssqlDatabase",
                  "WindowsCluster",
                  "MssqlAvailabilityGroup"
                ],
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          },
          {
            "description": "Filter by primary cluster ID, or **local**.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limit the number of matches returned.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "An integer that specifies the number of initial matches to ignore.\n",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Filter children by provided name.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by the value of the `isRelic` field for nodes with object type MssqlDatabase.",
            "in": "query",
            "name": "is_relic",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Filter database by the value of the `isLiveMount` field for nodes with object type MssqlDatabase.",
            "in": "query",
            "name": "is_live_mount",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Filter by the value of the `isLogShippingSecondary` field for nodes with object type MssqlDatabase.",
            "in": "query",
            "name": "is_log_shipping_secondary",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Filter by the value of the `isClustered` field for nodes with object type MssqlDatabase or MssqlInstance.",
            "in": "query",
            "name": "is_clustered",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Boolean that filters top-level nodes with the Host or WindowsCluster object type by whether or not the nodes have children MssqlInstance nodes. When this value is 'true,' the filter shows only nodes with children MssqlInstance nodes. When this value is 'false,' the filter shows only nodes without children MssqlInstance nodes.",
            "in": "query",
            "name": "has_instances",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Filter by SLA assignment type.",
            "in": "query",
            "name": "sla_assignment",
            "required": false,
            "schema": {
              "enum": [
                "Derived",
                "Direct",
                "Unassigned"
              ],
              "type": "string"
            }
          },
          {
            "description": "Attribute to sort the results on.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "name",
                "descendantCount.MssqlInstance",
                "descendantCount.MssqlDatabase",
                "logBackupRetentionHours",
                "copyOnly",
                "effectiveSlaDomainName"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort order, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          {
            "description": "Determines whether SQL Server instances are fetched with additional privilege checks.",
            "in": "query",
            "name": "snappable_status",
            "required": false,
            "schema": {
              "enum": [
                "Protectable"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlHierarchyObjectSummaryListResponse"
                }
              }
            },
            "description": "Summary list of children objects."
          }
        },
        "summary": "Get list of immediate descendant objects",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/hierarchy/{id}/descendants": {
      "get": {
        "description": "Retrieve the list of descendant objects for the specified parent.",
        "operationId": "getMssqlHierarchyDescendants",
        "parameters": [
          {
            "description": "ID of the parent SQL server hierarchy object. To get top-level nodes, use **root** as the ID.\n",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by the ID of the effective SLA Domain.",
            "in": "query",
            "name": "effective_sla_domain_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by a comma-separated list of node object types.\n",
            "explode": false,
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "items": {
                "enum": [
                  "Host",
                  "MssqlInstance",
                  "MssqlDatabase",
                  "WindowsCluster",
                  "MssqlAvailabilityGroup"
                ],
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          },
          {
            "description": "Filter by primary cluster ID, or **local**.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limit the number of matches returned.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "An integer that specifies the number of initial matches to ignore.\n",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Filter descendants by provided name.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by the value of the `isRelic` field for nodes with MssqlDatabase as the value of the object type field.",
            "in": "query",
            "name": "is_relic",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Filter database by the value of the `isLiveMount` field for nodes with MssqlDatabase as the value of the object type field.",
            "in": "query",
            "name": "is_live_mount",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Filter by the value of the `isLogShippingSecondary` field for nodes with MssqlDatabase as the value of the object type field.",
            "in": "query",
            "name": "is_log_shipping_secondary",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Filter by the value of the `isClustered` field for nodes with object type MssqlDatabase or MssqlInstance.",
            "in": "query",
            "name": "is_clustered",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Boolean that filters top-level nodes with the Host or WindowsCluster object type by whether or not the nodes have children MssqlInstance nodes. When this value is 'true,' the filter shows only nodes with children MssqlInstance nodes. When this value is 'false,' the filter shows only nodes without children MssqlInstance nodes.",
            "in": "query",
            "name": "has_instances",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Filter by SLA Domain assignment type.",
            "in": "query",
            "name": "sla_assignment",
            "required": false,
            "schema": {
              "enum": [
                "Derived",
                "Direct",
                "Unassigned"
              ],
              "type": "string"
            }
          },
          {
            "description": "Attribute to sort the results on.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "name",
                "descendantCount.MssqlInstance",
                "descendantCount.MssqlDatabase",
                "logBackupRetentionHours",
                "copyOnly",
                "effectiveSlaDomainName"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort order, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          {
            "description": "Determines whether SQL Server instances are fetched with additional privilege checks.",
            "in": "query",
            "name": "snappable_status",
            "required": false,
            "schema": {
              "enum": [
                "Protectable"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlHierarchyObjectSummaryListResponse"
                }
              }
            },
            "description": "Summary list of descendant objects."
          }
        },
        "summary": "Get list of descendant objects",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/host/configuration": {
      "get": {
        "description": "Returns a list of customized SQL Server host configurations.",
        "operationId": "queryMssqlHostConfig",
        "parameters": [
          {
            "description": "IDs of the hosts.",
            "explode": false,
            "in": "query",
            "name": "host_id",
            "required": false,
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlHostConfigurationWithHostIdListResponse"
                }
              }
            },
            "description": "Summary of SQL Server host configurations."
          }
        },
        "summary": "Get the summary of SQL Server host configurations",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      },
      "post": {
        "description": "Creates a SQL Server host configuration.",
        "operationId": "createMssqlHostConfig",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MssqlHostConfigurationWithHostId"
              }
            }
          },
          "description": "Parameters for creating a SQL Server host configuration.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlHostConfiguration"
                }
              }
            },
            "description": "Details of the new SQL Server host configuration."
          }
        },
        "summary": "Create a SQL Server host configuration",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/host/configuration/{host_id}": {
      "delete": {
        "description": "Deletes the SQL Server host configuration. The host falls back to use values from the global configuration.",
        "operationId": "deleteMssqlHostConfig",
        "parameters": [
          {
            "description": "ID of the host.",
            "in": "path",
            "name": "host_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "SQL Server host configuration deleted successfully."
          }
        },
        "summary": "Delete the SQL Server host configuration",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      },
      "get": {
        "description": "Returns the configuration for the specified SQL Server host.",
        "operationId": "getMssqlHostConfig",
        "parameters": [
          {
            "description": "ID of the host.",
            "in": "path",
            "name": "host_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlHostConfiguration"
                }
              }
            },
            "description": "Configuration details of the specified SQL Server host."
          }
        },
        "summary": "Get the configuration for a specific host",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      },
      "patch": {
        "description": "Updates the configuration for a specified host.",
        "operationId": "updateMssqlHostConfig",
        "parameters": [
          {
            "description": "ID of the SQL Server host to update the host configuration.",
            "in": "path",
            "name": "host_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MssqlHostConfiguration"
              }
            }
          },
          "description": "SQL Server host configuration properties to update.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlHostConfiguration"
                }
              }
            },
            "description": "Details of the updated SQL Server host configuration."
          }
        },
        "summary": "Update host configuration",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/instance": {
      "get": {
        "description": "Returns a list of summary information for Microsoft SQL instances.",
        "operationId": "queryMssqlInstance",
        "parameters": [
          {
            "description": "Include only instances that belong to this root.",
            "in": "query",
            "name": "root_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limits the instances returned within one cluster specified by primary_cluster_id.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Determines whether SQL Server instances are fetched with additional privilege checks.",
            "in": "query",
            "name": "snappable_status",
            "required": false,
            "schema": {
              "enum": [
                "Protectable"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlInstanceSummaryListResponse"
                }
              }
            },
            "description": "Returned if the query was successful."
          }
        },
        "summary": "Get summary information for Microsoft SQL instances",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/instance/count": {
      "get": {
        "description": "Returns a count of all Microsoft SQL instances.",
        "operationId": "countMssqlInstanceV1",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CountResponse"
                }
              }
            },
            "description": "Returned if the query was successful."
          }
        },
        "summary": "Returns a count of Microsoft SQL instances",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/instance/{id}": {
      "get": {
        "description": "Returns a detailed view of a Microsoft SQL instance.",
        "operationId": "getMssqlInstance",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL instance.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlInstanceDetail"
                }
              }
            },
            "description": "Returned if the query was successful."
          }
        },
        "summary": "Get detailed information for a Microsoft SQL instance",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      },
      "patch": {
        "description": "Update a Microsoft SQL instance with specified properties.",
        "operationId": "updateMssqlInstance",
        "parameters": [
          {
            "description": "ID of the Microsoft SQL instance.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MssqlInstanceUpdate"
              }
            }
          },
          "description": "Properties to update.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MssqlInstanceDetail"
                }
              }
            },
            "description": "Returned if the update was successful."
          }
        },
        "summary": "Update a Microsoft SQL instance",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/request/{id}": {
      "get": {
        "description": "Returns the task object for an async request related to SQL Server databases.",
        "operationId": "getMssqlAsyncRequestStatus",
        "parameters": [
          {
            "description": "ID of the async request.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the async request."
          }
        },
        "summary": "Get details for an async request",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/mssql/sla_domain/assign": {
      "post": {
        "description": "Assigns SLA Domain properties to SQL Server objects. Hosts and Windows clusters cannot be assigned SLA Domains directly. The SLA Domains are instead applied to the SQL Server child objects within the Host or Windows Cluster object. Newly discovered SQL Server objects within a given Host or Windows Cluster object do not inherit SLA Domain properties from other child SQL Server objects with the same parent object.\n",
        "operationId": "assignMssqlSlaProperties",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MssqlSlaDomainAssignInfo"
              }
            }
          },
          "description": "Update information.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "Successfully assigned SLA Domain properties."
          }
        },
        "summary": "Assign SLA properties to SQL Server objects",
        "tags": [
          "/mssql"
        ],
        "x-group": "mssql"
      }
    },
    "/oracle/aco_example_download_link": {
      "get": {
        "description": "Link to download the Advanced Recovery Options example file which can be used to customize Oracle recoveries.",
        "operationId": "getExampleAcoDownloadLink",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OracleFileDownloadLink"
                }
              }
            },
            "description": "Link to download the example Advanced Recovery Options file."
          }
        },
        "summary": "Link to download the Advanced Recovery Options example file",
        "tags": [
          "/oracle"
        ],
        "x-group": "oracle_db"
      }
    },
    "/oracle/aco_parameter_list": {
      "get": {
        "description": "Get the list of supported Advanced Cloning Options (ACO) parameters.",
        "operationId": "getAcoParameterList",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OracleAcoParameterList"
                }
              }
            },
            "description": "List of supported Advanced Cloning Options (ACO) parameters."
          }
        },
        "summary": "List of supported Advanced Cloning Options",
        "tags": [
          "/oracle"
        ],
        "x-group": "oracle_db"
      }
    },
    "/oracle/data_guard_group/{id}": {
      "patch": {
        "description": "Update properties of an Oracle Data Guard group object.",
        "operationId": "updateOracleDataGuardGroup",
        "parameters": [
          {
            "description": "ID assigned to an Oracle Data Guard group object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OracleDataGuardGroupUpdate"
              }
            }
          },
          "description": "Properties to use for the update of an Oracle Data Guard group object.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OracleDbDetail"
                }
              }
            },
            "description": "Successfully updated the Oracle Data Guard group object."
          }
        },
        "summary": "Update an Oracle Data Guard group",
        "tags": [
          "/oracle"
        ],
        "x-group": "oracle_data_guard_group"
      }
    },
    "/oracle/db": {
      "get": {
        "description": "Retrieves an array containing summary information about the Oracle database objects in the Rubrik cluster.",
        "operationId": "queryOracleDbV1",
        "parameters": [
          {
            "description": "Filters a response by making an infix comparison of the database name, SID, and tablespaces in the response with the specified value.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limits the response to Oracle databases that are protected by the specified type of SLA Domain assignment.",
            "in": "query",
            "name": "sla_assignment",
            "required": false,
            "schema": {
              "enum": [
                "Derived",
                "Direct",
                "Unassigned"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filters by effective SLA Domain ID.",
            "in": "query",
            "name": "effective_sla_domain_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limits the response to Oracle databases that have the specified primary cluster value.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limits the response to Oracle databases that have the specified isRelic value.",
            "in": "query",
            "name": "is_relic",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Limits the response to Oracle databases that have the specified isLiveMount value.",
            "in": "query",
            "name": "is_live_mount",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Limits the summary information to the specified number of matches. Optionally, it can be used with offset to begin the count of matches at the number specified in the offset parameter, and with sort_by to sort the results by the specified attribute.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Determines the elements to include in the response starting with the element at the index number specified here. Optionally used with limit to enable paging of the results by retrieving a smaller number of elements in the response.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Specifies a comma-separated list of attributes to use in sorting the matches. Performs an ASCII sort of the values in the response using each specified attribute, in the order specified.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "effectiveSlaDomainName",
                "name"
              ],
              "type": "string"
            }
          },
          {
            "description": "Specifies the ascending or descending order to sort the elements in the response by the attributes specified in the sort_by parameter.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          {
            "description": "Specifies whether to include the backup task information in the response.",
            "in": "query",
            "name": "include_backup_task_info",
            "required": false,
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "Limits the response to Oracle databases that have the specified value for the isDataGuardGroup flag.",
            "in": "query",
            "name": "is_data_guard_group",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OracleDbSummaryListResponse"
                }
              }
            },
            "description": "Summary of Oracle databases."
          }
        },
        "summary": "Get summary information for Oracle databases",
        "tags": [
          "/oracle"
        ],
        "x-group": "oracle_db"
      }
    },
    "/oracle/db/bulk": {
      "patch": {
        "description": "Update the properties of the objects that represent the specified Oracle Databases.",
        "operationId": "bulkUpdateOracleDb",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OracleBulkUpdate"
              }
            }
          },
          "description": "Properties to use for the update of Oracle Database objects.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkOracleDbDetails"
                }
              }
            },
            "description": "Successfully updated Oracle Database objects."
          }
        },
        "summary": "Update Oracle Databases",
        "tags": [
          "/oracle"
        ],
        "x-group": "oracle_db"
      }
    },
    "/oracle/db/{id}": {
      "get": {
        "description": "Retrieves detailed information for a specified Oracle database object.",
        "operationId": "getOracleDbV1",
        "parameters": [
          {
            "description": "ID of an Oracle database object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OracleDbDetail"
                }
              }
            },
            "description": "Detailed information for the specified Oracle database."
          }
        },
        "summary": "Get Oracle database information",
        "tags": [
          "/oracle"
        ],
        "x-group": "oracle_db"
      },
      "patch": {
        "description": "Updates the properties of a specified Oracle database object.",
        "operationId": "updateOracleDbV1",
        "parameters": [
          {
            "description": "ID of an Oracle database object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OracleUpdate"
              }
            }
          },
          "description": "Properties of the Oracle database object to be updated. object.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OracleDbDetail"
                }
              }
            },
            "description": "Detailed information for the updated Oracle database."
          }
        },
        "summary": "Update an Oracle database",
        "tags": [
          "/oracle"
        ],
        "x-group": "oracle_db"
      }
    },
    "/oracle/db/{id}/downloaded_snapshots": {
      "delete": {
        "description": "Requests an asynchronous job to expire downloaded database snapshots taken during a specified time period as well as log snapshots that contain any logs with timestamps within that time period.",
        "operationId": "deleteDownloadedSnapshots",
        "parameters": [
          {
            "description": "ID of the Oracle database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Uses the ISO 8601 format to specify the start of the time period used by the asynchronous snapshot expiration job, as in the example \"2016-01-01T01:23:45.678\".",
            "in": "query",
            "name": "after_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "Uses the ISO 8601 format to specify the end of the time period used by the asynchronous snapshot expiration job, as in the example \"2016-01-01T01:23:45.678\".",
            "in": "query",
            "name": "before_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "The request status of the asynchronous job that deletes downloaded Oracle database snapshots and log snapshots."
          }
        },
        "summary": "Delete downloaded Oracle database snapshots and log snapshots",
        "tags": [
          "/oracle"
        ],
        "x-group": "oracle_db"
      }
    },
    "/oracle/db/{id}/restore_estimate": {
      "get": {
        "description": "The estimated size of the data to download from an archival location in order to perform a specified restore or export operation.",
        "operationId": "oracleRestoreEstimate",
        "parameters": [
          {
            "description": "ID of the Oracle database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "ID of the snapshot to recover to.",
            "in": "query",
            "name": "snapshot_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The date and time for the recovery restore point, specified in the ISO 8601 format, as in the example \"2016-01-01T01:23:45.678\".",
            "in": "query",
            "name": "recovery_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OracleRestoreEstimateResult"
                }
              }
            },
            "description": "Returns the estimate for a restore or export to the specified recovery point."
          }
        },
        "summary": "Get a size estimate for a restore or export",
        "tags": [
          "/oracle"
        ],
        "x-group": "oracle_db"
      }
    },
    "/oracle/db/{id}/validate": {
      "post": {
        "description": "Queue a job to validate Oracle backups for a database snapshot or a specified timestamp.",
        "operationId": "createOracleValidateBackupJob",
        "parameters": [
          {
            "description": "ID of the database to be validated.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OracleValidateConfig"
              }
            }
          },
          "description": "Configuration parameters for a job to validate an Oracle backups.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Request status for the queued job to validate Oracle backups for a specified timestamp."
          }
        },
        "summary": "Validate Oracle database backups",
        "tags": [
          "/oracle"
        ],
        "x-group": "oracle_db"
      }
    },
    "/oracle/host/bulk": {
      "patch": {
        "description": "Update properties to Oracle Host objects.",
        "operationId": "bulkUpdateOracleHost",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OracleBulkUpdate"
              }
            }
          },
          "description": "Properties to use for the update of Oracle Host objects.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkOracleHostDetails"
                }
              }
            },
            "description": "Successfully updated Oracle Host objects."
          }
        },
        "summary": "Update Oracle Hosts",
        "tags": [
          "/oracle"
        ],
        "x-group": "oracle_host"
      }
    },
    "/oracle/rac/bulk": {
      "patch": {
        "description": "Update the properties of the objects that represent the specified Oracle RAC.",
        "operationId": "bulkUpdateOracleRac",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OracleBulkUpdate"
              }
            }
          },
          "description": "Properties to use for the update of Oracle RAC objects.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkOracleRacDetails"
                }
              }
            },
            "description": "Successfully updated Oracle RAC objects."
          }
        },
        "summary": "Update Oracle RACs",
        "tags": [
          "/oracle"
        ],
        "x-group": "oracle_rac"
      }
    },
    "/oracle/validate_aco_file": {
      "post": {
        "description": "Validate the provided Oracle ACO (Advanced Cloning Options) file.",
        "operationId": "validateOracleAcoFile",
        "parameters": [
          {
            "description": "Boolean that determines whether the ACO file is being used for a Live Mount.",
            "in": "query",
            "name": "is_live_mount",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "string"
              }
            }
          },
          "description": "Contents of the Advanced Cloning Options file in base64 encoded format.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OracleAcoValidationResult"
                }
              }
            },
            "description": "Validation result of the provided ACO file."
          }
        },
        "summary": "Validate Oracle ACO file",
        "tags": [
          "/oracle"
        ],
        "x-group": "oracle_db"
      }
    },
    "/organization/{id}/envoy/bulk": {
      "delete": {
        "description": "Remove a list of Rubrik Envoy objects from an organization and delete the objects from the Rubrik cluster.",
        "operationId": "bulkDeleteEnvoys",
        "parameters": [
          {
            "description": "ID assigned to an organization object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EnvoyIdList"
              }
            }
          },
          "description": "A list of Rubrik Envoy objects IDs.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "Successfully deleted a list of Rubrik Envoy objects."
          }
        },
        "summary": "Remove a list of Rubrik Envoy objects",
        "tags": [
          "/organization"
        ],
        "x-group": "organization_resource"
      },
      "patch": {
        "description": "Change one or more of the properties of a list of Rubrik Envoy objects.",
        "operationId": "bulkUpdateEnvoys",
        "parameters": [
          {
            "description": "ID assigned to an organization object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/EnvoyBulkUpdate"
                },
                "type": "array"
              }
            }
          },
          "description": "Properties to assign to the Rubrik Envoy objects.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EnvoyDetailList"
                }
              }
            },
            "description": "Returns a detailed view of all updated Rubrik Envoy objects."
          }
        },
        "summary": "Update a list of Rubrik Envoy objects",
        "tags": [
          "/organization"
        ],
        "x-group": "organization_resource"
      },
      "post": {
        "description": "Create a list of Rubrik Envoy objects for a specified organization and specify the properties to assign to the Rubrik Envoy objects.",
        "operationId": "bulkCreateEnvoys",
        "parameters": [
          {
            "description": "ID assigned to an organization object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/EnvoyCreate"
                },
                "type": "array"
              }
            }
          },
          "description": "Properties to assign to the Rubrik Envoy objects.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EnvoyDetailList"
                }
              }
            },
            "description": "Returns a detailed view of all created Rubrik Envoy objects."
          }
        },
        "summary": "Create a list of Rubrik Envoy objects",
        "tags": [
          "/organization"
        ],
        "x-group": "organization_resource"
      }
    },
    "/principal": {
      "get": {
        "description": "Search for principals based on the specified parameters.",
        "operationId": "searchPrincipalsV1",
        "parameters": [
          {
            "description": "Maximum number of results to return.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Starting offset of the results to return.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Attribute by which to sort. Default is \"name\".",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "Name",
                "PrincipalType",
                "Description",
                "FirstName",
                "LastName",
                "EmailAddress",
                "DisplayName"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort order. Default order is ascending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          {
            "description": "ID of the authentication domain that contains the principal.",
            "in": "query",
            "name": "auth_domain_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "ID of the organization of which the principal is a member.",
            "in": "query",
            "name": "organization_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A Boolean that specifies whether the principal has any roles assigned or is a local user. When a principal is a local user, or when the principal has any roles assigned, this value is 'true'.\n",
            "in": "query",
            "name": "is_assigned_roles_or_is_local",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "ID of a role assigned to the principal.",
            "in": "query",
            "name": "role_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The name of the principal.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The type of principal.",
            "in": "query",
            "name": "principal_type",
            "required": false,
            "schema": {
              "enum": [
                "User",
                "Group"
              ],
              "type": "string"
            }
          },
          {
            "description": "Indicates if the principal has TOTP authentication enabled. Returns the users with TOTP authentication enabled when the value is true.\n",
            "in": "query",
            "name": "is_totp_enabled",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PrincipalSummaryV1ListResponse"
                }
              }
            },
            "description": "The list of matching principals."
          }
        },
        "summary": "Search for principals",
        "tags": [
          "/principal"
        ],
        "x-group": "principal"
      }
    },
    "/principal/role": {
      "get": {
        "description": "Get a list of role information for all roles assigned to the principals.\n",
        "operationId": "getRolesForPrincipals",
        "parameters": [
          {
            "description": "IDs of the principals.",
            "explode": false,
            "in": "query",
            "name": "principals",
            "required": true,
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/PrincipalWithRoleInfo"
                  },
                  "type": "array"
                }
              }
            },
            "description": "List of roles assigned to the principal."
          }
        },
        "summary": "Get roles assigned to principals",
        "tags": [
          "/principal"
        ],
        "x-group": "principal"
      },
      "post": {
        "description": "Assign a set of roles to the specified principals.",
        "operationId": "assignRolesToPrincipals",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RoleAssignmentRequest"
              }
            }
          },
          "description": "A set of roles and a set of principals to which the roles should be granted.\n",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/RoleInfo"
                  },
                  "type": "array"
                }
              }
            },
            "description": "Role information for roles assigned to the principal.\n"
          }
        },
        "summary": "Assign roles to principals",
        "tags": [
          "/principal"
        ],
        "x-group": "principal"
      }
    },
    "/principal/role/bulk_revoke": {
      "post": {
        "description": "Revoke a set of roles from the specified principals.\n",
        "operationId": "revokeRolesFromPrincipals",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RoleAssignmentRequest"
              }
            }
          },
          "description": "A set of roles to revoke from a set of principals.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "Successfuly revoked roles from principals."
          }
        },
        "summary": "Revoke roles from principals",
        "tags": [
          "/principal"
        ],
        "x-group": "principal"
      }
    },
    "/replication/location_pause/disable": {
      "post": {
        "description": "A single Rubrik cluster can be the replication target for multiple source Rubrik clusters. For each source cluster specified, this resumes replication from that source cluster to the target cluster. This call must be made on the target cluster.\n",
        "operationId": "disablePerLocationPause",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DisablePerLocationPause"
              }
            }
          },
          "description": "A configuration value that specifies which source clusters resume replication. Snapshots taken before or during the replication pause can be skipped.\n",
          "required": true
        },
        "responses": {
          "204": {
            "description": "Successfully resumed replication from all specified source clusters.\n"
          }
        },
        "summary": "Resume replication from specified source clusters",
        "tags": [
          "/replication"
        ],
        "x-group": "replication"
      }
    },
    "/replication/location_pause/enable": {
      "post": {
        "description": "A single Rubrik cluster can be the replication target for multiple source Rubrik clusters. For each source cluster specified, this pauses replication from that source cluster to the target cluster. This call must be made on the target cluster.\n",
        "operationId": "enablePerLocationPause",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EnablePerLocationPause"
              }
            }
          },
          "description": "A configuration value that specifies which source clusters pause replication. Replication jobs can be canceled immediately or be allowed to finish.\n",
          "required": true
        },
        "responses": {
          "204": {
            "description": "Successfully paused replication from all specified source clusters.\n"
          }
        },
        "summary": "Pause replication from specified source clusters",
        "tags": [
          "/replication"
        ],
        "x-group": "replication"
      }
    },
    "/report/compliance_summary": {
      "get": {
        "description": "Returns the compliance summary information for all protected objects based on a time-based requirement of at least one snapshot in each 24 hour report period. This view ignores the policies assigned to protected objects through SLA Domains.",
        "operationId": "getComplianceSummaryV1",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ComplianceSummaryV1"
                }
              }
            },
            "description": "Data from the report data source."
          }
        },
        "summary": "Get compliance summary information",
        "tags": [
          "/reports"
        ],
        "x-group": "reports"
      }
    },
    "/report/compliance_summary_sla": {
      "get": {
        "description": "Returns the compliance summary information for all protected objects based on whether the last expected snapshot was successful. This requirement is based on the SLA Domain assigned to the objects.",
        "operationId": "getComplianceSummarySLAV1",
        "parameters": [
          {
            "description": "An SLA Domain-based range of snapshots. Compliance is calculated for snapshots in the range.",
            "in": "query",
            "name": "snapshot_range",
            "required": true,
            "schema": {
              "enum": [
                "LastSnapshot",
                "Last2Snapshots",
                "Last3Snapshots",
                "AllSnapshots"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ComplianceSummarySLAV1"
                }
              }
            },
            "description": "Data from the report data source."
          }
        },
        "summary": "Get compliance summary information",
        "tags": [
          "/reports"
        ],
        "x-group": "reports"
      }
    },
    "/report/config": {
      "patch": {
        "description": "Set the different report config parameters.",
        "operationId": "setReportConfig",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReportConfigPatch"
              }
            }
          },
          "description": "Specifies the new report config parameters.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReportConfigResponse"
                }
              }
            },
            "description": "The new duration, in days, of the retention period for report job instances for log jobs."
          }
        },
        "summary": "Modify the report config",
        "tags": [
          "/reports"
        ],
        "x-group": "config_report"
      }
    },
    "/role": {
      "get": {
        "description": "Get a list of role information for all roles in the specified organization.\n",
        "operationId": "getRoles",
        "parameters": [
          {
            "description": "Maximum number of results to return.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Starting offset of the results to return.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Attribute used to sort the role list.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "default": "Name",
              "enum": [
                "Name",
                "Description",
                "RoleTemplate"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort order used, ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "default": "asc",
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          {
            "description": "The ID of the organization the roles are a part of. When empty, the Rubrik cluster infers the organization from the session.\n",
            "in": "query",
            "name": "organization_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The name of the role.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "List of comma-separated role templates by which to filter the roles.\n",
            "explode": false,
            "in": "query",
            "name": "role_template",
            "required": false,
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RoleInfoListResponse"
                }
              }
            },
            "description": "Information about the requested roles."
          }
        },
        "summary": "Get all roles in an organization",
        "tags": [
          "/role"
        ],
        "x-group": "role"
      },
      "post": {
        "description": "Create a new role in the current organization.",
        "operationId": "createRole",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RoleInfoCreate"
              }
            }
          },
          "description": "Information about the role.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RoleInfo"
                }
              }
            },
            "description": "Information about the newly created role."
          }
        },
        "summary": "Create a new role",
        "tags": [
          "/role"
        ],
        "x-group": "role"
      }
    },
    "/role/{id}": {
      "delete": {
        "description": "Delete the role with the specified ID.",
        "operationId": "deleteRole",
        "parameters": [
          {
            "description": "ID of the role.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully deleted role."
          }
        },
        "summary": "Delete a role",
        "tags": [
          "/role"
        ],
        "x-group": "role"
      },
      "get": {
        "description": "Get role information for the role with the specified ID.",
        "operationId": "getRole",
        "parameters": [
          {
            "description": "ID of the role.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RoleInfo"
                }
              }
            },
            "description": "Information about the role."
          }
        },
        "summary": "Get role information for the specified role",
        "tags": [
          "/role"
        ],
        "x-group": "role"
      },
      "patch": {
        "description": "Update the role information for the specified role.",
        "operationId": "updateRole",
        "parameters": [
          {
            "description": "ID of the role.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RoleInfoUpdate"
              }
            }
          },
          "description": "Information about the role.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RoleInfo"
                }
              }
            },
            "description": "Information about the updated role."
          }
        },
        "summary": "Update role information",
        "tags": [
          "/role"
        ],
        "x-group": "role"
      }
    },
    "/saml/authn_request/{idp_name}": {
      "post": {
        "description": "Make a SAML authentication request for a specified IdP Authentication Domain.",
        "operationId": "makeSamlAuthnRequest",
        "parameters": [
          {
            "description": "Name of the IdP Authentication Domain to authenticate with.",
            "in": "path",
            "name": "idp_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SamlSsoAuthnRequestInfo"
              }
            }
          },
          "description": "Additional information associated with a single sign-on (SSO) authentication request."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SamlSsoAuthnRequestDetail"
                }
              }
            },
            "description": "Return the necessary data for constructing SAML authentication request."
          }
        },
        "summary": "Make SAML authentication request",
        "tags": [
          "/saml"
        ],
        "x-group": "saml",
        "x-unauthenticated": true
      }
    },
    "/saml/rubrik_metadata": {
      "post": {
        "description": "Configure and generate the SAML metadata for this Rubrik cluster. The call returns the download URL for the metadata.",
        "operationId": "configRubrikSamlMetadata",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RubrikSamlMetadataInfo"
              }
            }
          },
          "description": "Information for generating Rubrik SAML metadata file.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RubrikSamlMetadataSummary"
                }
              }
            },
            "description": "Returns the URL for downloading the Rubrik SAML metadata."
          }
        },
        "summary": "Configure and generate Rubrik SAML metadata",
        "tags": [
          "/saml"
        ],
        "x-group": "saml"
      }
    },
    "/saml/sso_status": {
      "get": {
        "description": "An object that contains two values. A Boolean value that determines whether or not SSO is enabled and an optional String value that indicates the name of the default IdP authentication domain for SSO login. When the boolean value is 'true,' SAML SSO is enabled. When the Boolean value is 'false,' SAML SSO is disabled.",
        "operationId": "getSamlSsoStatus",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SamlSsoStatus"
                }
              }
            },
            "description": "Return an object containing SAML SSO status."
          }
        },
        "summary": "Check SAML SSO Status",
        "tags": [
          "/saml"
        ],
        "x-group": "saml",
        "x-unauthenticated": true
      }
    },
    "/sap_hana/db": {
      "get": {
        "description": "Returns summary information for SAP HANA databases connected to the CDM cluster.",
        "operationId": "querySapHanaDatabases",
        "parameters": [
          {
            "description": "The ID of the SLA Domain that controls the protection of the host.",
            "in": "query",
            "name": "effective_sla_domain_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The ID of the Rubrik cluster that provides primary protection for the SAP HANA databases.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The name of the SAP HANA database.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The name of the SLA Domain that controls the protection of the SAP HANA database.",
            "in": "query",
            "name": "sla_assignment",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limit the number of matches returned.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "An integer that specifies a number of initial matches to ignore.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Specify whether the SAP HANA database is accessible on the Rubrik cluster.",
            "in": "query",
            "name": "is_relic",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Specifies the SAP HANA Database attribute to use in sorting the summary information.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "effectiveSlaDomainName",
                "name",
                "sapHanaSystemName"
              ],
              "type": "string"
            }
          },
          {
            "description": "The order to sort the responses by. Valid choices are asc (ascending) and desc (descending).",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SapHanaDatabaseSummaryListResponse"
                }
              }
            },
            "description": "If the query is successful, returns summary information for SAP HANA databases connected to the cluster."
          }
        },
        "summary": "Get summary information for discovered SAP HANA databases",
        "tags": [
          "/sap_hana"
        ],
        "x-group": "sap_hana_db"
      }
    },
    "/sap_hana/db/request/{id}": {
      "get": {
        "description": "Get details about a SAP HANA database related request which includes the status of data backup job.",
        "operationId": "getSapHanaDbAsyncRequestStatus",
        "parameters": [
          {
            "description": "ID of the request.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status for the async request."
          }
        },
        "summary": "Get the status of a SAP HANA database request",
        "tags": [
          "/sap_hana"
        ],
        "x-group": "sap_hana_db"
      }
    },
    "/sap_hana/db/snapshot/{id}": {
      "delete": {
        "description": "Initiates a request to delete a particular full snapshot of a SAP HANA database. If the log retention period for the database is still in effect, the snapshot will be deleted when the log retention period ends.",
        "operationId": "deleteSapHanaDbSnapshot",
        "parameters": [
          {
            "description": "ID assigned to a SAP HANA database full snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully initiated the request to delete the specified SAP HANA database snapshot and there is nothing to return."
          }
        },
        "summary": "Delete a particular full snapshot of a SAP HANA database",
        "tags": [
          "/sap_hana"
        ],
        "x-group": "sap_hana_db"
      },
      "get": {
        "description": "Retrieve detailed information about a full or an incremental snapshot of a SAP HANA database.",
        "operationId": "getSapHanaDbSnapshot",
        "parameters": [
          {
            "description": "ID of snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SapHanaDatabaseSnapshotDetail"
                }
              }
            },
            "description": "Returns details about a snapshot."
          }
        },
        "summary": "Get SAP HANA database snapshot details",
        "tags": [
          "/sap_hana"
        ],
        "x-group": "sap_hana_db"
      }
    },
    "/sap_hana/db/{id}": {
      "get": {
        "description": "Returns a detailed view of the SAP HANA database.",
        "operationId": "getSapHanaDatabase",
        "parameters": [
          {
            "description": "The ID of the SAP HANA database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SapHanaDatabaseDetail"
                }
              }
            },
            "description": "If the query is successful, returns a detailed view of the SAP HANA database."
          }
        },
        "summary": "Get detailed information for an SAP HANA database",
        "tags": [
          "/sap_hana"
        ],
        "x-group": "sap_hana_db"
      },
      "patch": {
        "description": "Update the SLA Domain that is configured for an SAP HANA database.",
        "operationId": "patchSapHanaDatabase",
        "parameters": [
          {
            "description": "The ID of the SAP HANA database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SapHanaDatabasePatch"
              }
            }
          },
          "description": "Object containing updated SAP HANA database SLA Domain ID.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SapHanaDatabaseDetail"
                }
              }
            },
            "description": "If the API call is successful, the SAP HANA database object is updated and summary of the object is returned."
          }
        },
        "summary": "Update the SLA Domain for an SAP HANA database",
        "tags": [
          "/sap_hana"
        ],
        "x-group": "sap_hana_db"
      }
    },
    "/sap_hana/db/{id}/configure_restore": {
      "post": {
        "description": "Initiates a job to configure the specified target database for a system copy restore by sending metadata about the source database. System copy restore in SAP HANA is done across different databases.",
        "operationId": "configureSapHanaRestore",
        "parameters": [
          {
            "description": "ID of the target SAP HANA database to be configured.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SapHanaRestoreSourceConfig"
              }
            }
          },
          "description": "The object containing configuration related metadata for the source SAP HANA database.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the request."
          }
        },
        "summary": "Configure the target database for system copy restore",
        "tags": [
          "/sap_hana"
        ],
        "x-group": "sap_hana_db"
      }
    },
    "/sap_hana/db/{id}/missed_snapshot": {
      "get": {
        "description": "Returns a summary of information for the missed snapshots of a SAP HANA database. Retrieve only the missed snapshots that occur between the beginning and ending timestamps.",
        "operationId": "getMissedSapHanaDbSnapshots",
        "parameters": [
          {
            "description": "ID of the SAP HANA database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter for snapshots that are missed on or after this time. The date-time string must be in ISO8601 format, for example, \"2016-01-01T01:23:45.678\".",
            "in": "query",
            "name": "after_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "Filter for snapshots that are missed on or before this time. The date-time string must be in ISO8601 format, for example, \"2016-01-01T01:23:45.678\".",
            "in": "query",
            "name": "before_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MissedSnapshotListResponse"
                }
              }
            },
            "description": "Returns details about missed snapshots."
          }
        },
        "summary": "Retrieve summary information for missed snapshots of a SAP HANA database",
        "tags": [
          "/sap_hana"
        ],
        "x-group": "sap_hana_db"
      }
    },
    "/sap_hana/db/{id}/recoverable_range": {
      "get": {
        "description": "Retrieve the recoverable ranges for a specified SAP HANA database. Provide a beginning and/or ending timestamp to retrieve only the recoverable ranges that fall within this period of time.",
        "operationId": "getSapHanaDbRecoverableRanges",
        "parameters": [
          {
            "description": "ID of the SAP HANA database.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter ranges to end after this time. The date-time string should be in an ISO8601 format. For example, \"2016-01-01T01:23:45.678Z\".",
            "in": "query",
            "name": "after_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "Filter ranges to start before this time. The date-time string should be in an ISO8601 format. For example, \"2016-01-01T01:23:45.678Z\".",
            "in": "query",
            "name": "before_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SapHanaRecoverableRangeListResponse"
                }
              }
            },
            "description": "Returns the recoverable ranges for the SAP HANA database."
          }
        },
        "summary": "Get recoverable ranges of a SAP HANA database",
        "tags": [
          "/sap_hana"
        ],
        "x-group": "sap_hana_db"
      }
    },
    "/sap_hana/db/{id}/snapshot": {
      "get": {
        "description": "Retrieve summary information about the full and incremental snapshots of a specified SAP HANA database.",
        "operationId": "querySapHanaDbSnapshot",
        "parameters": [
          {
            "description": "ID assigned to a SAP HANA database object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter snapshots to those of a particular backup type.",
            "in": "query",
            "name": "backup_type",
            "required": false,
            "schema": {
              "enum": [
                "FULL",
                "INCREMENTAL"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter snapshots to those taken on or after this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\".",
            "in": "query",
            "name": "after_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "Filter snapshots to those taken before or on this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\".",
            "in": "query",
            "name": "before_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SapHanaDatabaseSnapshotSummaryListResponse"
                }
              }
            },
            "description": "Returns summary information for all snapshots."
          }
        },
        "summary": "Get a summary list of snapshots for a SAP HANA database",
        "tags": [
          "/sap_hana"
        ],
        "x-group": "sap_hana_db"
      },
      "post": {
        "description": "Initiates a job to take an on demand full snapshot of a specified SAP HANA database object. The GET /sap_hana/db/request/{id} endpoint can be used to monitor the progress of the job.",
        "operationId": "createOnDemandSapHanaBackup",
        "parameters": [
          {
            "description": "ID assigned to a SAP HANA database object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BaseOnDemandSnapshotConfig"
              }
            }
          },
          "description": "Configuration for the on demand backup."
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status for the backup request."
          }
        },
        "summary": "Create on demand database snapshot",
        "tags": [
          "/sap_hana"
        ],
        "x-group": "sap_hana_db"
      }
    },
    "/sap_hana/db/{id}/unconfigure_restore": {
      "post": {
        "description": "Initiates a job to reset the configuration for the system copy restore on the specified target database. System copy restore in SAP HANA is done across different databases.",
        "operationId": "unconfigureSapHanaRestore",
        "parameters": [
          {
            "description": "ID assigned to target SAP HANA database object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the request."
          }
        },
        "summary": "Reset the configuration for system copy restore on target database",
        "tags": [
          "/sap_hana"
        ],
        "x-group": "sap_hana_db"
      }
    },
    "/sap_hana/system": {
      "get": {
        "description": "Returns summary information for SAP HANA systems.",
        "operationId": "querySapHanaSystems",
        "parameters": [
          {
            "description": "The ID of the Rubrik cluster that provides primary protection for the SAP HANA databases.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The SAP System Identification (SID) code for the SAP HANA system.",
            "in": "query",
            "name": "sid",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limit the number of matches returned.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "An integer that specifies a number of initial matches to ignore.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "The SAP HANA system attribute to use in sorting the responses.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "sid"
              ],
              "type": "string"
            }
          },
          {
            "description": "The order to sort the responses by. Valid choices are asc (ascending) and desc (descending).",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SapHanaSystemSummaryListResponse"
                }
              }
            },
            "description": "If query is successful, returns summary information for SAP HANA systems."
          }
        },
        "summary": "Get summary information for added SAP HANA systems",
        "tags": [
          "/sap_hana"
        ],
        "x-group": "sap_hana_system"
      },
      "post": {
        "description": "Add a SAP HANA system to the Rubrik cluster.",
        "operationId": "addSapHanaSystem",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SapHanaSystemConfig"
              }
            }
          },
          "description": "Add a SAP HANA system to the Rubrik cluster. Contains parameters like username, list of hosts, password required while adding a SAP HANA system.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SapHanaAddSystemResponse"
                }
              }
            },
            "description": "Adds the SAP HANA system and returns its ID and the status of the scheduled system refresh job."
          }
        },
        "summary": "Add a SAP HANA system",
        "tags": [
          "/sap_hana"
        ],
        "x-group": "sap_hana_system"
      }
    },
    "/sap_hana/system/request/{id}": {
      "get": {
        "description": "Get details about a SAP HANA system related request which includes the status of delete or refresh system job.",
        "operationId": "getSapHanaSystemAsyncRequestStatus",
        "parameters": [
          {
            "description": "The ID of the request object used to poll the status.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status for the request."
          }
        },
        "summary": "Get the status of a SAP HANA system request",
        "tags": [
          "/sap_hana"
        ],
        "x-group": "sap_hana_system"
      }
    },
    "/sap_hana/system/{id}": {
      "delete": {
        "description": "Initiates a job to delete a SAP HANA system object. GET /sap_hana/system/request/{id} endpoint can be used to monitor the progress of the job.",
        "operationId": "deleteSapHanaSystem",
        "parameters": [
          {
            "description": "The ID of the SAP HANA system.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status for the request."
          }
        },
        "summary": "Delete a SAP HANA system",
        "tags": [
          "/sap_hana"
        ],
        "x-group": "sap_hana_system"
      },
      "get": {
        "description": "Returns a summary view of a SAP HANA system.",
        "operationId": "getSapHanaSystem",
        "parameters": [
          {
            "description": "The ID of the SAP HANA system.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SapHanaSystemSummary"
                }
              }
            },
            "description": "Returns summary information."
          }
        },
        "summary": "Get summary information for a SAP HANA system",
        "tags": [
          "/sap_hana"
        ],
        "x-group": "sap_hana_system"
      },
      "patch": {
        "description": "Update the SLA Domain that is configured for a SAP HANA system.",
        "operationId": "patchSapHanaSystem",
        "parameters": [
          {
            "description": "The ID of the SAP HANA system.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SapHanaSystemPatch"
              }
            }
          },
          "description": "An object that contains the updated SLA Domain ID for the SAP HANA system.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SapHanaPatchSystemResponse"
                }
              }
            },
            "description": "Updates the SAP HANA system and returns its summary and the status of the scheduled system refresh job."
          }
        },
        "summary": "Update the SLA Domain for a SAP HANA system",
        "tags": [
          "/sap_hana"
        ],
        "x-group": "sap_hana_system"
      }
    },
    "/sap_hana/system/{id}/refresh": {
      "post": {
        "description": "Initiates a job to refresh metadata of a SAP HANA system object. The GET /sap_hana/system/request/{id} endpoint can be used to monitor the progress of the job.",
        "operationId": "createSapHanaSystemRefresh",
        "parameters": [
          {
            "description": "The ID of the SAP HANA system.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status for the request."
          }
        },
        "summary": "Refresh SAP HANA system metadata",
        "tags": [
          "/sap_hana"
        ],
        "x-group": "sap_hana_system"
      }
    },
    "/session": {
      "post": {
        "description": "Open a user session.",
        "operationId": "createSession",
        "parameters": [
          {
            "description": "Bind the new session to the specified organization. When this parameter is not specified, the session will be bound to an organization chosen according to the user's preferences and authorizations.",
            "in": "query",
            "name": "organization_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Bind the new session to the specified directory. When this parameter is unspecified, the session will be bound to local domain.",
            "in": "query",
            "name": "realm",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SessionSummary"
                }
              }
            },
            "description": "Session creation successful."
          }
        },
        "summary": "Create user session",
        "tags": [
          "/session"
        ],
        "x-group": "session",
        "x-rk-block-api-tokens": true
      }
    },
    "/session/{id}": {
      "delete": {
        "description": "Close a user session and invalidate the session token.",
        "operationId": "deleteSession",
        "parameters": [
          {
            "description": "Session ID or  *me* for session of bearer token.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "default": "me",
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Invalidation successful."
          }
        },
        "summary": "Delete user session",
        "tags": [
          "/session"
        ],
        "x-group": "session"
      }
    },
    "/sla_domain": {
      "get": {
        "description": "Retrieve summary information for all SLA Domains.",
        "operationId": "querySlaDomain",
        "parameters": [
          {
            "description": "Limits the information retrieved to those SLA Domains that are associated with the Rubrik cluster ID that is specified by primary_cluster_id. Use **local** for the Rubrik cluster that is hosting the current REST API session.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limit the list information to those SLA Domains which match the specified SLA Domain 'name' value.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Attribute to use to sort the SLA Domains summary information. Optionally use **_sort_order_** to specify whether to sort in ascending or descending order.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "name"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort order, either ascending or descending. If not specified, SLA Domain summary results will be sorted in ascending order.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          {
            "description": "Limit the list information to SLA Domains that can be assigned to specified data sources.",
            "explode": false,
            "in": "query",
            "name": "data_sources",
            "required": false,
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          },
          {
            "description": "Limit the list information to SLA Domains that can be assigned to specified snapshots.",
            "explode": false,
            "in": "query",
            "name": "snapshot_ids",
            "required": false,
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SlaDomainSummaryListResponse"
                }
              }
            },
            "description": "Summary information for SLA Domains."
          }
        },
        "summary": "Get list of SLA Domains",
        "tags": [
          "/sla_domain"
        ],
        "x-group": "sla_domain"
      },
      "post": {
        "description": "Create a new SLA Domain on a Rubrik cluster by specifying Domain Rules and policies. Only Managed Volume objects support minute frequency to take transaction log backup. SLA assignment on other objects will be disallowed.",
        "operationId": "createSlaDomain",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SlaDomainDefinition"
              }
            }
          },
          "description": "SLA Domain definition. The SLA domain accepts two backup windows, one for a regular backup or snapshot and one for the first full backup or snapshot. Specify times using Rubrik cluster timezone.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SlaDomainSummary"
                }
              }
            },
            "description": "Summary of newly created SLA Domain."
          }
        },
        "summary": "Create SLA Domain",
        "tags": [
          "/sla_domain"
        ],
        "x-group": "sla_domain"
      }
    },
    "/sla_domain/assign_to_downloaded_snapshots": {
      "post": {
        "description": "Assigns an SLA Domain to a list of downloaded snapshots. The SLA Domain manages retention for the snapshots in the downloaded location. The assignment does not affect the retention of the snapshots in other locations.",
        "operationId": "assignSlaToDownloadedSnapshots",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DownloadedSnapshotSlaAssignmentInfo"
              }
            }
          },
          "description": "An object ID and a list of IDs for the downloaded snapshots. The specified SLA Domain manages retention for the downloaded copy of snapshots assigned to the specified IDs.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchAsyncRequestStatus"
                }
              }
            },
            "description": "Queued asynchronous requests for assigning SLA Domains to downloaded snapshots."
          }
        },
        "summary": "Assign retention SLA Domain to the downloaded snapshots of a single object",
        "tags": [
          "/sla_domain"
        ],
        "x-group": "sla_domain"
      }
    },
    "/sla_domain/{id}": {
      "delete": {
        "description": "Delete an SLA Domain from a Rubrik cluster. The SLA Domain must not be assigned to any VMs, filesets or databases.",
        "operationId": "deleteSlaDomain",
        "parameters": [
          {
            "description": "ID of the SLA Domain.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Removed the specified SLA Domain."
          }
        },
        "summary": "Remove SLA Domain",
        "tags": [
          "/sla_domain"
        ],
        "x-group": "sla_domain"
      },
      "get": {
        "description": "Retrieve summary information for a specified SLA Domain.",
        "operationId": "getSlaDomain",
        "parameters": [
          {
            "description": "ID of the SLA Domain.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SlaDomainSummary"
                }
              }
            },
            "description": "Object containing information about the SLA Domain."
          }
        },
        "summary": "Get SLA Domain details",
        "tags": [
          "/sla_domain"
        ],
        "x-group": "sla_domain"
      },
      "patch": {
        "deprecated": true,
        "description": "(DEPRECATED) Patch the properties of an SLA Domain. The recommended endpoint is v3/sla_domain/{id}.",
        "operationId": "patchSlaDomain",
        "parameters": [
          {
            "description": "ID of the SLA Domain.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A Boolean that determines whether the new configuration retains existing snapshots of data sources that are currently retained by this SLA Domain. The value is 'true' by default.",
            "in": "query",
            "name": "should_apply_to_existing_snapshots",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SlaDomainPatchDefinition"
              }
            }
          },
          "description": "Object containing the fields to be edited for SLA Domain. The SLA Domain accepts two backup windows, one for a regular backup or snapshot and one for the first full backup or snapshot. Specify times using the Rubrik cluster timezone. Remote SLA Domain only supports edit to the archival specification.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SlaDomainSummary"
                }
              }
            },
            "description": "Object containing the patched SLA Domain."
          }
        },
        "summary": "Patch SLA Domain",
        "tags": [
          "/sla_domain"
        ],
        "x-group": "sla_domain"
      },
      "put": {
        "description": "Update the properties of an SLA Domain.",
        "operationId": "updateSlaDomain",
        "parameters": [
          {
            "description": "ID of the SLA Domain.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A Boolean that determines whether the new configuration retains existing snapshots of data sources that are currently retained by this SLA Domain. The value is 'true' by default.",
            "in": "query",
            "name": "should_apply_to_existing_snapshots",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SlaDomainDefinition"
              }
            }
          },
          "description": "Object containing the updated SLA Domain. The SLA domain accepts two backup windows, one for a regular backup or snapshot and one for the first full backup or snpashot. Specify times using the Rubrik cluster time zone.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SlaDomainSummary"
                }
              }
            },
            "description": "Object containing updated SLA Domain."
          }
        },
        "summary": "Update SLA Domain",
        "tags": [
          "/sla_domain"
        ],
        "x-group": "sla_domain"
      }
    },
    "/snapshot/{id}/storage/stats": {
      "get": {
        "description": "Returns the storage statistics for a snapshot.",
        "operationId": "getSnapshotStorageStatsV1",
        "parameters": [
          {
            "description": "ID assigned to a snapshot object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SnapshotStorageStats"
                }
              }
            },
            "description": "Returns storage stats for a snapshot."
          }
        },
        "summary": "Returns storage stats for a snapshot",
        "tags": [
          "/snapshot"
        ],
        "x-group": "snapshot_v1"
      }
    },
    "/syslog/export": {
      "get": {
        "description": "Return the list of all configured syslog export rules.",
        "operationId": "getSyslogExportRules",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SyslogExportRuleSummaryListResponse"
                }
              }
            },
            "description": "List of all configured syslog export rules."
          }
        },
        "summary": "Get the configured syslog export rules",
        "tags": [
          "/cluster"
        ],
        "x-group": "syslog"
      },
      "post": {
        "description": "Adds a new rule specifying where to export the specified syslog information.\n",
        "operationId": "addSyslogExportRule",
        "requestBody": {
          "$ref": "#/components/requestBodies/SyslogExportRuleFull"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SyslogExportRuleSummary"
                }
              }
            },
            "description": "Summary of the newly added syslog export rule."
          }
        },
        "summary": "Add a new syslog export rule",
        "tags": [
          "/cluster"
        ],
        "x-group": "syslog"
      }
    },
    "/syslog/export/test": {
      "post": {
        "description": "Send a test message using the syslog export rule specified by the given id.\n",
        "operationId": "testSyslogExportRule",
        "requestBody": {
          "$ref": "#/components/requestBodies/SyslogExportRuleFull"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SyslogServerTestResult"
                }
              }
            },
            "description": "Syslog export rule was tested successfully."
          }
        },
        "summary": "Test the specified syslog export rule",
        "tags": [
          "/cluster"
        ],
        "x-group": "syslog"
      }
    },
    "/syslog/export/{id}": {
      "delete": {
        "description": "Delete the syslog export rule specified by the given id.",
        "operationId": "deleteSyslogExportRule",
        "parameters": [
          {
            "description": "The ID of the syslog export rule.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Syslog server export rule successfully deleted."
          }
        },
        "summary": "Delete the specified syslog export rule",
        "tags": [
          "/cluster"
        ],
        "x-group": "syslog"
      },
      "get": {
        "description": "Get the summary of the syslog export rule specified by the given id.\n",
        "operationId": "getSyslogExportRule",
        "parameters": [
          {
            "description": "The ID of syslog export rule.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SyslogExportRuleSummary"
                }
              }
            },
            "description": "Summary of the syslog export rule."
          }
        },
        "summary": "Get the specified syslog export rule",
        "tags": [
          "/cluster"
        ],
        "x-group": "syslog"
      },
      "patch": {
        "description": "Update the syslog export rule specified by the given id.",
        "operationId": "updateSyslogExportRule",
        "parameters": [
          {
            "description": "The ID of syslog export rule.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SyslogExportRulePartial"
              }
            }
          },
          "description": "Syslog export rule.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SyslogExportRuleSummary"
                }
              }
            },
            "description": "Updated syslog export rule."
          }
        },
        "summary": "Update the specified syslog export rule",
        "tags": [
          "/cluster"
        ],
        "x-group": "syslog"
      }
    },
    "/unmanaged_object": {
      "get": {
        "description": "Get summary of all the objects with unmanaged snapshots.",
        "operationId": "queryUnmanagedObjectV1",
        "parameters": [
          {
            "description": "Limit the number of matches returned.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "First unmanaged object after which objects should be retrieved.",
            "in": "query",
            "name": "after_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filters by the object name using infix search.",
            "in": "query",
            "name": "search_value",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filters by object status. Valid status are Protected, Unprotected, and Relic.",
            "in": "query",
            "name": "unmanaged_status",
            "required": false,
            "schema": {
              "enum": [
                "Protected",
                "Relic",
                "Unprotected",
                "ReplicatedRelic",
                "RemoteUnprotected"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter by the type of the unmanaged object.",
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "enum": [
                "VirtualMachine",
                "MssqlDatabase",
                "LinuxFileset",
                "WindowsFileset",
                "ShareFileset",
                "NutanixVirtualMachine",
                "HypervVirtualMachine",
                "ManagedVolume",
                "Ec2Instance",
                "StorageArrayVolumeGroup",
                "VcdVapp",
                "LinuxHost",
                "WindowsHost",
                "OracleDatabase",
                "VolumeGroup",
                "AppBlueprint"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort the result by given attribute.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "Name",
                "UnmanagedStatus",
                "Location",
                "UnmanagedSnapshotCount",
                "LocalStorage",
                "ArchiveStorage",
                "RetentionSlaDomainName",
                "ObjectType",
                "SnapshotCount",
                "AutoSnapshotCount",
                "ManualSnapshotCount"
              ],
              "type": "string"
            }
          },
          {
            "description": "The sort order. The default sort order is ascending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnmanagedObjectDetailsListResponse"
                }
              }
            },
            "description": "Get page summary about objects with unmanaged snapshots."
          }
        },
        "summary": "Get summary of all the objects with unmanaged snapshots",
        "tags": [
          "/unmanaged_object"
        ],
        "x-group": "unmanaged_object"
      }
    },
    "/unmanaged_object/assign_retention_sla": {
      "post": {
        "description": "Assign relic/unmanaged entities to the specified SLA Domain for managing retention. The assignment event runs asynchronously.",
        "operationId": "assignToRetentionSlaAsync",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UnmanagedObjectSlaAssignmentInfo"
              }
            }
          },
          "description": "Object with SLA Domain ID and a comma-separated list of the IDs of the relic/unmanaged entities being assigned to the SLA Domain.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/ManagedObjectPendingSlaInfo"
                  },
                  "type": "array"
                }
              }
            },
            "description": "Pending SLA Domains resulting from this assignment."
          }
        },
        "summary": "Assign relic/unmanaged entities to an SLA Domain for managing retention asynchronously",
        "tags": [
          "/unmanaged_object"
        ],
        "x-group": "unmanaged_object"
      }
    },
    "/unmanaged_object/reader_object": {
      "get": {
        "description": "A summary of all unmanaged objects recovered from reader archival locations.",
        "operationId": "queryUnmanagedReaderObject",
        "parameters": [
          {
            "description": "Limit the number of matches returned.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Retrieve objects after the unmanaged object with the specified ID.",
            "in": "query",
            "name": "after_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Search object by object name.",
            "in": "query",
            "name": "object_name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filters by object status. Valid status are Protected, Unprotected, and Relic.",
            "in": "query",
            "name": "unmanaged_status",
            "required": false,
            "schema": {
              "enum": [
                "Protected",
                "Relic",
                "Unprotected",
                "ReplicatedRelic",
                "RemoteUnprotected"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter by the type of the unmanaged object.",
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "enum": [
                "VirtualMachine",
                "MssqlDatabase",
                "LinuxFileset",
                "WindowsFileset",
                "ShareFileset",
                "NutanixVirtualMachine",
                "HypervVirtualMachine",
                "ManagedVolume",
                "Ec2Instance",
                "StorageArrayVolumeGroup",
                "VcdVapp",
                "LinuxHost",
                "WindowsHost",
                "OracleDatabase",
                "VolumeGroup",
                "AppBlueprint"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort the result by given attribute.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "Name",
                "UnmanagedStatus",
                "Location",
                "UnmanagedSnapshotCount",
                "LocalStorage",
                "ArchiveStorage",
                "RetentionSlaDomainName",
                "ObjectType",
                "SnapshotCount",
                "AutoSnapshotCount",
                "ManualSnapshotCount"
              ],
              "type": "string"
            }
          },
          {
            "description": "The sort order. The default sort order is ascending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnmanagedObjectSummaryListResponse"
                }
              }
            },
            "description": "Returns a page summary of the unmanaged objects recovered from reader archival locations."
          }
        },
        "summary": "Get summary of all unmanaged reader objects",
        "tags": [
          "/unmanaged_object"
        ],
        "x-group": "unmanaged_object"
      }
    },
    "/unmanaged_object/snapshot/bulk_archive_tier": {
      "post": {
        "description": "Schedules a job to tier existing snapshots of the specified objects to cold storage.",
        "operationId": "bulkTierExistingSnapshots",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BulkTierSnapshotsConfig"
              }
            }
          },
          "description": "A list of object IDs to tier. Optionally specifies a location ID.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Job ID of the TIER_EXISTING_SNAPSHOTS job scheduled."
          }
        },
        "summary": "Bulk tier existing snapshots to cold storage",
        "tags": [
          "/unmanaged_object"
        ],
        "x-group": "unmanaged_object"
      }
    },
    "/unmanaged_object/{id}/snapshot": {
      "get": {
        "description": "Gets summary information for all snapshots of the object with the specified object ID.",
        "operationId": "queryUnmanagedObjectSnapshotsV1",
        "parameters": [
          {
            "description": "ID of a object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limit the number of matches returned.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Ignore these many matches in the beginning.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Search snapshot by date and time.",
            "in": "query",
            "name": "search_value",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by snapshot type. Valid types are OnDemand, PolicyBased, Retrieved.",
            "in": "query",
            "name": "snapshot_type",
            "required": false,
            "schema": {
              "enum": [
                "OnDemand",
                "PolicyBased",
                "Retrieved"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter all the snapshots before a date.",
            "in": "query",
            "name": "before_date",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "Filter all the snapshots after a date.",
            "in": "query",
            "name": "after_date",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "Sort by given attribute.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "SnapshotDateAndTime",
                "LocalExpirationDate",
                "ArchivalLocation"
              ],
              "type": "string"
            }
          },
          {
            "description": "The sort order. The default sort order is ascending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SnapshotSummaryListResponse"
                }
              }
            },
            "description": "Get page summary about snapshots for a given object."
          }
        },
        "summary": "Get summary of all the snapshots for a given object",
        "tags": [
          "/unmanaged_object"
        ],
        "x-group": "unmanaged_object"
      }
    },
    "/user/lockout": {
      "get": {
        "description": "Get the local user account lockout settings which are used to configure whether user accounts will be locked on failed logins, when they will be locked and the duration for which they will stay locked.\n",
        "operationId": "getUserAccountLockoutSettings",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LocalUserAccountLockoutStatus"
                }
              }
            },
            "description": "Get the local user account lockout settings which are used to configure whether user accounts will be locked on failed logins, when they will be locked and the duration for which they will stay locked.\n"
          }
        },
        "summary": "Get the local user account lockout settings",
        "tags": [
          "/user"
        ],
        "x-group": "user"
      },
      "patch": {
        "description": "Update the local user account lockout settings which are used to configure whether user accounts will be locked on failed logins, when they will be locked and the duration for which they will stay locked.\n",
        "operationId": "manageUserAccountLockoutSettings",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LocalUserAccountLockoutConfig"
              }
            }
          },
          "description": "Update the local user account lockout settings.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LocalUserAccountLockoutStatus"
                }
              }
            },
            "description": "Current configuration for local user account lockout feature.\n"
          }
        },
        "summary": "Update the local user account lockout settings",
        "tags": [
          "/user"
        ],
        "x-group": "user"
      }
    },
    "/user/{id}/totp/config": {
      "delete": {
        "description": "Reset the TOTP settings to the default disabled state for the specified user account.\n",
        "operationId": "resetTotp",
        "parameters": [
          {
            "description": "The user account object ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully reset the TOTP."
          }
        },
        "summary": "Reset the TOTP for the given user",
        "tags": [
          "/user"
        ],
        "x-group": "user"
      },
      "put": {
        "description": "Use this endpoint to configure the time-based one time password (TOTP) secret for a specified user account. The endpoint replaces an existing secret with the new one. The Rubrik cluster checks the secret against a one time password (OTP) to ensure validity.\n",
        "operationId": "setupTotp",
        "parameters": [
          {
            "description": "The user account object ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TotpConfigUpdateRequest"
              }
            }
          },
          "description": "The time-based one time password (TOTP) configuration.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "Successfully configured the TOTP settings for the specified user account.\n"
          }
        },
        "summary": "Configure the TOTP secret for the given user",
        "tags": [
          "/user"
        ],
        "x-group": "user"
      }
    },
    "/user/{id}/totp/new_secret": {
      "post": {
        "description": "Use this endpoint to generate the time-based one time password (TOTP) secret key for a specified user account. The secret is a key value encoded in Base32 and includes a URI for generating a scannable QR code.\n",
        "operationId": "generateTotpSecret",
        "parameters": [
          {
            "description": "The user account object ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TotpSecret"
                }
              }
            },
            "description": "Successfully generated TOTP secret."
          }
        },
        "summary": "Generate a TOTP secret key for the given user",
        "tags": [
          "/user"
        ],
        "x-group": "user"
      }
    },
    "/user/{id}/totp/status": {
      "get": {
        "description": "Get the time-based one time password (TOTP) status for a specified user account. The TOTP status specifies whether that account has TOTP enabled and whether TOTP is being enforced for that account.\n",
        "operationId": "getTotpStatus",
        "parameters": [
          {
            "description": "The user account object ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TotpStatus"
                }
              }
            },
            "description": "The TOTP status of the user.\n"
          }
        },
        "summary": "Get the TOTP status for the given user",
        "tags": [
          "/user"
        ],
        "x-group": "user"
      }
    },
    "/user/{id}/unlock": {
      "post": {
        "description": "Unlock a user account that has been locked because of too many failed login attempts.",
        "operationId": "unlockUser",
        "parameters": [
          {
            "description": "The ID of the user account that has been locked.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully unlocked the user."
          }
        },
        "summary": "Unlock a user account",
        "tags": [
          "/user"
        ],
        "x-group": "user"
      }
    },
    "/user_defined_tag": {
      "delete": {
        "description": "Delete a list of user-defined resource tags in one delete operation.\n",
        "operationId": "deleteUserDefinedTagBulk",
        "parameters": [
          {
            "description": "An array of IDs of the user-defined resource tags to be deleted. Any non-existent ID in the array will be ignored.\n",
            "explode": false,
            "in": "query",
            "name": "ids",
            "required": true,
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResourceTagDeleteResponse"
                }
              }
            },
            "description": "Return a list of IDs that were deleted successfully."
          }
        },
        "summary": "Delete a list of user-defined resource tags",
        "tags": [
          "/user_defined_tag"
        ],
        "x-group": "user_defined_tag"
      },
      "get": {
        "description": "Get user-defined resource tags for the cloud compute resources created by CloudOn and CloudOut.\n",
        "operationId": "queryUserDefinedTag",
        "parameters": [
          {
            "description": "Filter results by resource tag.",
            "in": "query",
            "name": "key",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter results by archival location id.",
            "in": "query",
            "name": "scope_ref_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResourceTagGetResponse"
                }
              }
            },
            "description": "List of user-defined resource tags."
          }
        },
        "summary": "Get user-defined resource tags",
        "tags": [
          "/user_defined_tag"
        ],
        "x-group": "user_defined_tag"
      },
      "post": {
        "description": "Create a user-defined resource tag for tagging cloud compute resources created by CloudOn and CloutOut.\n",
        "operationId": "createUserDefinedTag",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ResourceTagDefinition"
              }
            }
          },
          "description": "The definition of a new user-defined resource tag to be created.\n",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResourceTagDetail"
                }
              }
            },
            "description": "Return the successfully created ResourceTag details."
          }
        },
        "summary": "Create a user-defined resource tag for tagging cloud compute resources",
        "tags": [
          "/user_defined_tag"
        ],
        "x-group": "user_defined_tag"
      }
    },
    "/user_defined_tag/{id}": {
      "delete": {
        "description": "Delete a user-defined resource tag.",
        "operationId": "deleteUserDefinedTag",
        "parameters": [
          {
            "description": "ID of the user-defined resource tag.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Result of the delete request."
          }
        },
        "summary": "Delete a user-defined resource tag",
        "tags": [
          "/user_defined_tag"
        ],
        "x-group": "user_defined_tag"
      },
      "get": {
        "description": "Retrieve details of a user-defined resource tag.",
        "operationId": "getUserDefinedTag",
        "parameters": [
          {
            "description": "ID of the user-defined resource tag.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResourceTagDetail"
                }
              }
            },
            "description": "resource tag detail."
          }
        },
        "summary": "Get user-defined tag",
        "tags": [
          "/user_defined_tag"
        ],
        "x-group": "user_defined_tag"
      },
      "patch": {
        "description": "Update the value of a user-defined resource tag.\n",
        "operationId": "updateUserDefinedTag",
        "parameters": [
          {
            "description": "ID of the user-defined resource tag.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ResourceTagUpdate"
              }
            }
          },
          "description": "Properties to update.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResourceTagDetail"
                }
              }
            },
            "description": "Updated resource tag detail."
          }
        },
        "summary": "Update the value of a user-defined resource tag",
        "tags": [
          "/user_defined_tag"
        ],
        "x-group": "user_defined_tag"
      }
    },
    "/vcd/cluster": {
      "get": {
        "description": "Retrieve summary information for all vCD cluster objects.",
        "operationId": "queryVcdClusterV1",
        "parameters": [
          {
            "description": "Search for a vCD Cluster object by name.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter the results using the status value of the vCD Cluster objects.",
            "in": "query",
            "name": "status",
            "required": false,
            "schema": {
              "enum": [
                "Disconnected",
                "Refreshing",
                "Connected",
                "BadlyConfigured",
                "Deleting",
                "Remote"
              ],
              "type": "string"
            }
          },
          {
            "description": "Attribute to sort the results on.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "Name",
                "Status"
              ],
              "type": "string"
            }
          },
          {
            "description": "Order for sorting the results, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "default": "asc",
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VcdClusterSummaryListResponse"
                }
              }
            },
            "description": "Summary information for vCD clusters."
          }
        },
        "summary": "Get summary for all vCD Clusters",
        "tags": [
          "/vcd/cluster"
        ],
        "x-group": "vcd_cluster"
      },
      "post": {
        "description": "Create a vCD Cluster object by providing the address of the vCD Cluster and the credentials for an account on the vCD Cluster that has administrator privileges. This request initiates an asynchronous job to connect with the vCD Cluster and retrieve the required metadata.",
        "operationId": "createVcdClusterV1",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VcdClusterConfig"
              }
            }
          },
          "description": "IP address and account credentials of the vCD Cluster, and ID of the managing Rubrik cluster.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of an async request to add a vCD Cluster."
          }
        },
        "summary": "Add a vCD Cluster",
        "tags": [
          "/vcd/cluster"
        ],
        "x-group": "vcd_cluster"
      }
    },
    "/vcd/cluster/request/{id}": {
      "get": {
        "description": "Retrieve the details of a specified asynchronous job for a vCD Cluster.",
        "operationId": "getVcdClusterAsyncRequestStatusV1",
        "parameters": [
          {
            "description": "ID assigned to an asynchronous job.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of a vCD Cluster asynchronous job."
          }
        },
        "summary": "Get vCD Cluster job status",
        "tags": [
          "/vcd/cluster"
        ],
        "x-group": "vcd_cluster"
      }
    },
    "/vcd/cluster/{id}": {
      "delete": {
        "description": "Start an asynchronous job to remove a vCD Cluster object.",
        "operationId": "deleteVcdClusterV1",
        "parameters": [
          {
            "description": "ID assigned to a vCD Cluster object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of a job to delete a vCD Cluster."
          }
        },
        "summary": "Remove vCD Cluster",
        "tags": [
          "/vcd/cluster"
        ],
        "x-group": "vcd_cluster"
      },
      "get": {
        "description": "Retrieve detailed information for a vCD Cluster object.",
        "operationId": "getVcdClusterV1",
        "parameters": [
          {
            "description": "ID assigned to a vCD Cluster object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VcdClusterDetail"
                }
              }
            },
            "description": "Details for a vCD Cluster object."
          }
        },
        "summary": "Get vCD Cluster details",
        "tags": [
          "/vcd/cluster"
        ],
        "x-group": "vcd_cluster"
      },
      "patch": {
        "description": "Modify the hostname and credentials of a specified vCD Cluster object.",
        "operationId": "updateVcdClusterV1",
        "parameters": [
          {
            "description": "ID assigned to a vCD Cluster object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VcdClusterPatch"
              }
            }
          },
          "description": "Updated hostname and credentials for a specified vCD Cluster object.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VcdClusterDetail"
                }
              }
            },
            "description": "Details of an updated vCD Cluster object."
          }
        },
        "summary": "Change vCD Cluster object",
        "tags": [
          "/vcd/cluster"
        ],
        "x-group": "vcd_cluster"
      }
    },
    "/vcd/cluster/{id}/refresh": {
      "post": {
        "description": "Start an asynchronous job to refresh the metadata for a specified vCD Cluster object.",
        "operationId": "refreshVcdClusterV1",
        "parameters": [
          {
            "description": "ID assigned to a vCD Cluster object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of a vCD Cluster metadata refresh job."
          }
        },
        "summary": "Refresh a vCD Cluster",
        "tags": [
          "/vcd/cluster"
        ],
        "x-group": "vcd_cluster"
      }
    },
    "/vcd/cluster/{id}/vimserver": {
      "get": {
        "description": "Retrieves the VimServer representation of the vCenter Servers that are attached to a specified vCD Cluster object.",
        "operationId": "queryVcdVimServerV1",
        "parameters": [
          {
            "description": "ID assigned to a vCD Cluster object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Attribute to sort the results on.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "Name",
                "Status"
              ],
              "type": "string"
            }
          },
          {
            "description": "Order for sorting the results, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "default": "asc",
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VimserverSummaryListResponse"
                }
              }
            },
            "description": "Summary information for VimServer objects."
          }
        },
        "summary": "Get VimServers of a vCD Cluster",
        "tags": [
          "/vcd/cluster"
        ],
        "x-group": "vcd_cluster"
      }
    },
    "/vcd/hierarchy/{id}": {
      "get": {
        "description": "Retrieve details for the specified object in the vCD hierarchy.",
        "operationId": "getVcdHierarchyObjectV1",
        "parameters": [
          {
            "description": "ID of the vCD hierarchy object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VcdHierarchyObjectSummary"
                }
              }
            },
            "description": "Details of the hierarchy object."
          }
        },
        "summary": "Get summary of a vCD hierarchy object",
        "tags": [
          "/vcd/hierarchy"
        ],
        "x-group": "vcd_hierarchy"
      }
    },
    "/vcd/hierarchy/{id}/children": {
      "get": {
        "description": "Retrieve the list of immediate descendant objects for the specified parent.",
        "operationId": "getVcdHierarchyChildrenV1",
        "parameters": [
          {
            "description": "ID of the parent vCD hierarchy object. To get top-level nodes, use **root** as the ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Attribute to sort the results on.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "Name",
                "EffectiveSlaDomainName",
                "SlaAssignment",
                "ConnectionStatus",
                "VappCount"
              ],
              "type": "string"
            }
          },
          {
            "description": "Order for sorting the results, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "default": "asc",
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          {
            "description": "Limit the number of matches returned.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Number of matches to ignore from the beginning of the results.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Search object by object name.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by isRelic field of vCD vApp hierarchy object. Return both relic and non-relic children when this value is not specified.",
            "in": "query",
            "name": "is_relic",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Filter by ID of effective SLA domain.",
            "in": "query",
            "name": "effective_sla_domain_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by node object type.",
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "enum": [
                "Cluster",
                "VimServer",
                "Org",
                "OrgVdc",
                "Catalog",
                "vApp"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter by primary cluster ID, or **local**.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by SLA assignment type.",
            "in": "query",
            "name": "sla_assignment",
            "required": false,
            "schema": {
              "enum": [
                "Derived",
                "Direct",
                "Unassigned"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filters vCD hierarchy objects based on the specified query value.",
            "in": "query",
            "name": "snappable_status",
            "required": false,
            "schema": {
              "enum": [
                "Protectable"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VcdHierarchyObjectSummaryListResponse"
                }
              }
            },
            "description": "Summary list of immediate descendant objects."
          }
        },
        "summary": "Get immediate descendant objects",
        "tags": [
          "/vcd/hierarchy"
        ],
        "x-group": "vcd_hierarchy"
      }
    },
    "/vcd/hierarchy/{id}/descendants": {
      "get": {
        "description": "Retrieve the list of descendant objects for the specified parent.",
        "operationId": "getVcdHierarchyDescendantsV1",
        "parameters": [
          {
            "description": "ID of the parent vCD hierarchy object. To get top-level nodes, use **root** as the ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Attribute to sort the results on.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "Name",
                "EffectiveSlaDomainName",
                "SlaAssignment",
                "ConnectionStatus",
                "VappCount"
              ],
              "type": "string"
            }
          },
          {
            "description": "Order for sorting the results, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "default": "asc",
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          {
            "description": "Limit the number of matches returned.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Ignore these many matches in the beginning.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Search object by object name.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by isRelic field of vCD vApp hierarchy object. Return both relic and non-relic descendants if this query is not set.",
            "in": "query",
            "name": "is_relic",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Filter by ID of effective SLA domain.",
            "in": "query",
            "name": "effective_sla_domain_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by node object type.",
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "enum": [
                "Cluster",
                "VimServer",
                "Org",
                "OrgVdc",
                "Catalog",
                "vApp"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filter by primary cluster ID, or **local**.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by SLA assignment type.",
            "in": "query",
            "name": "sla_assignment",
            "required": false,
            "schema": {
              "enum": [
                "Derived",
                "Direct",
                "Unassigned"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filters vCD hierarchy objects based on the specified query value.",
            "in": "query",
            "name": "snappable_status",
            "required": false,
            "schema": {
              "enum": [
                "Protectable"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VcdHierarchyObjectSummaryListResponse"
                }
              }
            },
            "description": "Summary list of descendant objects."
          }
        },
        "summary": "Get list of descendant objects",
        "tags": [
          "/vcd/hierarchy"
        ],
        "x-group": "vcd_hierarchy"
      }
    },
    "/vcd/vapp": {
      "get": {
        "description": "Retrieve summary information for all vCD vApp objects.",
        "operationId": "queryVcdVappsV1",
        "parameters": [
          {
            "description": "Attribute to sort the vCD vApp list on.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "Name",
                "EffectiveSlaDomainName",
                "SlaAssignment"
              ],
              "type": "string"
            }
          },
          {
            "description": "Order for sorting the results, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "default": "asc",
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          {
            "description": "Limit the number of matches returned.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Number of matches to ignore from the beginning of the results.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Search for a vCD vApp object by name.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by isRelic field of vCD vApp object. Return both relic and non-relic vApps when this value is not specified.",
            "in": "query",
            "name": "is_relic",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Filter by ID of the effective SLA domain.",
            "in": "query",
            "name": "effective_sla_domain_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by primary cluster ID, or **local**.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by SLA assignment type.",
            "in": "query",
            "name": "sla_assignment",
            "required": false,
            "schema": {
              "enum": [
                "Derived",
                "Direct",
                "Unassigned"
              ],
              "type": "string"
            }
          },
          {
            "description": "Include backup task information in response.",
            "in": "query",
            "name": "include_backup_task_info",
            "required": false,
            "schema": {
              "default": false,
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VcdVappSummaryListResponse"
                }
              }
            },
            "description": "Summary information for vCD vApps."
          }
        },
        "summary": "Get summary for vApps",
        "tags": [
          "/vcd/vapp"
        ],
        "x-group": "vcd_vapp"
      }
    },
    "/vcd/vapp/request/{id}": {
      "get": {
        "description": "Retrieve the details of a specified asynchronous job for a vApp.",
        "operationId": "getVappAsyncRequestStatusV1",
        "parameters": [
          {
            "description": "ID assigned to an asynchronous job.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of a vApp asynchronous job."
          }
        },
        "summary": "Get vApp job status",
        "tags": [
          "/vcd/vapp"
        ],
        "x-group": "vcd_vapp"
      }
    },
    "/vcd/vapp/snapshot/{id}": {
      "delete": {
        "description": "Designate a vApp snapshot as expired and available for garbage collection. The snapshot must be an on-demand snapshot or a snapshot from a vApp that is not assigned to an SLA Domain.",
        "operationId": "deleteVappSnapshotV1",
        "parameters": [
          {
            "description": "ID assigned to a snapshot object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Location of the snapshot to delete. Use _local_ to delete only the local copy of the snapshot. Use _all_ to delete the snapshot locally, on a replication target, and at an archival location.",
            "in": "query",
            "name": "location",
            "required": true,
            "schema": {
              "enum": [
                "all",
                "local"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Snapshot successfully deleted."
          }
        },
        "summary": "Delete a vApp snapshot",
        "tags": [
          "/vcd/vapp"
        ],
        "x-group": "vcd_vapp"
      },
      "get": {
        "description": "Retrieve detailed information about a specified snapshot for a vApp object.",
        "operationId": "getVappSnapshotV1",
        "parameters": [
          {
            "description": "ID assigned to a snapshot object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VcdVappSnapshotDetail"
                }
              }
            },
            "description": "Details for a vApp snapshot."
          }
        },
        "summary": "Get vApp snapshot details",
        "tags": [
          "/vcd/vapp"
        ],
        "x-group": "vcd_vapp"
      }
    },
    "/vcd/vapp/snapshot/{id}/download": {
      "post": {
        "description": "Provides a method for retrieving a snapshot that is not available locally, from an archival location.",
        "operationId": "createVcdVappDownloadSnapshotFromCloudV1",
        "parameters": [
          {
            "description": "ID of snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the download request."
          }
        },
        "summary": "Download snapshot from archive",
        "tags": [
          "/vcd/vapp"
        ],
        "x-group": "vcd_vapp"
      }
    },
    "/vcd/vapp/snapshot/{snapshot_id}/export": {
      "post": {
        "description": "Export the specified vApp snapshot into a new vApp or an existing vApp.",
        "operationId": "createVappExportV1",
        "parameters": [
          {
            "description": "ID assigned to the vApp snapshot object.",
            "in": "path",
            "name": "snapshot_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VappExportSnapshotJobConfig"
              }
            }
          },
          "description": "Configuration for the request to export the specified vApp snapshot.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Accepted request for asynchronous job to export a vApp snapshot."
          }
        },
        "summary": "Export vApp snapshot",
        "tags": [
          "/vcd/vapp"
        ],
        "x-group": "vcd_vapp"
      }
    },
    "/vcd/vapp/snapshot/{snapshot_id}/export/options": {
      "get": {
        "description": "Retrieve summary information for the vApp networks that are available for network connections from the virtual machines in the exported vApp snapshot. The summary also specifies the default vApp network for each virtual machine network connection.",
        "operationId": "getVappSnapshotExportOptionsV1",
        "parameters": [
          {
            "description": "ID assigned to the vApp snapshot object to export.",
            "in": "path",
            "name": "snapshot_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Target type for the specified vApp export.",
            "in": "query",
            "name": "export_mode",
            "required": true,
            "schema": {
              "enum": [
                "ExportToNewVapp",
                "ExportToTargetVapp"
              ],
              "type": "string"
            }
          },
          {
            "description": "ID assigned to the target vApp object, when the export is into an existing vApp. When the export is not into a target vApp, remove the 'target_vapp_id' member.",
            "in": "query",
            "name": "target_vapp_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "ID assigned to a target organization VDC object. Use the ID when exporting a vApp snapshot to create a new vApp on the specified target organization VDC. When the exported vApp snapshot is not used to create a new vApp on a target organization VDC, remove the 'target_org_vdc_id' member.",
            "in": "query",
            "name": "target_org_vdc_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VappExportOptions"
                }
              }
            },
            "description": "vApp snapshot export options."
          }
        },
        "summary": "Get exportable network configurations",
        "tags": [
          "/vcd/vapp"
        ],
        "x-group": "vcd_vapp"
      }
    },
    "/vcd/vapp/snapshot/{snapshot_id}/instant_recover": {
      "post": {
        "description": "Use Instant Recovery to recover specified vApp virtual machines.",
        "operationId": "createVappInstantRecoveryV1",
        "parameters": [
          {
            "description": "ID assigned to the vApp snapshot object.",
            "in": "path",
            "name": "snapshot_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VappInstantRecoveryJobConfig"
              }
            }
          },
          "description": "Configuration for a request to recover specified virtual machines from a vApp snapshot.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the async request initiated for the Instant Recovery job for virtual machines in a vApp snapshot."
          }
        },
        "summary": "Instant Recovery of vApp virtual machines",
        "tags": [
          "/vcd/vapp"
        ],
        "x-group": "vcd_vapp"
      }
    },
    "/vcd/vapp/snapshot/{snapshot_id}/instant_recover/options": {
      "get": {
        "description": "Retrieve the available vApp network connections and the default vApp network connection for the virtual machines in a vApp snapshot. Use this information to configure an Instant Recovery of specified virtual machines in the vApp snapshot.",
        "operationId": "getVappSnapshotInstantRecoveryOptionsV1",
        "parameters": [
          {
            "description": "ID assigned to a vApp snapshot object.",
            "in": "path",
            "name": "snapshot_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VappInstantRecoveryOptions"
                }
              }
            },
            "description": "vApp Instant Recovery options."
          }
        },
        "summary": "Get Instant Recovery information",
        "tags": [
          "/vcd/vapp"
        ],
        "x-group": "vcd_vapp"
      }
    },
    "/vcd/vapp/template/snapshot/{snapshot_id}/export": {
      "post": {
        "description": "Export a vApp template snapashot to a catalog. Use the options endpoint to confirm that exporting to the catalog defaults or the original organization vDC storage profile is possible.",
        "operationId": "createVappTemplateSnapshotExport",
        "parameters": [
          {
            "description": "ID assigned to a vApp snapshot object.",
            "in": "path",
            "name": "snapshot_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VappTemplateExportJobConfig"
              }
            }
          },
          "description": "Configuration for a request to export a vApp template snapshot to a specific catalog.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Request status for asynchronous Export job for vApp template snapshot."
          }
        },
        "summary": "Export of a vApp template snapshot",
        "tags": [
          "/vcd/vapp"
        ],
        "x-group": "vcd_vapp"
      }
    },
    "/vcd/vapp/template/snapshot/{snapshot_id}/export/options": {
      "get": {
        "description": "Retrieve the available choices vApp template storage profile and organization vDC choices in case of exporting to either original organization vDC defaults of the target catalog. In case advanced option of manually deciding org vdc is preferred, this also provides available storage profile choices.",
        "operationId": "getVappTemplateSnapshotExportOptions",
        "parameters": [
          {
            "description": "ID assigned to a vApp snapshot object.",
            "in": "path",
            "name": "snapshot_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "ID of the target catalog object.",
            "in": "query",
            "name": "catalog_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Name of template object to create. This is used to verify the existence of a template with the given name. Templates must have unique names.",
            "in": "query",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "ID assigned to a target organization vDC object. Use the ID when exporting a vApp template snapshot to a specified organization VDC. This ID is used to fetch the avaiable choices to pick the storage profile of the template. Leave this field empty to use the options from the original organization vDC or the target catalog defaults.",
            "in": "query",
            "name": "org_vdc_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VappTemplateExportOptionsUnion"
                }
              }
            },
            "description": "vApp template snapshot export options."
          }
        },
        "summary": "Get Export information for a vApp template snapshot",
        "tags": [
          "/vcd/vapp"
        ],
        "x-group": "vcd_vapp"
      }
    },
    "/vcd/vapp/{id}": {
      "get": {
        "description": "Retrieve detailed information for a specified vApp.",
        "operationId": "getVcdVappV1",
        "parameters": [
          {
            "description": "ID assigned to a vApp object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VcdVappDetail"
                }
              }
            },
            "description": "Detailed information about a vApp object."
          }
        },
        "summary": "Get details of a specific vApp",
        "tags": [
          "/vcd/vapp"
        ],
        "x-group": "vcd_vapp"
      },
      "patch": {
        "description": "Make changes to the parameters of a specified vApp object.",
        "operationId": "updateVcdVappV1",
        "parameters": [
          {
            "description": "ID assigned to a vApp object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VcdVappPatch"
              }
            }
          },
          "description": "Parameters to use to update the specified vApp object.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VcdVappDetail"
                }
              }
            },
            "description": "Details of an updated vApp object."
          }
        },
        "summary": "Update vApp",
        "tags": [
          "/vcd/vapp"
        ],
        "x-group": "vcd_vapp"
      }
    },
    "/vcd/vapp/{id}/missed_snapshot": {
      "get": {
        "description": "Retrieve the timestamp for each missed snapshot for a specified vApp.",
        "operationId": "vcdMissedSnapshotsV1",
        "parameters": [
          {
            "description": "ID of the vApp.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MissedSnapshotListResponse"
                }
              }
            },
            "description": "Details for missed snapshots for a vApp."
          }
        },
        "summary": "Get details about missed snapshots for a vApp",
        "tags": [
          "/vcd/vapp"
        ],
        "x-group": "vcd_vapp"
      }
    },
    "/vcd/vapp/{id}/search": {
      "get": {
        "description": "Aggregated search for a file through snapshots of all virtual machines that are presently part of the vApp. Specify the file using a full path prefix or a filename prefix.",
        "operationId": "searchVappV1",
        "parameters": [
          {
            "description": "ID of the vApp.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The path query. Use either a path prefix or a filename prefix.",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppSearchResponseListResponse"
                }
              }
            },
            "description": "File search results."
          }
        },
        "summary": "Search for a file in a vApp",
        "tags": [
          "/vcd/vapp"
        ],
        "x-group": "vcd_vapp"
      }
    },
    "/vcd/vapp/{id}/snapshot": {
      "delete": {
        "description": "Delete all snapshots for a specified vApp object.",
        "operationId": "deleteVappSnapshotsV1",
        "parameters": [
          {
            "description": "ID assigned to a vApp object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Snapshots deleted successfully."
          }
        },
        "summary": "Delete all snapshots of vApp",
        "tags": [
          "/vcd/vapp"
        ],
        "x-group": "vcd_vapp"
      },
      "get": {
        "description": "Retrieve summary information for each of the snapshot objects of a specified vApp object.",
        "operationId": "queryVappSnapshotV1",
        "parameters": [
          {
            "description": "ID assigned to a vApp object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VcdVappSnapshotSummaryListResponse"
                }
              }
            },
            "description": "Summary information for all snapshots for a vApp object."
          }
        },
        "summary": "Get list of snapshots of vApp",
        "tags": [
          "/vcd/vapp"
        ],
        "x-group": "vcd_vapp"
      },
      "post": {
        "description": "Start an asynchronous job to create an on-demand snapshot for a specified vApp object.",
        "operationId": "createOnDemandSnapshotV1",
        "parameters": [
          {
            "description": "ID assigned to a vApp object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BaseOnDemandSnapshotConfig"
              }
            }
          },
          "description": "Configuration for the on-demand backup of a specified vApp object."
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the async job for the on-demand snapshot of a vApp."
          }
        },
        "summary": "Create an on-demand snapshot for a vApp",
        "tags": [
          "/vcd/vapp"
        ],
        "x-group": "vcd_vapp"
      }
    },
    "/vmware/compute_cluster": {
      "get": {
        "description": "Get all the clusters belonging to this datacenter.",
        "operationId": "queryComputeCluster",
        "parameters": [
          {
            "description": "Filter clusters on data center ID.",
            "in": "query",
            "name": "datacenter_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter on a primary cluster ID. Also accepts value 'local'.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Determines whether to fetch Compute Clusters with additional privilege checks.",
            "in": "query",
            "name": "snappable_status",
            "required": false,
            "schema": {
              "enum": [
                "Protectable"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ComputeClusterSummaryListResponse"
                }
              }
            },
            "description": "Returns list of compute clusters subject to provided filters."
          }
        },
        "summary": "Get all the clusters belonging to this datacenter",
        "tags": [
          "/vmware/compute_cluster"
        ],
        "x-group": "compute_cluster"
      }
    },
    "/vmware/compute_cluster/request/{id}": {
      "get": {
        "description": "Get the details of an asynchronous request that involves a VMware compute cluster.",
        "operationId": "getAsyncRequestStatusForComputeCluster",
        "parameters": [
          {
            "description": "ID of an asynchronous request.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of an asynchronous request."
          }
        },
        "summary": "Get asynchronous request details for VMware cluster",
        "tags": [
          "/vmware/compute_cluster"
        ],
        "x-group": "compute_cluster"
      }
    },
    "/vmware/compute_cluster/{id}": {
      "get": {
        "description": "Get details for the compute cluster.",
        "operationId": "getComputeCluster",
        "parameters": [
          {
            "description": "ID of the compute cluster.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ComputeClusterDetail"
                }
              }
            },
            "description": "Details of the requested compute cluster."
          }
        },
        "summary": "Get details for the compute cluster",
        "tags": [
          "/vmware/compute_cluster"
        ],
        "x-group": "compute_cluster"
      },
      "patch": {
        "description": "Update the configuredSlaDomainId for a VMware compute cluster with a specific ID.",
        "operationId": "updateComputeCluster",
        "parameters": [
          {
            "description": "ID of the compute cluster.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ComputeClusterUpdate"
              }
            }
          },
          "description": "Object with changes for the Compute Cluster information.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ComputeClusterDetail"
                }
              }
            },
            "description": "Details of the updated compute cluster."
          }
        },
        "summary": "Modify information for a VMware compute cluster",
        "tags": [
          "/vmware/compute_cluster"
        ],
        "x-group": "compute_cluster"
      }
    },
    "/vmware/compute_cluster/{id}/install_io_filter": {
      "post": {
        "description": "Install the latest version of Rubrik ioFilter to the VMware cluster with a specific ID. The cluster must be in maintenance mode to install the ioFilter successfully. The vCenter of the VMware compute cluster must be of version 6.7 and above.",
        "operationId": "installIoFilter",
        "parameters": [
          {
            "description": "ID of the VMware compute cluster.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/FullyQualifiedDomainNameInfo"
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the Rubrik ioFilter installation job."
          },
          "404": {
            "description": "Returned if there is no compute cluster with the given ID."
          }
        },
        "summary": "Install the Rubrik ioFilter to the VMware cluster with a specific ID",
        "tags": [
          "/vmware/compute_cluster"
        ],
        "x-group": "compute_cluster"
      }
    },
    "/vmware/compute_cluster/{id}/io_filter": {
      "get": {
        "description": "Get the summary of the ioFilters on the VMware compute cluster with a specific ID.",
        "operationId": "getIoFilters",
        "parameters": [
          {
            "description": "ID of the VMware compute cluster.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IoFilterSummaryListResponse"
                }
              }
            },
            "description": "List of the ioFilters on the VMware compute cluster."
          },
          "404": {
            "description": "Returned if there is no compute cluster with the given ID."
          }
        },
        "summary": "Get the ioFilters on the VMware compute cluster with a specific ID",
        "tags": [
          "/vmware/compute_cluster"
        ],
        "x-group": "compute_cluster"
      }
    },
    "/vmware/compute_cluster/{id}/uninstall_io_filter": {
      "post": {
        "description": "Uninstall the Rubrik ioFilter from the VMware cluster with a specific ID. The cluster must be in maintenance mode to uninstall the ioFilter successfully. The vCenter of the VMware compute cluster must be of version 6.7 and above.",
        "operationId": "uninstallIoFilter",
        "parameters": [
          {
            "description": "ID of the VMware compute cluster.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the Rubrik ioFilter uninstallation job."
          },
          "404": {
            "description": "Returned if there is no compute cluster with the given id."
          }
        },
        "summary": "Uninstall the Rubrik ioFilter from the VMware cluster with a specific ID",
        "tags": [
          "/vmware/compute_cluster"
        ],
        "x-group": "compute_cluster"
      }
    },
    "/vmware/compute_cluster/{id}/upgrade_io_filter": {
      "post": {
        "description": "Upgrade the Rubrik ioFilter for a VMware cluster with a specific ID. The cluster must be in maintenance mode to upgrade the ioFilter successfully. The vCenter of the VMware compute cluster must be of version 6.7 and above.",
        "operationId": "upgradeIoFilter",
        "parameters": [
          {
            "description": "ID of the VMware compute cluster.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/FullyQualifiedDomainNameInfo"
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the Rubrik ioFilter upgrade."
          },
          "404": {
            "description": "Returned if there is no compute cluster with the given id."
          }
        },
        "summary": "Upgrade the Rubrik ioFilter for the VMware cluster with a specific ID",
        "tags": [
          "/vmware/compute_cluster"
        ],
        "x-group": "compute_cluster"
      }
    },
    "/vmware/config/cdp/get_preferred_cdp_network_protocol": {
      "get": {
        "description": "Returns the current preference of CDM between IPv4 and IPv6 for CDP data transfer.",
        "operationId": "getPreferredCdpNetworkProtocol",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PreferredCdpNetworkProtocolObject"
                }
              }
            },
            "description": "The preferred network protocol to use for transferring CDP data."
          }
        },
        "summary": "Returns the current preference of CDM between IPv4 and IPv6 for CDP data transfer",
        "tags": [
          "/vmware/config"
        ],
        "x-group": "vmware_config"
      }
    },
    "/vmware/config/cdp/set_preferred_cdp_network_protocol": {
      "patch": {
        "description": "Set the current preference of CDM between IPv4 and IPv6 for CDP data transfer.",
        "operationId": "setPreferredCdpNetworkProtocol",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PreferredCdpNetworkProtocol"
              }
            }
          },
          "description": "The preferred network protocol to use for transferring CDP data.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PreferredCdpNetworkProtocolObject"
                }
              }
            },
            "description": "The updated preferred network protocol to transfer CDP data over."
          }
        },
        "summary": "Set the current preference of CDM between IPv4 and IPv6 for CDP data transfer",
        "tags": [
          "/vmware/config"
        ],
        "x-group": "vmware_config"
      }
    },
    "/vmware/config/recovery/networks": {
      "get": {
        "description": "Get all the networks for snapshot recovery for the specified compute resource.",
        "operationId": "getVmwareRecoveryNetworks",
        "parameters": [
          {
            "description": "Get VMware recovery networks for the compute resource ID.",
            "in": "query",
            "name": "compute_resource_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The type of the compute resource.",
            "in": "query",
            "name": "compute_resource_type",
            "required": true,
            "schema": {
              "enum": [
                "ComputeCluster",
                "Host",
                "ResourcePool"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VmwareNetworkCollection"
                }
              }
            },
            "description": "All the VMware networks for the compute resource."
          }
        },
        "summary": "Get all the VMware recovery networks for a compute resource ID",
        "tags": [
          "/vmware/config"
        ],
        "x-group": "vmware_config"
      }
    },
    "/vmware/hierarchy/export": {
      "get": {
        "description": "Get VMware Clusters, Hosts, and Resource Pool hierarchy objects that are available as the target for Virtual Machine Export operations.",
        "operationId": "getVmwareHierarchyExport",
        "parameters": [
          {
            "description": "Get child objects of given root ID.",
            "in": "query",
            "name": "root_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VmwareHierarchyInfoListResponse"
                }
              }
            },
            "description": "Information about Child Hierarchy Objects of Root."
          }
        },
        "summary": "Get Available VMware Hierarchy Objects for Export Operations",
        "tags": [
          "/vmware/hierarchy"
        ],
        "x-group": "vmware_hierarchy"
      }
    },
    "/vmware/hierarchy/{id}/export": {
      "get": {
        "description": "Get VMware Clusters, Hosts, and Resource Pool hierarchy object detail information by object ID.",
        "operationId": "getVmwareHierarchyObject",
        "parameters": [
          {
            "description": "Get VMware hierarchy objects of given ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VmwareHierarchyInfo"
                }
              }
            },
            "description": "VMware hierarchy object details."
          }
        },
        "summary": "Get VMware Hierarchy Object Information",
        "tags": [
          "/vmware/hierarchy"
        ],
        "x-group": "vmware_hierarchy"
      }
    },
    "/vmware/host": {
      "get": {
        "description": "Get summary of all the ESXi hypervisor.",
        "operationId": "queryVmwareHost",
        "parameters": [
          {
            "description": "ID of the Primary cluster.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by ID of Compute Cluster.",
            "in": "query",
            "name": "compute_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Requests additional data about VMware Hosts based on the specified query value.",
            "in": "query",
            "name": "snappable_status",
            "required": false,
            "schema": {
              "enum": [
                "Protectable"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VmwareHostSummaryListResponse"
                }
              }
            },
            "description": "List of VMware host summaries."
          }
        },
        "summary": "Get summary of all the ESXi hypervisor",
        "tags": [
          "/vmware/host"
        ],
        "x-group": "vmware_host"
      }
    },
    "/vmware/host/{id}": {
      "get": {
        "description": "Get details of a ESXi hypervisor.",
        "operationId": "getVmwareHost",
        "parameters": [
          {
            "description": "ID of the VMWare host.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VmwareHostDetail"
                }
              }
            },
            "description": "Details about the vmware host."
          }
        },
        "summary": "Get details of a ESXi hypervisor",
        "tags": [
          "/vmware/host"
        ],
        "x-group": "vmware_host"
      },
      "patch": {
        "description": "Update the SLA Domain that is configured for an ESXi hypervisor.",
        "operationId": "updateVmwareHost",
        "parameters": [
          {
            "description": "ID of the ESXi hypervisor.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VmwareHostUpdate"
              }
            }
          },
          "description": "Object with changes for the ESXi hypervisor information.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VmwareHostDetail"
                }
              }
            },
            "description": "Details for the ESXi hypervisor."
          }
        },
        "summary": "Update the SLA Domain for an ESXi hypervisor",
        "tags": [
          "/vmware/host"
        ],
        "x-group": "vmware_host"
      }
    },
    "/vmware/host/{id}/datastore": {
      "get": {
        "description": "Get details of datastores in a ESXi hypervisor.",
        "operationId": "getVmwareHostDatastore",
        "parameters": [
          {
            "description": "ID of the VMWare host.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VmwareHostDatastoreDetail"
                }
              }
            },
            "description": "Details about the vmware host."
          }
        },
        "summary": "Get details of datastores in a ESXi hypervisor",
        "tags": [
          "/vmware/host"
        ],
        "x-group": "vmware_host"
      }
    },
    "/vmware/vcenter": {
      "get": {
        "description": "Retrieve information for each managed vCenter, including: ID, managed ID, address, username, SLA ID, and primary cluster ID.",
        "operationId": "queryVcenter",
        "parameters": [
          {
            "description": "Limits the information to the Rubrik cluster specified by the value of primary_cluster_id. Use 'local' for the Rubrik cluster that is hosting the current REST API session.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Determines whether to fetch vCenters with additional privilege checks.",
            "in": "query",
            "name": "snappable_status",
            "required": false,
            "schema": {
              "enum": [
                "Protectable"
              ],
              "type": "string"
            }
          },
          {
            "description": "Don't ping vCenters for connection status. The connection_status field in the response is unusable.",
            "in": "query",
            "name": "ignore_connection_status",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VcenterSummaryListResponse"
                }
              }
            },
            "description": "Summary information for managed vCenters."
          }
        },
        "summary": "Get list of vCenters",
        "tags": [
          "/vmware/vcenter"
        ],
        "x-group": "vcenter"
      },
      "post": {
        "description": "(DEPRECATED) Create a vCenter Server object by providing the address and account credentials of the vCenter Server. Initiates an asynchronous job to establish a connection with the vCenter Server and retrieve all metadata. Use GET /vcenter/{id}/status to check status. The recommended endpoint is /v2/vmware/vcenter. This endpoint will remain available in future releases despite deprecation.",
        "operationId": "createVcenter",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VcenterConfig"
              }
            }
          },
          "description": "IP address and account credentials of the vCenter Server server, and ID of the managing Rubrik cluster.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status for the add vCenter Server request."
          }
        },
        "summary": "Add vCenter Server",
        "tags": [
          "/vmware/vcenter"
        ],
        "x-group": "vcenter"
      }
    },
    "/vmware/vcenter/hotadd/vm": {
      "get": {
        "description": "Retrieve summary information for all HotAdd proxy virtual machines.",
        "operationId": "queryHotAddProxyVm",
        "parameters": [
          {
            "description": "Limit the list information to HotAdd proxy virtual machines that match the specified HotAdd proxy virtual machine 'name' value.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Attribute to use to sort the HotAdd proxy virtual machines summary information. Optionally use **_sort_order_** to specify whether to sort in ascending or descending order.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "name"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort order, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HotAddProxyVmInfoListResponse"
                }
              }
            },
            "description": "Summary information for HotAdd proxy virtual machines."
          }
        },
        "summary": "Get a list of HotAdd proxy virtual machines",
        "tags": [
          "/vmware/vcenter"
        ],
        "x-group": "vcenter"
      }
    },
    "/vmware/vcenter/request/{id}": {
      "get": {
        "description": "Get details about a vcenter related async request.",
        "operationId": "getVcenterAsyncRequestStatus",
        "parameters": [
          {
            "description": "ID of the request.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status for the async request."
          }
        },
        "summary": "Get vCenter Server async request",
        "tags": [
          "/vmware/vcenter"
        ],
        "x-group": "vcenter"
      }
    },
    "/vmware/vcenter/{id}": {
      "delete": {
        "description": "Initiates an asynchronous job to remove a vCenter Server object. The vCenter Server cannot have VMs mounted through the Rubrik cluster.",
        "operationId": "deleteVcenter",
        "parameters": [
          {
            "description": "ID of the vCenter Server. to remove.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status for the async request."
          }
        },
        "summary": "Remove vCenter Server",
        "tags": [
          "/vmware/vcenter"
        ],
        "x-group": "vcenter"
      },
      "get": {
        "description": "Retrieve detailed information for a vCenter Server object.",
        "operationId": "getVcenter",
        "parameters": [
          {
            "description": "ID of the vCenter Server.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VcenterDetail"
                }
              }
            },
            "description": "Details for a vCenter Server object."
          }
        },
        "summary": "Get the details of a vCenter Server",
        "tags": [
          "/vmware/vcenter"
        ],
        "x-group": "vcenter"
      },
      "patch": {
        "description": "Update the SLA Domain that is configured for a vCenter Server.",
        "operationId": "patchVcenter",
        "parameters": [
          {
            "description": "ID of the vCenter Server.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VcenterPatch"
              }
            }
          },
          "description": "Object containing updated vCenter Server information.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VcenterSummary"
                }
              }
            },
            "description": "Summary of the updated vCenter Server object."
          }
        },
        "summary": "Update the SLA Domain for a vCenter Server",
        "tags": [
          "/vmware/vcenter"
        ],
        "x-group": "vcenter"
      },
      "put": {
        "description": "Update the address, username and password of the specified vCenter Server object.",
        "operationId": "updateVcenter",
        "parameters": [
          {
            "description": "ID of the vCenter Server.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VcenterConfig"
              }
            }
          },
          "description": "Object containing updated vCenter Server information.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VcenterSummary"
                }
              }
            },
            "description": "Summary of the updated vCenter Server object."
          }
        },
        "summary": "Update vCenter Server",
        "tags": [
          "/vmware/vcenter"
        ],
        "x-group": "vcenter"
      }
    },
    "/vmware/vcenter/{id}/hotadd/bandwidth": {
      "get": {
        "description": "Get the ingest and export bandwidth limits in Mbps when using HotAdd with the vCenter. These limits are shared across all HotAdd proxies for the Center.",
        "operationId": "getHotAddBandwidth",
        "parameters": [
          {
            "description": "The ID of the vCenter server from which to derive the number of proxies needed.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HotAddBandwidthInfo"
                }
              }
            },
            "description": "Ingest and export bandwidth limits for the vCenter."
          }
        },
        "summary": "Get the ingest and export bandwidth limits for HotAdd with the vCenter",
        "tags": [
          "/vmware/vcenter"
        ],
        "x-group": "vcenter"
      },
      "post": {
        "description": "Set the ingest and export bandwidth limits in Mbps when using HotAdd with the vCenter. These limits are shared across all HotAdd proxies for the Center.",
        "operationId": "setHotAddBandwidth",
        "parameters": [
          {
            "description": "ID of the vCenter server upon which the Rubrik cluster is setting the HotAdd bandwidth limits.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HotAddBandwidthInfo"
              }
            }
          },
          "description": "The ingest and export bandwidth limits for the vCenter.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "The bandwidth was set correctly."
          }
        },
        "summary": "Set the ingest and export bandwidth limits for HotAdd with the vCenter",
        "tags": [
          "/vmware/vcenter"
        ],
        "x-group": "vcenter"
      }
    },
    "/vmware/vcenter/{id}/hotadd/needed": {
      "get": {
        "description": "Get the number of HotAdd proxies that need to be deployed to the vCenter to support the maximum number of ingest jobs.",
        "operationId": "getNumProxiesNeeded",
        "parameters": [
          {
            "description": "The ID of the vCenter server for which to get the number of proxies needed.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HotAddProxiesNeededInfo"
                }
              }
            },
            "description": "Number of HotAdd proxies needed for the vCenter."
          }
        },
        "summary": "Get the number of HotAdd proxies needed for the vCenter",
        "tags": [
          "/vmware/vcenter"
        ],
        "x-group": "vcenter"
      }
    },
    "/vmware/vcenter/{id}/hotadd/network": {
      "get": {
        "description": "Retrieve the user-configured network for HotAdd backup and recovery operations on VMware on AWS.",
        "operationId": "getHotAddNetwork",
        "parameters": [
          {
            "description": "ID of the vCenter server for which the Rubrik cluster is retrieving the configured HotAdd network information.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HotAddNetworkConfigWithName"
                }
              }
            },
            "description": "Configured network information for the HotAdd proxy virtual machines."
          }
        },
        "summary": "Retrieve the user-configured network for HotAdd operations",
        "tags": [
          "/vmware/vcenter"
        ],
        "x-group": "vcenter"
      },
      "post": {
        "description": "Set the user-configured network for HotAdd backup and recovery operations on VMware on AWS.",
        "operationId": "setHotAddNetwork",
        "parameters": [
          {
            "description": "ID of the vCenter server for which the Rubrik cluster is setting the HotAdd network information.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HotAddNetworkConfigWithId"
              }
            }
          },
          "description": "The information about a static IP address and user-configured vCenter network selected for HotAdd backup and recovery.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "The network was set correctly."
          }
        },
        "summary": "Set the user-configured network for HotAdd backup and recovery",
        "tags": [
          "/vmware/vcenter"
        ],
        "x-group": "vcenter"
      }
    },
    "/vmware/vcenter/{id}/networks": {
      "get": {
        "description": "Get the names and IDs of the user configured networks in the vCenter. This information enables users to choose a desired network for backups to go through for VMware Cloud on AWS setups.",
        "operationId": "getNetworks",
        "parameters": [
          {
            "description": "The ID of the vCenter server for which to retrieve user-configured networks.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NetworkInfoListResponse"
                }
              }
            },
            "description": "List of network IDs and Names."
          }
        },
        "summary": "Get the user-configured networks in the vCenter",
        "tags": [
          "/vmware/vcenter"
        ],
        "x-group": "vcenter"
      }
    },
    "/vmware/vcenter/{id}/refresh": {
      "post": {
        "description": "Create a job to refresh the metadata for the specified vCenter Server.",
        "operationId": "createRefresh",
        "parameters": [
          {
            "description": "ID of the vCenter Server.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Job Instance ID of the scheduled vCenter Server refresh job."
          }
        },
        "summary": "Refresh vCenter Server metadata",
        "tags": [
          "/vmware/vcenter"
        ],
        "x-group": "vcenter"
      }
    },
    "/vmware/vcenter/{id}/refresh_vm": {
      "post": {
        "description": "Refresh the metadata for a single virtual machine controlled by vCenter.",
        "operationId": "createRefreshVmV1",
        "parameters": [
          {
            "description": "The ID of the vCenter server that controls the management of the virtual machine whose metadata will be refreshed.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "string"
              }
            }
          },
          "description": "The vCenter managed object ID (MOID) of the virtual machine whose metadata will be refreshed.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "The virtual machine metadata was refreshed successfully."
          }
        },
        "summary": "Refresh single virtual machine metadata in a vcenter",
        "tags": [
          "/vmware/vcenter"
        ],
        "x-group": "vcenter"
      }
    },
    "/vmware/vm": {
      "get": {
        "description": "Get summary of all the VMs.",
        "operationId": "queryVm",
        "parameters": [
          {
            "description": "Filter by ID of effective SLA Domain.",
            "in": "query",
            "name": "effective_sla_domain_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by primary cluster ID, or **local**.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limit the number of matches returned.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Ignore these many matches in the beginning.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Filter by the isRelic field of the virtual machine. When this parameter is not set, return both relic and non-relic virtual machines.",
            "in": "query",
            "name": "is_relic",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Search by using a virtual machine name.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Search by using a virtual machine managed object ID.",
            "in": "query",
            "name": "moid",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by SLA Domain assignment type.",
            "in": "query",
            "name": "sla_assignment",
            "required": false,
            "schema": {
              "enum": [
                "Derived",
                "Direct",
                "Unassigned"
              ],
              "type": "string"
            }
          },
          {
            "description": "Filters by the name of operating system using infix search.",
            "in": "query",
            "name": "guest_os_name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Sort results based on the specified attribute.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "effectiveSlaDomainName",
                "name",
                "moid",
                "folderPath",
                "infraPath"
              ],
              "type": "string"
            }
          },
          {
            "description": "Sort order, either ascending or descending.",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VirtualMachineSummaryListResponse"
                }
              }
            },
            "description": "Virtual machine summary."
          }
        },
        "summary": "Get list of VMs",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/batch_mount": {
      "post": {
        "operationId": "batchMountSnapshot",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BatchMountSnapshotJobConfig"
              }
            }
          },
          "description": "Configuration object containing an array of virtual machine IDs, a way to indicate the snapshot to be chosen and mount configs.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchAsyncRequestStatus"
                }
              }
            },
            "description": "Status of the Live Mount requests."
          }
        },
        "summary": "Live mount a snapshot each from a set of virtual machines",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/cdp": {
      "post": {
        "operationId": "getVmwareCdpLiveInfo",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "description": "ID of the CDP-enabled virtual machine.",
                  "type": "string"
                },
                "type": "array"
              }
            }
          },
          "description": "The ID of each CDP-enabled virtual machine for which live info is being retrieved.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchVmwareCdpLiveInfo"
                }
              }
            },
            "description": "Returns the live CDP info for the CDP-enabled virtual machines."
          }
        },
        "summary": "Returns the live CDP info for a set of CDP-enabled virtual machines",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/cdp_state": {
      "post": {
        "operationId": "getVmwareCdpStateInfo",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "description": "ID of the virtual machine.",
                  "type": "string"
                },
                "type": "array"
              }
            }
          },
          "description": "The ID of each virtual machine for which CDP state info is being retrieved.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchVmwareCdpStateInfo"
                }
              }
            },
            "description": "Returns CDP state info for the virtual machines."
          }
        },
        "summary": "Returns CDP state info for a set of virtual machines",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/make_primary": {
      "post": {
        "description": "Migrate the primary cluster with which the agent is able to communicate. For disaster recovery when migrating everything over from another cluster, the /host/make_primary endpoint can be used with the oldPrimaryClusterUuid parameter.",
        "operationId": "vmMakePrimary",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            }
          },
          "description": "IDs of hosts to migrate.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Asynchronous request for making this cluster primary."
          }
        },
        "summary": "Make this cluster the primary for agents on a set of VMs",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/missed_recoverable_range": {
      "post": {
        "operationId": "getVmwareVmMissedRecoverableRangesInBatch",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BatchVmwareVmMissedRecoverableRangesRequest"
              }
            }
          },
          "description": "The batch request and the date ranges (optional) as a filter. The batch request includes the ID of each CDP-enabled virtual machine for which missed recoverable ranges are being retrieved.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchVmwareVmMissedRecoverableRanges"
                }
              }
            },
            "description": "Returns the missed recoverable ranges for a set of CDP-enabled virtual machines."
          }
        },
        "summary": "Returns the recoverable ranges that were missed for a set of CDP-enabled virtual machines",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/recoverable_range": {
      "post": {
        "operationId": "getVmwareVmRecoverableRangesInBatch",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BatchVmwareVmRecoverableRangesRequest"
              }
            }
          },
          "description": "The batch request, which includes the ID of each CDP-enabled virtual machine for which recoverable ranges are being retrieved, and optionally the date ranges as a filter.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchVmwareVmRecoverableRanges"
                }
              }
            },
            "description": "Returns the recoverable ranges for a set of CDP-enabled virtual machines."
          }
        },
        "summary": "Returns the recoverable ranges for a set of CDP-enabled virtual machines",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/request/{id}": {
      "get": {
        "description": "Get the details of an asynchronous request that involves a VMware virtual machine.",
        "operationId": "getAsyncRequestStatus",
        "parameters": [
          {
            "description": "ID of an asynchronous request.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of an asynchronous request."
          }
        },
        "summary": "Get asynchronous request details for VM",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/snapshot/bulk": {
      "post": {
        "description": "Bulk operation of taking on-demand snapshot for given virtual machines.",
        "operationId": "bulkCreateOnDemandBackup",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BulkOnDemandSnapshotJobConfig"
              }
            }
          },
          "description": "The IDs of the virtual machines for which to take an on-demand snapshot and the ID of the SLA Domain to assign to the resulting snapshot.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchAsyncRequestStatus"
                }
              }
            },
            "description": "Status of the on-demand backup requests."
          }
        },
        "summary": "Take an on-demand snapshot of multiple virtual machines",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/snapshot/mount": {
      "get": {
        "description": "Retrieve summary information about Live Mount activity.",
        "operationId": "queryMountV1",
        "parameters": [
          {
            "description": "Filters information by virtual machine ID.",
            "in": "query",
            "name": "vm_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Starting position in the list of Live Mount entries contained in the response. The summary information includes the specified numbered entry and all higher numbered entries. Use with **_limit_** to retrieve the summary information as smaller groups of entries, e.g. for paging of the results.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Limit the summary information to a specified maximum number of entries. Optionally, use with **_offset_** to start the count at a specified point. Default is 25.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VmwareVmMountSummaryV1ListResponse"
                }
              }
            },
            "description": "Summary information for all Live Mounts."
          }
        },
        "summary": "Get Live Mount information",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/snapshot/mount/{id}": {
      "delete": {
        "description": "Create a request to delete a Live Mount virtual machine.",
        "operationId": "createUnmount",
        "parameters": [
          {
            "description": "ID of a Live Mount.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Force unmount to remove metadata when the datastore of the Live Mount virtual machine was moved off of the Rubrik cluster.",
            "in": "query",
            "name": "force",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the delete request."
          }
        },
        "summary": "Delete a Live Mount VM",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      },
      "get": {
        "description": "Retrieve detailed information for a specified Live Mount.",
        "operationId": "getMountV1",
        "parameters": [
          {
            "description": "ID of a Live Mount.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VmwareVmMountDetailV1"
                }
              }
            },
            "description": "Detailed information for the specified Live Mount."
          }
        },
        "summary": "Get information for a Live Mount",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      },
      "patch": {
        "description": "Power a specified Live Mount virtual machine on or off. Pass **_true_** to power the virtual machine on and pass **_false_** to power the virtual machine off.",
        "operationId": "updateMount",
        "parameters": [
          {
            "description": "ID of a Live Mount.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateMountConfig"
              }
            }
          },
          "description": "Power state configuration.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VmwareVmMountDetailV1"
                }
              }
            },
            "description": "Details of the Live Mount."
          }
        },
        "summary": "Power a Live Mount on and off",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/snapshot/mount/{id}/relocate": {
      "post": {
        "description": "Run storage VMotion to relocate a specified Live Mount into another data store.",
        "operationId": "relocateMount",
        "parameters": [
          {
            "description": "ID of the live mount.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RelocateMountConfig"
              }
            }
          },
          "description": "Configuration for the RelocateMount request to another data store.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of an asynchronous request to migrate datastore."
          }
        },
        "summary": "Relocate a virtual machine to another datastore",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/snapshot/{id}": {
      "delete": {
        "description": "Designate a snapshot as expired and available for garbage collection. The snapshot must be an on-demand snapshot or a snapshot from a virtual machine that is not assigned to an SLA Domain.",
        "operationId": "deleteVmwareSnapshot",
        "parameters": [
          {
            "description": "ID of snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Location of the snapshot. Use **_local_** to delete only the local copy of the snapshot. Or use **_all_** to delete the snapshot locally, on a replication target, and at an archival location.",
            "in": "query",
            "name": "location",
            "required": true,
            "schema": {
              "enum": [
                "all",
                "local"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Snapshot successfully deleted."
          }
        },
        "summary": "Delete VM snapshot",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      },
      "get": {
        "description": "Retrieve detailed information about a virtual machine snapshot.",
        "operationId": "getSnapshot",
        "parameters": [
          {
            "description": "ID of a snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VmSnapshotDetail"
                }
              }
            },
            "description": "Snapshot details."
          }
        },
        "summary": "Get VM snapshot details",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/snapshot/{id}/browse": {
      "get": {
        "description": "For a virtual machine snapshot, list the directories and files that are beneath a specified file system path.",
        "operationId": "browseVmwareSnapshot",
        "parameters": [
          {
            "description": "ID of snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The absolute path of the starting point for the directory listing.",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Starting position in the list of path entries contained in the query results, sorted by lexicographical order. The response includes the specified numbered entry and all higher numbered entries.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "type": "integer"
            }
          },
          {
            "description": "Maximum number of entries in the response.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BrowseResponseListResponse"
                }
              }
            },
            "description": "List of files and directories at the specified path."
          }
        },
        "summary": "List files in VM snapshot",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/snapshot/{id}/download": {
      "post": {
        "description": "Provides a method for retrieving a snapshot, that is not available locally, from an archival location.",
        "operationId": "createDownloadSnapshotFromCloud",
        "parameters": [
          {
            "description": "ID of snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status for the download request."
          }
        },
        "summary": "Download snapshot from archive",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/snapshot/{id}/download_file": {
      "post": {
        "description": "Create a request to download a file from a virtual machine snapshot.",
        "operationId": "createDownloadFileJob",
        "parameters": [
          {
            "description": "ID of a snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DownloadFileJobConfig"
              }
            }
          },
          "description": "Configuration for the file download request.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the file download request."
          }
        },
        "summary": "Download file from VM snapshot",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/snapshot/{id}/export": {
      "post": {
        "description": "Export a virtual machine from a snapshot, using a specified hypervisor host as the datastore.",
        "operationId": "createExportV1",
        "parameters": [
          {
            "description": "ID of a snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ExportSnapshotJobConfigV1"
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the export request."
          }
        },
        "summary": "Export VM snapshot",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/snapshot/{id}/export_with_download": {
      "post": {
        "description": "Download a snapshot from an archival location and then export a virtual machine using the downloaded snapshot.",
        "operationId": "createExportWithDownloadFromCloudV1",
        "parameters": [
          {
            "description": "ID of a snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ExportSnapshotJobConfigV1"
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the download request."
          }
        },
        "summary": "Download a snapshot from an archival location, then export a virtual machine using the downloaded snapshot",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/snapshot/{id}/instant_recover": {
      "post": {
        "description": "Instantly recovery a virtual machine from a snapshot. The Instant Recovery request starts the virtual machine with networking enabled and renames and powers off the source virtual machine, if it still exists.",
        "operationId": "createInstantRecovery",
        "parameters": [
          {
            "description": "ID of Snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InstantRecoveryJobConfig"
              }
            }
          },
          "description": "Configuration for the Instant Recovery request.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the Instant Recovery request."
          }
        },
        "summary": "Instantly recover a VM",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/snapshot/{id}/mount": {
      "post": {
        "description": "Create a request to Live Mount a virtual machine from a snapshot using a specified configuration.",
        "operationId": "createMountV1",
        "parameters": [
          {
            "description": "ID of a snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MountSnapshotJobConfigV1"
              }
            }
          },
          "description": "Configuration for the Live Mount request."
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the Live Mount request."
          }
        },
        "summary": "Live mount a VM from a snapshot",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/snapshot/{id}/restore_file": {
      "post": {
        "description": "Create a request to restore a file or folder to the source virtual machine.",
        "operationId": "createRestoreFileJob",
        "parameters": [
          {
            "description": "ID of a snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RestoreFileJobConfig"
              }
            }
          },
          "description": "Configuration for the restore request.",
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status of the restore request."
          }
        },
        "summary": "Restore file from VM snapshot",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/snapshots": {
      "post": {
        "description": "Retrieve snapshot summaries for a list of virtual machines.",
        "operationId": "querySnapshotsForVms",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "description": "ID of the virtual machine.",
                  "type": "string"
                },
                "type": "array"
              }
            }
          },
          "description": "IDs of the virtual machines.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchVmSnapshotSummaries"
                }
              }
            },
            "description": "Snapshot summaries for a list of virtual machines."
          }
        },
        "summary": "Get snapshot information for a list of virtual machines",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/virtual_disk/{id}": {
      "get": {
        "description": "Detailed about the specific Virtual Disk.",
        "operationId": "getVirtualDisk",
        "parameters": [
          {
            "description": "ID of the Virtual Disk.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VirtualDiskDetail"
                }
              }
            },
            "description": "Return details about the virtual disk."
          }
        },
        "summary": "Details about the specific Virtual Disk",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "virtual_disk"
      },
      "patch": {
        "description": "Update a specific Virtual Disk.",
        "operationId": "updateVirtualDisk",
        "parameters": [
          {
            "description": "ID of the Virtual Disk.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VirtualDiskUpdate"
              }
            }
          },
          "description": "Virtual Disk update information.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VirtualDiskDetail"
                }
              }
            },
            "description": "The updated Virtual Disk."
          }
        },
        "summary": "Update a specific Virtual Disk",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "virtual_disk"
      }
    },
    "/vmware/vm/{id}": {
      "get": {
        "description": "Retrieve details for a virtual machine.",
        "operationId": "getVm",
        "parameters": [
          {
            "description": "ID of the virtual machine.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VirtualMachineDetail"
                }
              }
            },
            "description": "Virtual machine details."
          }
        },
        "summary": "Get VM details",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      },
      "patch": {
        "description": "Update a virtual machine with specified properties. Use the guestCredential field to update the guest credential for a specified virtual machine.",
        "operationId": "updateVm",
        "parameters": [
          {
            "description": "ID of virtual machine.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VirtualMachineUpdateWithSecret"
              }
            }
          },
          "description": "Properties to update.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VirtualMachineDetail"
                }
              }
            },
            "description": "Virtual machine details."
          }
        },
        "summary": "Update VM",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/{id}/guest_script/run": {
      "post": {
        "description": "Run the specified preBackup, postSnap, or postBackup script in the guest OS of a virtual machine. The script must exist and meet requirements.",
        "operationId": "runGuestOsScript",
        "parameters": [
          {
            "description": "ID of the virtual machine.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VmGuestScriptRunConfig"
              }
            }
          },
          "description": "Configuration used to run the specified preBackup, postSnap, or postBackup guest OS script.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "Guest OS script ran successfully and returned a 0 exit code."
          }
        },
        "summary": "Run guest OS script",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/{id}/missed_recoverable_range": {
      "get": {
        "description": "Gets a list of time ranges to which a CDP-enabled virtual machine cannot perform a point-in-time recovery. The time ranges are indicated by start and end timestamps listed as date-time strings.",
        "operationId": "getVmwareMissedRecoverableRanges",
        "parameters": [
          {
            "description": "The virtual machine ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter ranges to end after this time. The date-time string should be in ISO8601 format, such as `2018-01-01T01:23:45.678Z`.",
            "in": "query",
            "name": "after_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "Filter ranges to start before this time. The date-time string should be in ISO8601 format, such as `2018-01-01T01:23:45.678Z`.",
            "in": "query",
            "name": "before_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VmwareRecoverableRangeListResponse"
                }
              }
            },
            "description": "Returns the missed recoverable ranges for the virtual machine."
          }
        },
        "summary": "Get missed time ranges for point in time recovery",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/{id}/missed_snapshot": {
      "get": {
        "description": "Retrieve details about the missed snapshots for a virtual machine.",
        "operationId": "missedSnapshots",
        "parameters": [
          {
            "description": "ID of a virtual machine.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MissedSnapshotListResponse"
                }
              }
            },
            "description": "Missed snapshot details for a virtual machine."
          }
        },
        "summary": "Get details about missed snapshots for a VM",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/{id}/recoverable_range": {
      "get": {
        "description": "Gets time ranges available for point-in-time recovery. The time ranges are indicated by start and end date-time strings.",
        "operationId": "getVmwareRecoverableRanges",
        "parameters": [
          {
            "description": "The virtual machine ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter ranges to end after this time. The date-time string should be in ISO8601 format, such as `2018-01-01T01:23:45.678Z`.",
            "in": "query",
            "name": "after_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "description": "Filter ranges to start before this time. The date-time string should be in ISO8601 format, such as `2018-01-01T01:23:45.678Z`.",
            "in": "query",
            "name": "before_time",
            "required": false,
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VmwareRecoverableRangeListResponse"
                }
              }
            },
            "description": "Returns the recoverable ranges for the virtual machine."
          }
        },
        "summary": "Get available time ranges for point in time recovery",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/{id}/register_agent": {
      "post": {
        "description": "Register the Rubrik Backup Service that is running on a specified host with the specified Rubrik cluster.",
        "operationId": "vmRegisterAgent",
        "parameters": [
          {
            "description": "ID assigned to a virtual machine object.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully registered the Rubrik Backup Service for a specified virtual machine."
          }
        },
        "summary": "Register Rubrik Backup Service",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/{id}/request/force_full_snapshot": {
      "get": {
        "description": "Retrieve the configuration that has been set for forcing a full snapshot for a VMware virtual machine.",
        "operationId": "getVmForceFullSpec",
        "parameters": [
          {
            "description": "ID of the VMware virtual machine.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VmForceFullResponse"
                }
              }
            },
            "description": "Return the configuration for forcing a full snapshot for the VMware virtual machine."
          }
        },
        "summary": "Retrieve the configuration for forcing a full snapshot of a VMware virtual machine",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      },
      "post": {
        "description": "Request a full snapshot to be taken for the next backup job of a VMware virtual machine.",
        "operationId": "requestVmForceFullSnapshot",
        "parameters": [
          {
            "description": "ID of the VMware virtual machine.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VmForceFullRequest"
              }
            }
          },
          "description": "Configuration for forcing a full snapshot on the VMware virtual machine.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VmForceFullResponse"
                }
              }
            },
            "description": "Returns the response to the request for a forced full snapshot."
          }
        },
        "summary": "Request a full snapshot for the next backup job of a VMware virtual machine",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/{id}/search": {
      "get": {
        "description": "Search for a file in the snapshots of a a virtual machine. Specify the file by full path prefix or filename prefix.",
        "operationId": "searchVm",
        "parameters": [
          {
            "description": "ID of the virtual machine.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The path query. Use either a path prefix or a filename prefix.",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Maximum number of entries in the response.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "type": "integer"
            }
          },
          {
            "description": "Pagination cursor returned by the previous request.",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResponseListResponse"
                }
              }
            },
            "description": "File search results."
          }
        },
        "summary": "Search for a file from a VM",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/vmware/vm/{id}/snapshot": {
      "delete": {
        "description": "Delete all of the snapshots from a virtual machine.",
        "operationId": "deleteVmwareSnapshots",
        "parameters": [
          {
            "description": "Virtual machine ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Snapshots successfully deleted."
          }
        },
        "summary": "Delete all snapshots of VM",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      },
      "get": {
        "description": "Retrieve summary information for the snapshots of a virtual machine.",
        "operationId": "querySnapshot",
        "parameters": [
          {
            "description": "ID of the virtual machine.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VmSnapshotSummaryListResponse"
                }
              }
            },
            "description": "Summary snapshot information for a virtual machine."
          }
        },
        "summary": "Get list of snapshots of VM",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      },
      "post": {
        "description": "Use the ID of a virtual machine to create an on-demand snapshot.",
        "operationId": "createOnDemandBackup",
        "parameters": [
          {
            "description": "ID of the virtual machine.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BaseOnDemandSnapshotConfig"
              }
            }
          },
          "description": "Configuration for the on-demand snapshot."
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "On-demand snapshot status."
          }
        },
        "summary": "Create an on-demand snapshot for a VM",
        "tags": [
          "/vmware/vm"
        ],
        "x-group": "vm"
      }
    },
    "/volume_group": {
      "get": {
        "description": "Get summary of all Volume Groups.",
        "operationId": "queryVolumeGroup",
        "parameters": [
          {
            "description": "The ID of the SLA Domain that controls the protection of the Volume Group.",
            "in": "query",
            "name": "effective_sla_domain_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The ID of the Rubrik cluster that provides primary protection for the Volume Group.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Limit the number of matches returned.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Ignore these many matches in the beginning.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Specifies whether the results should contain only Volume Groups that are accessible on the Rubrik cluster.",
            "in": "query",
            "name": "is_relic",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "The name of the Volume Group.",
            "in": "query",
            "name": "name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The type of SLA assigned to the Volume Group.",
            "in": "query",
            "name": "sla_assignment",
            "required": false,
            "schema": {
              "enum": [
                "Derived",
                "Direct",
                "Unassigned"
              ],
              "type": "string"
            }
          },
          {
            "description": "The Volume Group attribute to use in storing the responses. Valid attributes are `name` and `effectiveSlaDomainName`.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "default": "name",
              "enum": [
                "name",
                "effectiveSlaDomainName"
              ],
              "type": "string"
            }
          },
          {
            "description": "The order to sort the responses. Valid choices are asc (ascending) or desc (descending).",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "default": "asc",
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VolumeGroupSummaryListResponse"
                }
              }
            },
            "description": "Get Volume Groups summary list."
          }
        },
        "summary": "Get list of Volume Groups",
        "tags": [
          "/volume_group"
        ],
        "x-group": "volume_group"
      }
    },
    "/volume_group/snapshot/mount": {
      "get": {
        "description": "Retrieves information for each Volume Group mount. The information returned includes the following items, when available. id (the unique ID of the mount), name (the name of the Volume Group), snapshotDate (the snapshot date), sourceVolumeGroupId (the ID of the Volume Group from which this snapshot was created), sourceHostId (the ID of the source host), sourceHostName (the name of the source host), mountedDate (the date when the mount was created), mountedVolumes (information on the mounted volumes), targetHostId (the ID of the mounted volumes host), targetHostName (the name of the mounted volumes host), mountRequestId (the ID of the job instance that initiated the mount), unmountRequestId (the ID of the job instance that initiated the request to remove the mount), isReady (whether the Volume Group mount is ready to use), and restoreScriptSmbPath (the link to the script that can perform bare-metal recovery).",
        "operationId": "queryVolumeGroupSnapshotMount",
        "parameters": [
          {
            "description": "The ID of the source Volume Group.",
            "in": "query",
            "name": "source_volume_group_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A prefix of the source host name. The prefix is used as a response filter when available.",
            "in": "query",
            "name": "source_host_name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The Volume Group mount attribute used in sorting the responses. Valid choices are name, sourceHostName, snapshotDate, and mountedDate.",
            "in": "query",
            "name": "sort_by",
            "required": false,
            "schema": {
              "enum": [
                "name",
                "sourceHostName",
                "snapshotDate",
                "mountedDate"
              ],
              "type": "string"
            }
          },
          {
            "description": "The order to sort the responses. Valid choices are asc (ascending) or desc (descending).",
            "in": "query",
            "name": "sort_order",
            "required": false,
            "schema": {
              "default": "asc",
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          {
            "description": "Ignore these many matches in the beginning.",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Limit the number of matches returned. The default value is 25.",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "int32",
              "minimum": 0,
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VolumeGroupMountSummaryListResponse"
                }
              }
            },
            "description": "Returns summary information for all mounts."
          }
        },
        "summary": "Get summary information for all mounts",
        "tags": [
          "/volume_group"
        ],
        "x-group": "volume_group"
      }
    },
    "/volume_group/snapshot/mount/{id}": {
      "get": {
        "description": "Retrieve information on a Volume Group mount. The information returned includes the following items, when available. id (the unique ID of the mount), name (the name of the Volume Group), snapshotDate (the snapshot date), sourceVolumeGroupId (The ID of the Volume Group from which this snapshot was created), sourceHostId (the ID of the source host), sourceHostName (the name of the source host), mountedDate (the date when the mount was created), mountedVolumes (the mounted volumes information), targetHostId (the ID of the mounted volumes host), targetHostName (the name of the mounted volumes host), mountRequestId (the ID of the job instance that initiated the mount), unmountRequestId (the ID of the job instance that intiated the request to remove the mount), isReady (whether the Volume Group mount is ready to use), and restoreScriptSmbPath (the link to the script that can perform bare-metal recovery).",
        "operationId": "getVolumeGroupSnapshotMount",
        "parameters": [
          {
            "description": "The ID of the Volume Group mount.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VolumeGroupMountSummary"
                }
              }
            },
            "description": "Returns detail information for a specified live mount."
          }
        },
        "summary": "Get summary information for a mount",
        "tags": [
          "/volume_group"
        ],
        "x-group": "volume_group"
      }
    },
    "/volume_group/snapshot/{id}": {
      "get": {
        "description": "Retrieve detailed information about a snapshot.",
        "operationId": "getVolumeGroupSnapshot",
        "parameters": [
          {
            "description": "The ID of the Volume Group snapshot.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VolumeGroupSnapshotDetail"
                }
              }
            },
            "description": "Returns details about a snapshot."
          }
        },
        "summary": "Get Volume Group snapshot details",
        "tags": [
          "/volume_group"
        ],
        "x-group": "volume_group"
      }
    },
    "/volume_group/{id}": {
      "get": {
        "description": "Detailed view of a Volume Group.",
        "operationId": "getVolumeGroup",
        "parameters": [
          {
            "description": "The ID of the Volume Group.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VolumeGroupDetail"
                }
              }
            },
            "description": "Return details about the Volume Group."
          }
        },
        "summary": "Get Volume Group details",
        "tags": [
          "/volume_group"
        ],
        "x-group": "volume_group"
      },
      "patch": {
        "description": "Patch Volume Group with specified properties.",
        "operationId": "patchVolumeGroup",
        "parameters": [
          {
            "description": "The ID of Volume Group.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VolumeGroupPatch"
              }
            }
          },
          "description": "Properties to update for this Volume Group.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VolumeGroupDetail"
                }
              }
            },
            "description": "Return details about the Volume Group."
          }
        },
        "summary": "Update Volume Group properties",
        "tags": [
          "/volume_group"
        ],
        "x-group": "volume_group"
      }
    },
    "/volume_group/{id}/latest_snapshot": {
      "get": {
        "description": "Retrieve the latest snapshot summary of a Volume Group.",
        "operationId": "queryVolumeGroupLatestSnapshot",
        "parameters": [
          {
            "description": "ID of the Volume Group.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/VolumeGroupSnapshotSummary"
                  },
                  "type": "array"
                }
              }
            },
            "description": "Returns a summary of a Volume Group's latest snapshot. Returns an empty array if there is no snapshot summary.\n"
          }
        },
        "summary": "Get the latest snapshot of the Volume Group",
        "tags": [
          "/volume_group"
        ],
        "x-group": "volume_group"
      }
    },
    "/volume_group/{id}/request/force_full_snapshot": {
      "get": {
        "description": "Retrieve the configuration for forcing a full snapshot for a Volume Group.",
        "operationId": "getVolumeGroupForceFullSpec",
        "parameters": [
          {
            "description": "The ID of the Volume Group.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VolumeGroupForceFullResponse"
                }
              }
            },
            "description": "Return the configuration for forcing a full snapshot on the Volume Group."
          }
        },
        "summary": "Retrieve the configuration for forcing a full snapshot",
        "tags": [
          "/volume_group"
        ],
        "x-group": "volume_group"
      },
      "post": {
        "description": "Request a full snapshot to be taken during the next backup job of a Volume Group.",
        "operationId": "requestVolumeGroupForceFullSnapshot",
        "parameters": [
          {
            "description": "The ID of the Volume Group.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VolumeGroupForceFullRequest"
              }
            }
          },
          "description": "Configuration for forcing a full snapshot on the Volume Group.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VolumeGroupForceFullResponse"
                }
              }
            },
            "description": "Return the configuration for forcing a full snapshot on the Volume Group."
          }
        },
        "summary": "Request a full snapshot on the next backup job of a Volume Group",
        "tags": [
          "/volume_group"
        ],
        "x-group": "volume_group"
      }
    },
    "/volume_group/{id}/snapshot": {
      "get": {
        "description": "Retrieve snapshot details for a Volume Group.",
        "operationId": "queryVolumeGroupSnapshot",
        "parameters": [
          {
            "description": "The ID of the Volume Group.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VolumeGroupSnapshotSummaryListResponse"
                }
              }
            },
            "description": "Returns summary information for all snapshots."
          }
        },
        "summary": "Get list of snapshots of the Volume Group",
        "tags": [
          "/volume_group"
        ],
        "x-group": "volume_group"
      },
      "post": {
        "description": "Create an on-demand snapshot for the given Volume Group ID.",
        "operationId": "createOnDemandVolumeGroupBackup",
        "parameters": [
          {
            "description": "The ID of the Volume Group.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VolumeGroupOnDemandSnapshotConfig"
              }
            }
          },
          "description": "Configuration for the on-demand backup. Configuration values are `volumeIdsIncludedInSnapshot`, which specifies the unique ID of each volume that is part of this snapshot of the Volume Group, and `slaID`, the ID of the SLA Domain for the snapshot."
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsyncRequestStatus"
                }
              }
            },
            "description": "Status for the backup request."
          }
        },
        "summary": "Create on-demand snapshot for the Volume Group",
        "tags": [
          "/volume_group"
        ],
        "x-group": "volume_group"
      }
    },
    "/windows_cluster": {
      "get": {
        "description": "Returns a list of summary information for Windows server failover clusters.",
        "operationId": "queryWindowsCluster",
        "parameters": [
          {
            "description": "Filter by primary_cluster_id. Use **local** for the local cluster.",
            "in": "query",
            "name": "primary_cluster_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter by is_agentless flag.",
            "in": "query",
            "name": "is_agentless",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Determines whether Windows clusters are fetched with additional privilege checks.",
            "in": "query",
            "name": "snappable_status",
            "required": false,
            "schema": {
              "enum": [
                "Protectable"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WindowsClusterSummaryListResponse"
                }
              }
            },
            "description": "Returned if the query was successful."
          }
        },
        "summary": "Get summary information for Windows clusters",
        "tags": [
          "/windows_cluster"
        ],
        "x-group": "windows_cluster"
      }
    },
    "/windows_cluster/{id}": {
      "get": {
        "description": "Returns a detailed view of a Windows server failover cluster.",
        "operationId": "getWindowsCluster",
        "parameters": [
          {
            "description": "ID of the Windows cluster.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WindowsClusterDetail"
                }
              }
            },
            "description": "Returned if the query was successful."
          }
        },
        "summary": "Get detailed information for a Windows cluster",
        "tags": [
          "/windows_cluster"
        ],
        "x-group": "windows_cluster"
      }
    }
  },
  "components": {
    "requestBodies": {
      "BaseOnDemandSnapshotConfig": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/BaseOnDemandSnapshotConfig"
            }
          }
        },
        "description": "Configuration for the on-demand backup."
      },
      "ExportSnapshotJobConfigV1": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ExportSnapshotJobConfigV1"
            }
          }
        },
        "description": "Configuration for the export request.",
        "required": true
      },
      "FullyQualifiedDomainNameInfo": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/FullyQualifiedDomainNameInfo"
            }
          }
        },
        "required": true
      },
      "HostRegister": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/HostRegister"
            }
          }
        },
        "description": "Registration definition for a host.",
        "required": true
      },
      "LdapServiceInfoUpdate": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/LdapServiceInfoUpdate"
            }
          }
        },
        "description": "Information for updating an authentication domain.",
        "required": true
      },
      "SyslogExportRuleFull": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/SyslogExportRuleFull"
            }
          }
        },
        "description": "Syslog export rule.",
        "required": true
      }
    },
    "responses": {
      "RequestFailedException": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/RequestFailedException"
            }
          }
        },
        "description": "Request failed."
      }
    },
    "schemas": {
      "ActionDetails": {
        "properties": {
          "actionString": {
            "description": "Action script to run.",
            "type": "string"
          },
          "isEnabled": {
            "description": "Flag to determine whether action script needs to be run.",
            "type": "boolean"
          }
        },
        "required": [
          "actionString",
          "isEnabled"
        ],
        "type": "object"
      },
      "ActivityLogSummaryV1": {
        "properties": {
          "afterId": {
            "description": "The serialized AfterId of the response, if any.",
            "type": "string"
          },
          "eventDetailList": {
            "description": "List of the events in the event series.",
            "items": {
              "$ref": "#/components/schemas/EventSummaryV1"
            },
            "type": "array"
          },
          "eventSeriesStatus": {
            "$ref": "#/components/schemas/EventSeriesStatusV1"
          },
          "latestEvent": {
            "$ref": "#/components/schemas/EventSummaryV1"
          },
          "warningCount": {
            "description": "The number of events in the same series as the specified event that have the warning status.",
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "latestEvent",
          "warningCount"
        ],
        "type": "object"
      },
      "ActivityLogSummaryV1ListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/ActivityLogSummaryV1"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "AdaptiveThrottlingSettingsVmwareFields": {
        "properties": {
          "vmwareThrottlingSettings": {
            "$ref": "#/components/schemas/VmwareAdaptiveThrottlingSettings"
          }
        },
        "type": "object"
      },
      "AdvancedLdapConfiguration": {
        "properties": {
          "groupMaxLevel": {
            "description": "Maximum level of groups to query. Set to 1 to query the immediate groups to which a user belongs. Leave blank to query all the groups to which a user belongs. Valid values are between 1 and 50 inclusive. When ldapSearchAcrossIntegrations is set to be true, this value is ignored. When this value is set, then for this ldap service, ldapActiveDirectoryDisableMatchingRuleInChain is ignored and assumed to be true.",
            "format": "int32",
            "type": "integer"
          },
          "groupMemberAttribute": {
            "description": "LDAP field that contains the group members. For example, Active Directory uses the field \"member\".",
            "type": "string"
          },
          "groupMembershipAttribute": {
            "description": "Points to the group that this entry belongs to. For example, Active Directory uses the field \"memberOf\".",
            "type": "string"
          },
          "groupSearchFilter": {
            "description": "A string representation of the LDAP group search filter in RFC4515 format. For example, a group search filter for Active Directory has the string representation (objectCategory=group).",
            "type": "string"
          },
          "userNameSearchAttribute": {
            "description": "Specifies the user name. Active Directory searches can use the attributes sAMAccountName and userPrincipalName.",
            "type": "string"
          },
          "userSearchFilter": {
            "description": "A string representation of the LDAP user search filter in RFC4515 format. For example, an Active Directory user search filter that selects all enabled user objects has the following string representation (&(objectCategory=person) (objectClass=user) (!(userAccountControl:1.2.840.113556.1.4.803:=2))).",
            "type": "string"
          }
        },
        "type": "object"
      },
      "AdvancedUiConfigAttributes": {
        "properties": {
          "retentionType": {
            "$ref": "#/components/schemas/SlaTimeUnit"
          },
          "timeUnit": {
            "$ref": "#/components/schemas/SlaTimeUnit"
          }
        },
        "required": [
          "retentionType",
          "timeUnit"
        ],
        "type": "object"
      },
      "AgentSecondaryCertificateInfo": {
        "properties": {
          "certId": {
            "description": "ID of the certificate.",
            "type": "string"
          },
          "clusterUuid": {
            "description": "Parsed cluster ID from the certificate.",
            "type": "string"
          },
          "isAgentEnabled": {
            "description": "Whether this certificate has been marked for use by agents.",
            "type": "boolean"
          },
          "name": {
            "description": "Display name for the certificate.",
            "type": "string"
          }
        },
        "required": [
          "certId",
          "clusterUuid",
          "isAgentEnabled",
          "name"
        ],
        "type": "object"
      },
      "AgentSecondaryCertificateInfoListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/AgentSecondaryCertificateInfo"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "AgentStatus": {
        "properties": {
          "agentStatus": {
            "description": "The agent connection status.",
            "type": "string"
          },
          "disconnectReason": {
            "description": "The reason the agent disconnected.",
            "type": "string"
          }
        },
        "required": [
          "agentStatus"
        ],
        "type": "object"
      },
      "AppSearchResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SearchResponse"
          },
          {
            "properties": {
              "childObjectId": {
                "description": "ID assigned to the child virtual machine of the vApp where this file was found.",
                "type": "string"
              },
              "childObjectName": {
                "description": "Name of the child virtual machine of the vApp where this file was found.",
                "type": "string"
              }
            },
            "required": [
              "childObjectId",
              "childObjectName"
            ],
            "type": "object"
          }
        ]
      },
      "AppSearchResponseListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/AppSearchResponse"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "ApplyLegalHoldDefinition": {
        "properties": {
          "holdConfig": {
            "$ref": "#/components/schemas/HoldConfig"
          },
          "snapshotId": {
            "type": "string"
          }
        },
        "required": [
          "holdConfig",
          "snapshotId"
        ],
        "type": "object"
      },
      "ArchivalSpec": {
        "properties": {
          "archivalThreshold": {
            "format": "int64",
            "type": "integer"
          },
          "archivalTieringSpec": {
            "$ref": "#/components/schemas/ArchivalTieringSpec"
          },
          "isPassthroughSupported": {
            "description": "A Boolean value that identifies whether the archival location type supports direct archive backups.\n",
            "type": "boolean"
          },
          "locationId": {
            "type": "string"
          },
          "locationName": {
            "type": "string"
          }
        },
        "required": [
          "archivalThreshold",
          "locationId"
        ],
        "type": "object"
      },
      "ArchivalSpecV2": {
        "properties": {
          "archivalThreshold": {
            "description": "Amount of time, in seconds, after which the snapshot must be uploaded.",
            "format": "int64",
            "type": "integer"
          },
          "archivalTieringSpec": {
            "$ref": "#/components/schemas/ArchivalTieringSpec"
          },
          "isPassthroughSupported": {
            "description": "Boolean value that indicates if the archival location type supports direct archive backups.\n",
            "type": "boolean"
          },
          "locationId": {
            "type": "string"
          },
          "locationName": {
            "type": "string"
          },
          "polarisManagedId": {
            "description": "The Polaris managed ID of an archival location. At least one of the parameters locationId and polarisManagedId must be defined to correctly refer to an archival location.\n",
            "type": "string"
          }
        },
        "required": [
          "archivalThreshold"
        ],
        "type": "object"
      },
      "ArchivalTieringSpec": {
        "properties": {
          "coldStorageClass": {
            "$ref": "#/components/schemas/CloudStorageColdTier"
          },
          "isInstantTieringEnabled": {
            "description": "A Boolean value that determines whether to immediately tier uploaded snapshots to cold storage. When this value is 'true,' uploaded snapshots are immediately tiered to cold storage. When this value is 'false,' snapshots are marked as eligible for tiering to cold storage after their time on the archival location exceeds the configured minimum accessible duration.\n",
            "type": "boolean"
          },
          "minAccessibleDurationInSeconds": {
            "description": "Specifies an interval in seconds. Uploaded snapshots are accessible for instant recovery for the duration of the specified interval. This value is ignored when Instant Tiering is enabled.\n",
            "format": "int64",
            "type": "integer"
          },
          "shouldTierExistingSnapshots": {
            "description": "Indicates if existing snapshots for all objects protected by the SLA should be tiered. If not specified, this defaults to false. Only the snapshots that exist in the archival location associated with the SLA will be tiered.\n",
            "type": "boolean"
          }
        },
        "required": [
          "isInstantTieringEnabled"
        ],
        "type": "object"
      },
      "AsyncRequestStatus": {
        "properties": {
          "endTime": {
            "description": "The end time of the request.",
            "format": "date-time",
            "type": "string"
          },
          "error": {
            "$ref": "#/components/schemas/RequestErrorInfo"
          },
          "id": {
            "description": "The ID of the request object used to poll the status.",
            "type": "string"
          },
          "links": {
            "description": "References to any related objects.",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "type": "array"
          },
          "nodeId": {
            "description": "The ID of the node where the job ran.",
            "type": "string"
          },
          "progress": {
            "description": "The current percentage progress of the asynchronous request.",
            "format": "double",
            "type": "number"
          },
          "startTime": {
            "description": "The start time of the request.",
            "format": "date-time",
            "type": "string"
          },
          "status": {
            "description": "Status of the ID.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "links",
          "status"
        ],
        "type": "object"
      },
      "AuthDomainType": {
        "description": "The type of authentication domain.",
        "enum": [
          "Local",
          "Ldap",
          "Idp"
        ],
        "type": "string"
      },
      "AvailableVersionInfo": {
        "properties": {
          "availability": {
            "$ref": "#/components/schemas/SoftwareAvailability"
          },
          "description": {
            "description": "Brief description of the Rubrik CDM version. An example response value is \"Rubrik 5.0 (GA)\".\n",
            "type": "string"
          },
          "downloadJobInfo": {
            "$ref": "#/components/schemas/DownloadJobInfo"
          },
          "generalAvailabilityReleaseDateForReleaseFamily": {
            "description": "The date the Rubrik CDM family was released. This date is only available for software images stored remotely and not yet downloaded.",
            "type": "string"
          },
          "md5sum": {
            "description": "The MD5 checksum of the software image. This value is used to verify the integrity of the package download.",
            "type": "string"
          },
          "releaseDate": {
            "description": "The date the Rubrik CDM version was released. This is only available for software images stored remotely and not yet downloaded.",
            "type": "string"
          },
          "releaseNotes": {
            "description": "The URL used to access the version Release Notes for the Rubrik CDM software image. The URL is available only for software images stored remotely and not yet downloaded.",
            "type": "string"
          },
          "remoteDownloadUrl": {
            "description": "The remote download URL of the Rubrik CDM software image. This URL is used to download the software to the Rubrik cluster.",
            "type": "string"
          },
          "size": {
            "description": "The size, in bytes, of the downloaded software image.",
            "format": "int64",
            "type": "integer"
          },
          "version": {
            "description": "The version of Rubrik CDM available in the Rubrik cluster or in the Rubrik remote central repository.",
            "type": "string"
          }
        },
        "required": [
          "availability",
          "version"
        ],
        "type": "object"
      },
      "AwsEc2InstanceSlaObjectCount": {
        "properties": {
          "numEc2Instances": {
            "description": "The number of EC2 instances protected under this SLA Domain.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "BackupTaskDiagnosticInfo": {
        "properties": {
          "expectedEndTime": {
            "description": "The expected completion time of the task.",
            "format": "date-time",
            "type": "string"
          },
          "queueTime": {
            "description": "The scheduled start time of the task.",
            "format": "date-time",
            "type": "string"
          },
          "taskStatus": {
            "$ref": "#/components/schemas/DiagnosticTaskStatus"
          }
        },
        "required": [
          "taskStatus"
        ],
        "type": "object"
      },
      "BackupWindow": {
        "properties": {
          "durationInHours": {
            "format": "int32",
            "type": "integer"
          },
          "startTimeAttributes": {
            "$ref": "#/components/schemas/SlaStartTimeAttributes"
          }
        },
        "required": [
          "durationInHours",
          "startTimeAttributes"
        ],
        "type": "object"
      },
      "BaseGuestCredential": {
        "properties": {
          "password": {
            "description": "Password for the account used to login to the VM guest OS.",
            "type": "string",
            "x-secret": true
          },
          "username": {
            "description": "Username for the account used to login to the VM guest OS. To include a domain, use the format <domain>\\<username>.",
            "type": "string"
          }
        },
        "required": [
          "password",
          "username"
        ],
        "type": "object"
      },
      "BaseGuestCredentialDetail": {
        "properties": {
          "username": {
            "type": "string"
          }
        },
        "required": [
          "username"
        ],
        "type": "object"
      },
      "BaseOnDemandSnapshotConfig": {
        "properties": {
          "slaId": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "BaseSnapshotDetail": {
        "properties": {
          "config": {
            "type": "string"
          },
          "isCorrupt": {
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "BaseSnapshotSummary": {
        "properties": {
          "archivalLocationIds": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "cloudState": {
            "description": "Integer value that represents the archival state of a snapshot. 0 means the snapshot is not archived. 2 means the snapshot is archived. 3 means the snapshot is downloaded from the archival location. 4 means the snapshot is in the process of being downloaded from the archival location. 6 means the snapshot is stored locally and at the archival location.\n",
            "format": "int64",
            "type": "integer"
          },
          "cloudStorageTier": {
            "$ref": "#/components/schemas/SnapshotCloudStorageTier"
          },
          "consistencyLevel": {
            "type": "string"
          },
          "date": {
            "format": "date-time",
            "type": "string"
          },
          "expirationDate": {
            "format": "date-time",
            "type": "string"
          },
          "id": {
            "type": "string"
          },
          "indexState": {
            "description": "Integer value representing the state of the indexing job for a snapshot. 0 means that the indexing has not begun or is in progress. 1 means indexing completed successfully. 2 means that the indexer failed to process this snapshot.\n",
            "format": "int64",
            "type": "integer"
          },
          "isCustomRetentionApplied": {
            "description": "A Boolean that indicates whether or not custom retention is applied to the snapshot.\n",
            "type": "boolean"
          },
          "isOnDemandSnapshot": {
            "type": "boolean"
          },
          "isPlacedOnLegalHold": {
            "description": "A Boolean that indicates whether the snapshot is placed on Legal Hold. When this value is 'true', the snapshot is placed on Legal Hold.",
            "type": "boolean"
          },
          "isRetainedByRetentionLockSla": {
            "description": "A Boolean that indicates whether the snapshot is being retained under a Retention Lock SLA Domain. When this value is 'true', the snapshot is being retained under a Retention Lock SLA Domain.",
            "type": "boolean"
          },
          "parentSnapshotId": {
            "description": "ID of the parent snapshot if the current snapshot is a child snapshot. Child snapshots are snapshots of objects that are part of an app, either a vCloud Director vApp or an AppBlueprint. Snapshots of the app are parent snapshots.\n",
            "type": "string"
          },
          "replicationLocationIds": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "slaId": {
            "description": "(Deprecated) For a policy based snapshot this parameter contains the ID of the SLA Domain currently assigned to the data source of that snapshot. For an on demand snapshot this field corresponds to the SLA Domain that was assigned when the snapshot was taken. A data source, and individual snapshots, can be reassigned to a different SLA Domain, or the SLA Domain can be modified. In any of these cases this parameter can contain a stale and incorrect value. To view retention information for this snapshot, use snapshotRetentionInfo instead.",
            "type": "string"
          },
          "slaName": {
            "description": "(Deprecated) For a policy based snapshot this parameter contains the name of the SLA Domain currently assigned to the data source of that snapshot. For an on demand snapshot this field corresponds to the SLA Domain that was assigned when the snapshot was taken. A data source, and individual snapshots, can be reassigned to a different SLA Domain, or the SLA Domain can be modified. In any of these cases this parameter can contain a stale and incorrect value. To view retention information for this snapshot, use snapshotRetentionInfo instead.",
            "type": "string"
          },
          "snapshotRetentionInfo": {
            "$ref": "#/components/schemas/SnapshotRetentionInfo"
          },
          "sourceObjectType": {
            "type": "string"
          }
        },
        "required": [
          "date",
          "id",
          "isCustomRetentionApplied",
          "isOnDemandSnapshot",
          "replicationLocationIds",
          "slaId",
          "slaName"
        ],
        "type": "object"
      },
      "BatchAsyncRequest": {
        "properties": {
          "ids": {
            "description": "Batch of the request object IDs used to poll the status.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "ids"
        ],
        "type": "object"
      },
      "BatchAsyncRequestStatus": {
        "properties": {
          "responses": {
            "description": "The asynchronous request status of a batch request.",
            "items": {
              "$ref": "#/components/schemas/AsyncRequestStatus"
            },
            "type": "array"
          }
        },
        "required": [
          "responses"
        ],
        "type": "object"
      },
      "BatchMountSnapshotJobConfig": {
        "properties": {
          "snapshots": {
            "description": "Array of objects containing information about snapshots to mount.",
            "items": {
              "$ref": "#/components/schemas/MountSnapshotJobConfigForBatchV1"
            },
            "type": "array"
          }
        },
        "required": [
          "snapshots"
        ],
        "type": "object"
      },
      "BatchVmSnapshotSummaries": {
        "properties": {
          "responses": {
            "description": "The snapshot summaries for a list of virtual machines.",
            "items": {
              "$ref": "#/components/schemas/VmSnapshotSummaries"
            },
            "type": "array"
          }
        },
        "required": [
          "responses"
        ],
        "type": "object"
      },
      "BatchVmwareCdpLiveInfo": {
        "properties": {
          "responses": {
            "description": "The live CDP info for the virtual machines.",
            "items": {
              "$ref": "#/components/schemas/VmwareCdpLiveInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "responses"
        ],
        "type": "object"
      },
      "BatchVmwareCdpStateInfo": {
        "properties": {
          "responses": {
            "description": "The CDP state info for the virtual machines.",
            "items": {
              "$ref": "#/components/schemas/VmwareCdpStateInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "responses"
        ],
        "type": "object"
      },
      "BatchVmwareVmMissedRecoverableRanges": {
        "properties": {
          "responses": {
            "description": "Missed recoverable ranges for a set of virtual machines.",
            "items": {
              "$ref": "#/components/schemas/VmwareVmMissedRecoverableRanges"
            },
            "type": "array"
          }
        },
        "required": [
          "responses"
        ],
        "type": "object"
      },
      "BatchVmwareVmMissedRecoverableRangesRequest": {
        "properties": {
          "after_time": {
            "description": "Query filter - only ranges that occur after this time are included. The date-time string should be in ISO8601 format. For example, `2018-01-01T01:23:45.678Z`.",
            "format": "date-time",
            "type": "string"
          },
          "before_time": {
            "description": "Query filter - only ranges that occur before this time are included. The date-time string should be in ISO8601 format. For example, `2018-01-01T01:23:45.678Z`.",
            "format": "date-time",
            "type": "string"
          },
          "vmIds": {
            "description": "ID of each CDP-enabled virtual machine for which missed recoverable ranges are being retrieved.",
            "items": {
              "description": "ID of the CDP-enabled virtual machine.",
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "vmIds"
        ],
        "type": "object"
      },
      "BatchVmwareVmRecoverableRanges": {
        "properties": {
          "responses": {
            "description": "The recoverable ranges for a set of virtual machines.",
            "items": {
              "$ref": "#/components/schemas/VmwareVmRecoverableRanges"
            },
            "type": "array"
          }
        },
        "required": [
          "responses"
        ],
        "type": "object"
      },
      "BatchVmwareVmRecoverableRangesRequest": {
        "properties": {
          "after_time": {
            "description": "Query filter - only ranges after this time will be included. The date-time string should be in ISO8601 format, such as `2018-01-01T01:23:45.678Z`.",
            "format": "date-time",
            "type": "string"
          },
          "before_time": {
            "description": "Query filter - only ranges before this time will be included. The date-time string should be in ISO8601 format, such as `2018-01-01T01:23:45.678Z`.",
            "format": "date-time",
            "type": "string"
          },
          "vmIds": {
            "description": "The ID of each CDP-enabled virtual machine for which recoverable ranges are being retrieved.",
            "items": {
              "description": "ID of the CDP-enabled virtual machine.",
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "vmIds"
        ],
        "type": "object"
      },
      "BlackoutWindow": {
        "properties": {
          "endTime": {
            "type": "string"
          },
          "startTime": {
            "type": "string"
          }
        },
        "required": [
          "startTime"
        ],
        "type": "object"
      },
      "BlackoutWindowResponseInfo": {
        "properties": {
          "blackoutWindowStatus": {
            "$ref": "#/components/schemas/BlackoutWindowStatus"
          },
          "blackoutWindows": {
            "$ref": "#/components/schemas/BlackoutWindows"
          }
        },
        "required": [
          "blackoutWindowStatus",
          "blackoutWindows"
        ],
        "type": "object"
      },
      "BlackoutWindowStatus": {
        "properties": {
          "isGlobalBlackoutActive": {
            "type": "boolean"
          },
          "isSnappableBlackoutActive": {
            "type": "boolean"
          }
        },
        "required": [
          "isGlobalBlackoutActive"
        ],
        "type": "object"
      },
      "BlackoutWindows": {
        "properties": {
          "globalBlackoutWindows": {
            "items": {
              "$ref": "#/components/schemas/BlackoutWindow"
            },
            "type": "array"
          },
          "snappableBlackoutWindows": {
            "items": {
              "$ref": "#/components/schemas/BlackoutWindow"
            },
            "type": "array"
          }
        },
        "required": [
          "globalBlackoutWindows"
        ],
        "type": "object"
      },
      "BooleanResponse": {
        "properties": {
          "value": {
            "type": "boolean"
          }
        },
        "required": [
          "value"
        ],
        "type": "object"
      },
      "BootstrappableNodeInfoV1": {
        "properties": {
          "hostname": {
            "description": "Hostname of a Rubrik node.",
            "type": "string"
          },
          "ipv6": {
            "description": "IPv6 address of a Rubrik node.",
            "type": "string"
          }
        },
        "required": [
          "hostname",
          "ipv6"
        ],
        "type": "object"
      },
      "BootstrappableNodeIpv4Info": {
        "properties": {
          "hostname": {
            "description": "Hostname of a Rubrik node.",
            "type": "string"
          },
          "ipv4": {
            "description": "IPv4 address of a Rubrik node.",
            "type": "string"
          }
        },
        "required": [
          "hostname",
          "ipv4"
        ],
        "type": "object"
      },
      "BrowseResponse": {
        "properties": {
          "fileMode": {
            "description": "The type of file, either a regular file or a directory.",
            "type": "string"
          },
          "filename": {
            "description": "The name of the file.",
            "type": "string"
          },
          "lastModified": {
            "type": "string"
          },
          "path": {
            "description": "The complete path of the file.",
            "type": "string"
          },
          "size": {
            "format": "int64",
            "type": "integer"
          },
          "statusMessage": {
            "description": "Description about the status.",
            "type": "string"
          },
          "unreadable": {
            "description": "Reason the file is unreadable. Undefined if the file is readable.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "BrowseResponseListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/BrowseResponse"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "BulkDeleteObjectSnapshotsConfig": {
        "properties": {
          "locationId": {
            "description": "The ID of the location that contains the snapshots to delete. When no location ID is present, this API endpoint deletes snapshots from all locations.\n",
            "type": "string"
          },
          "snapshotIds": {
            "description": "A list of snapshot IDs for the snapshots to delete.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "snapshotIds"
        ],
        "type": "object"
      },
      "BulkDeleteSnapshotsConfig": {
        "properties": {
          "objectIds": {
            "description": "List of object IDs. This endpoint deletes all snapshots from all locations for the objects with the specified IDs.\n",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "objectIds"
        ],
        "type": "object"
      },
      "BulkOnDemandSnapshotJobConfig": {
        "properties": {
          "slaId": {
            "description": "The ID of the SLA Domain to assign to the virtual machines.",
            "type": "string"
          },
          "vms": {
            "description": "The IDs of the virtual machines for which to take on-demand snapshots.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "vms"
        ],
        "type": "object"
      },
      "BulkOracleDbDetails": {
        "properties": {
          "responses": {
            "description": "An array that contains all Oracle Database update details.",
            "items": {
              "$ref": "#/components/schemas/OracleDbDetail"
            },
            "type": "array"
          }
        },
        "required": [
          "responses"
        ],
        "type": "object"
      },
      "BulkOracleHostDetails": {
        "properties": {
          "responses": {
            "description": "An array that contains all Oracle Host update details.",
            "items": {
              "$ref": "#/components/schemas/OracleHostDetail"
            },
            "type": "array"
          }
        },
        "required": [
          "responses"
        ],
        "type": "object"
      },
      "BulkOracleRacDetails": {
        "properties": {
          "responses": {
            "description": "An array that contains all Oracle RAC update details.",
            "items": {
              "$ref": "#/components/schemas/OracleRacDetail"
            },
            "type": "array"
          }
        },
        "required": [
          "responses"
        ],
        "type": "object"
      },
      "BulkShareAddResponse": {
        "properties": {
          "refreshJobStatus": {
            "$ref": "#/components/schemas/AsyncRequestStatus"
          },
          "sharesDetail": {
            "description": "Details of created shares.",
            "items": {
              "$ref": "#/components/schemas/HostShareDetail"
            },
            "type": "array"
          }
        },
        "required": [
          "refreshJobStatus",
          "sharesDetail"
        ],
        "type": "object"
      },
      "BulkSlaConflictsSummary": {
        "properties": {
          "responses": {
            "description": "List of SLA domain conflict summaries for the specified managed IDs.",
            "items": {
              "$ref": "#/components/schemas/SlaConflictsSummary"
            },
            "type": "array"
          }
        },
        "required": [
          "responses"
        ],
        "type": "object"
      },
      "BulkTierSnapshotsConfig": {
        "properties": {
          "locationId": {
            "description": "Users can specify the archival location ID in order to tier snapshots in the specified archival location. When an archival location ID is not specified, snapshots in the archival location specified in the SLA Domain policy for protected objects will be tiered. Relic and unprotected object snapshots across all archival locations will be tiered.",
            "type": "string"
          },
          "objectIds": {
            "description": "A list of object IDs to tier.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "objectIds"
        ],
        "type": "object"
      },
      "CdpLocalStatus": {
        "description": "Current Local CDP Status of virtual machine.",
        "enum": [
          "NotEnabled",
          "Pending",
          "TakingSnapshot",
          "Failed",
          "Active",
          "Resyncing"
        ],
        "type": "string"
      },
      "CdpReplicationStatus": {
        "description": "Current CDP Replication Status of virtual machine.",
        "enum": [
          "NotEnabled",
          "Failed",
          "Healthy",
          "Initializing"
        ],
        "type": "string"
      },
      "CdpState": {
        "description": "Current CDP State of virtual machine.",
        "enum": [
          "NotEnabled",
          "Pending",
          "WaitingForInitialSnapshot",
          "Running",
          "Broken",
          "FailedToStart",
          "TryingToStart",
          "Resyncing"
        ],
        "type": "string"
      },
      "CertificateImportRequest": {
        "properties": {
          "csrId": {
            "description": "ID of the certificate signing request (CSR) associated with the imported certificate.",
            "type": "string"
          },
          "description": {
            "description": "User-friendly description for the certificate.",
            "type": "string"
          },
          "name": {
            "description": "Display name for the certificate.",
            "type": "string"
          },
          "pemFile": {
            "description": "The certificates, and optionally private key to be imported, in PEM format.",
            "type": "string",
            "x-secret": true
          },
          "privateKey": {
            "description": "The private key, in PEM format, to be imported. If a private key is provided using this field instead of the pemFile field, the import fails if the private key is not successfully parsed.",
            "type": "string",
            "x-secret": true
          }
        },
        "required": [
          "name",
          "pemFile"
        ],
        "type": "object"
      },
      "CertificateListSortAttributes": {
        "description": "Attributes that are available to use when sorting query results for certificates.",
        "enum": [
          "name",
          "description",
          "hasKey",
          "expiration"
        ],
        "type": "string"
      },
      "CertificatePatchRequest": {
        "properties": {
          "description": {
            "description": "User-friendly description for the certificate.",
            "type": "string"
          },
          "name": {
            "description": "Display name for the certificate.",
            "type": "string"
          },
          "pemFile": {
            "description": "The certificates to be imported, in PEM format.",
            "type": "string",
            "x-secret": true
          }
        },
        "type": "object"
      },
      "CertificateSummary": {
        "properties": {
          "certId": {
            "description": "ID of the certificate.",
            "type": "string"
          },
          "description": {
            "description": "User-friendly description for the certificate.",
            "type": "string"
          },
          "expiration": {
            "description": "The expiration date for the certificate.",
            "format": "date-time",
            "type": "string"
          },
          "hasKey": {
            "description": "A Boolean value that specifies whether or not the certificate is associated with a stored private key. When this value is 'true,' the private key for the certificate is stored. When this value is 'false,' the private key for the certificate is not stored.",
            "type": "boolean"
          },
          "name": {
            "description": "Display name for the certificate.",
            "type": "string"
          },
          "pemFile": {
            "description": "The certificates, in PEM format.",
            "type": "string"
          },
          "usedBy": {
            "description": "A list of components using the certificate.",
            "type": "string"
          }
        },
        "required": [
          "certId",
          "expiration",
          "hasKey",
          "name",
          "pemFile",
          "usedBy"
        ],
        "type": "object"
      },
      "CertificateSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/CertificateSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "CloudInstantiationSpec": {
        "properties": {
          "imageRetentionInSeconds": {
            "description": "Specifies the number of seconds to retain an image file that is generated for a snappable. Setting this to -1 disables cloud instantiation for the snappable.\n",
            "format": "int64",
            "type": "integer"
          }
        },
        "required": [
          "imageRetentionInSeconds"
        ],
        "type": "object"
      },
      "CloudOutComputeForecastSummaries": {
        "properties": {
          "forecastWithConsolidation": {
            "$ref": "#/components/schemas/CloudOutComputeForecastSummary"
          },
          "forecastWithoutConsolidation": {
            "$ref": "#/components/schemas/CloudOutComputeForecastSummary"
          }
        },
        "type": "object"
      },
      "CloudOutComputeForecastSummary": {
        "properties": {
          "computeCostInUSD": {
            "description": "The cost of running a compute instance. The list contains up to forecastPeriodInGranularityUnit values, one for each granularity. For example, for a 3-year forecast period with a granularity of 'year', the list contains 3 values, the first value for the first year, the second value for the second year, and the third value for the third year.",
            "items": {
              "format": "int64",
              "minimum": 0,
              "type": "integer"
            },
            "type": "array"
          },
          "computeDurationInHrs": {
            "description": "Number of hours for which a compute instance is used. The list contains up to forecastPeriodInGranularityUnit values, one for each granularity. For example, for a 3-year forecast period with a granularity of 'year', the list contains 3 values, the first value for the first year, the second value for the second year, and the third value for the third year.",
            "items": {
              "format": "int64",
              "minimum": 0,
              "type": "integer"
            },
            "type": "array"
          }
        },
        "required": [
          "computeCostInUSD",
          "computeDurationInHrs"
        ],
        "type": "object"
      },
      "CloudOutForecastRequest": {
        "properties": {
          "consolidationFilter": {
            "$ref": "#/components/schemas/ForecastConsolidationFilter"
          },
          "forecastPeriodInGranularityUnit": {
            "description": "Length of forecast period, in multiples of granularity. The maximum supported forecast period is 10 years.",
            "format": "int32",
            "minimum": 1,
            "type": "integer"
          },
          "granularity": {
            "$ref": "#/components/schemas/ForecastGranularity"
          },
          "slaParameters": {
            "$ref": "#/components/schemas/CloudOutForecastSlaParameters"
          }
        },
        "required": [
          "consolidationFilter",
          "forecastPeriodInGranularityUnit",
          "granularity",
          "slaParameters"
        ],
        "type": "object"
      },
      "CloudOutForecastSlaParameters": {
        "properties": {
          "advancedUiConfig": {
            "description": "The advanced UI configuration according to the SLA Domain.",
            "items": {
              "$ref": "#/components/schemas/AdvancedUiConfigAttributes"
            },
            "type": "array"
          },
          "archivalSpecs": {
            "$ref": "#/components/schemas/ArchivalSpecV2"
          },
          "frequencies": {
            "$ref": "#/components/schemas/SlaFrequencyV2"
          },
          "maxLocalRetentionLimit": {
            "description": "Maximum local retention limit, in seconds, according to the SLA Domain. Required only for remote SLA Domains.",
            "format": "int64",
            "type": "integer"
          }
        },
        "required": [
          "frequencies"
        ],
        "type": "object"
      },
      "CloudOutForecastSummary": {
        "properties": {
          "assumptions": {
            "$ref": "#/components/schemas/ForecastAssumptions"
          },
          "locationForecast": {
            "$ref": "#/components/schemas/PerLocationCloudOutForecastSummary"
          }
        },
        "type": "object"
      },
      "CloudOutStorageForecastSummaries": {
        "properties": {
          "forecastWithConsolidation": {
            "$ref": "#/components/schemas/CloudOutStorageForecastSummary"
          },
          "forecastWithoutConsolidation": {
            "$ref": "#/components/schemas/CloudOutStorageForecastSummary"
          }
        },
        "type": "object"
      },
      "CloudOutStorageForecastSummary": {
        "properties": {
          "dataRetrievalCostInUSD": {
            "description": "Data retrieval costs, in USD, for the cloud archival location. The list contains forecastPeriodInGranularityUnit values, one for each granularity period. For example, for a 3-year forecast period with a granularity of 'year', the list contains 3 values. The first value corresponds to the first year, the second value corresponds to the second year, and the third value corresponds to the third year.",
            "items": {
              "format": "int64",
              "minimum": 0,
              "type": "integer"
            },
            "type": "array"
          },
          "earlyDeletionCostInUSD": {
            "description": "Early deletion costs, in USD, for the cloud archival location. The list contains forecastPeriodInGranularityUnit values, one for each granularity period. For example, for a 3-year forecast period with a granularity of 'year', the list contains 3 values. The first value corresponds to the first year, the second value corresponds to the second year, and the third value corresponds to the third year.",
            "items": {
              "format": "int64",
              "minimum": 0,
              "type": "integer"
            },
            "type": "array"
          },
          "perStorageClassForecast": {
            "description": "Storage utilization forecast for cloud archival location across various storage classes. The list contains one object per storage class that is used on the cloud archival location.",
            "items": {
              "$ref": "#/components/schemas/PerStorageClassCloudOutStorageForecastSummary"
            },
            "type": "array"
          },
          "storageCostInUSD": {
            "description": "Storage costs, in USD, for the cloud archival location. The list contains forecastPeriodInGranularityUnit values, one for each granularity period. For example, for a 3-year forecast period with a granularity of 'year', the list contains 3 values. The first value corresponds to the first year, the second value corresponds to the second year, and the third value corresponds to the third year.",
            "items": {
              "format": "int64",
              "minimum": 0,
              "type": "integer"
            },
            "type": "array"
          },
          "storageUsedInGB": {
            "description": "Storage values, in GBs, used on the cloud archival location. The number of values in the list is specified by the value of the forecastPeriodInGranularityUnit parameter. Each value in the list is for the last day of the granularity period. For example, for a 3-year forecast period with a granularity of 'year', the list contains 3 values. First value corresponds to the last day of the first year. Second value corresponds to the last day of the second year. Third value corresponds to the last day of the third year.",
            "items": {
              "format": "int64",
              "minimum": 0,
              "type": "integer"
            },
            "type": "array"
          }
        },
        "required": [
          "storageUsedInGB"
        ],
        "type": "object"
      },
      "CloudStorageColdTier": {
        "description": "The set of storage classes that support Cold tiering during smart or instant tiering.\n",
        "enum": [
          "AzureArchive",
          "Glacier",
          "GlacierDeepArchive"
        ],
        "type": "string"
      },
      "CloudStorageRehydrationSpeed": {
        "description": "Specifies the retrieval speed option when retrieving data from the cold storage tier to the hot storage tier for restore purposes. Rubrik cannot directly restore data from the cold storage tier and the data must be first retrieved into the hot storage tier. This is applicable only for AWS S3 and Azure archival locations. For AWS, three speed options are supported -- AwsExpedited, AwsStandard, and AwsBulk. AwsBulk is the cheapest and slowest. AwsExpedited is the fastest and most expensive. AwsStandard is the recommended default value. For Azure the only option is AzureStandard.\n",
        "enum": [
          "AwsBulk",
          "AwsStandard",
          "AwsExpedited",
          "AzureStandard"
        ],
        "type": "string"
      },
      "ClusterApiVersion": {
        "properties": {
          "apiVersion": {
            "description": "REST API version.",
            "type": "string"
          }
        },
        "required": [
          "apiVersion"
        ],
        "type": "object"
      },
      "ClusterCertificate": {
        "properties": {
          "certificate": {
            "description": "Cluster certificate.",
            "type": "string"
          }
        },
        "required": [
          "certificate"
        ],
        "type": "object"
      },
      "ClusterGeolocation": {
        "properties": {
          "address": {
            "description": "Address information for mapping the location of the Rubrik cluster. This\n value is used to provide a location for the Rubrik cluster on the\n dashboard map.\n",
            "type": "string"
          }
        },
        "required": [
          "address"
        ],
        "type": "object"
      },
      "ClusterHostGroupInfo": {
        "properties": {
          "datacenterName": {
            "description": "Name of data center the compute cluster is a member of.",
            "type": "string"
          },
          "hostGroups": {
            "description": "Host groups configured in the compute cluster.",
            "items": {
              "$ref": "#/components/schemas/HostGroupInfo"
            },
            "type": "array"
          },
          "id": {
            "description": "Moid of the compute cluster. This is not the Rubrik managed id.",
            "type": "string"
          },
          "name": {
            "description": "Name of the compute cluster.",
            "type": "string"
          }
        },
        "required": [
          "datacenterName",
          "hostGroups",
          "id",
          "name"
        ],
        "type": "object"
      },
      "ClusterInfo": {
        "properties": {
          "acceptedEulaVersion": {
            "description": "Version of the EULA accepted by admin.",
            "type": "string"
          },
          "apiVersion": {
            "description": "REST API version.",
            "type": "string"
          },
          "geolocation": {
            "$ref": "#/components/schemas/ClusterGeolocation"
          },
          "id": {
            "description": "ID of the Rubrik cluster.",
            "type": "string"
          },
          "latestEulaVersion": {
            "description": "Latest version of the EULA that must be accepted by admin.",
            "type": "string"
          },
          "name": {
            "description": "Name of the cluster.",
            "type": "string"
          },
          "timezone": {
            "$ref": "#/components/schemas/ClusterTimezone"
          },
          "version": {
            "description": "Rubrik cluster software version.",
            "type": "string"
          }
        },
        "required": [
          "acceptedEulaVersion",
          "apiVersion",
          "id",
          "latestEulaVersion",
          "name",
          "timezone",
          "version"
        ],
        "type": "object"
      },
      "ClusterTimezone": {
        "properties": {
          "timezone": {
            "description": "Cluster time zone.",
            "enum": [
              "Africa/Johannesburg",
              "Africa/Lagos",
              "Africa/Nairobi",
              "America/Anchorage",
              "America/Araguaina",
              "America/Barbados",
              "America/Chicago",
              "America/Costa_Rica",
              "America/Bogota",
              "America/Panama",
              "America/Atikokan",
              "America/Denver",
              "America/Los_Angeles",
              "America/Mexico_City",
              "America/New_York",
              "America/Noronha",
              "America/Phoenix",
              "America/Santiago",
              "America/St_Johns",
              "America/Toronto",
              "America/Vancouver",
              "Asia/Bangkok",
              "Asia/Dhaka",
              "Asia/Dubai",
              "Asia/Hong_Kong",
              "Asia/Karachi",
              "Asia/Kathmandu",
              "Asia/Kolkata",
              "Asia/Magadan",
              "Asia/Singapore",
              "Asia/Tokyo",
              "Atlantic/Cape_Verde",
              "Australia/Adelaide",
              "Australia/Brisbane",
              "Australia/Perth",
              "Australia/Sydney",
              "Europe/Amsterdam",
              "Europe/Athens",
              "Europe/London",
              "Europe/Moscow",
              "Pacific/Auckland",
              "Pacific/Honolulu",
              "Pacific/Midway",
              "UTC"
            ],
            "type": "string"
          }
        },
        "required": [
          "timezone"
        ],
        "type": "object"
      },
      "ClusterUpdate": {
        "properties": {
          "acceptedEulaVersion": {
            "description": "Version of the EULA accepted by admin. By modifying this attribute you\n agree to the specific version of the EULA. You can view the EULA from\n UI.\n",
            "type": "string"
          },
          "geolocation": {
            "$ref": "#/components/schemas/ClusterGeolocation"
          },
          "name": {
            "description": "New name for a Rubrik cluster.",
            "type": "string"
          },
          "timezone": {
            "$ref": "#/components/schemas/ClusterTimezone"
          }
        },
        "type": "object"
      },
      "ClusterVersion": {
        "properties": {
          "version": {
            "description": "Rubrik cluster software version.",
            "type": "string"
          }
        },
        "required": [
          "version"
        ],
        "type": "object"
      },
      "ClusterVisibilityConfig": {
        "properties": {
          "hostGroupFilter": {
            "description": "Names of the host groups being protected.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "id": {
            "description": "VMware managed object ID of the compute cluster. This is not the ID managed by Rubrik.",
            "type": "string"
          }
        },
        "required": [
          "hostGroupFilter",
          "id"
        ],
        "type": "object"
      },
      "ClusterVisibilityInfo": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ClusterVisibilityConfig"
          },
          {
            "properties": {
              "name": {
                "description": "Name of the compute cluster.",
                "type": "string"
              }
            },
            "required": [
              "name"
            ],
            "type": "object"
          }
        ]
      },
      "CommunityUserCredentials": {
        "properties": {
          "password": {
            "description": "Password for the account used to login to the Rubrik community / self-serve website.",
            "type": "string",
            "x-secret": true
          },
          "username": {
            "description": "Username for the account used to login to the Rubrik community / self-serve website.",
            "type": "string"
          }
        },
        "required": [
          "password",
          "username"
        ],
        "type": "object"
      },
      "ComplianceRangeFilter": {
        "description": "Specifies a number of snapshots. Compliance for each object is calculated for the most recent snapshots, up to the specified number.",
        "enum": [
          "LastSnapshot",
          "Last2Snapshots",
          "Last3Snapshots",
          "AllSnapshots"
        ],
        "type": "string"
      },
      "ComplianceSummarySLAV1": {
        "properties": {
          "numberOfInComplianceSnapshots": {
            "description": "Number of objects in compliance based on the snapshot range filter.",
            "format": "int64",
            "type": "integer"
          },
          "numberOfOutOfComplianceSnapshots": {
            "description": "Number of objects out of compliance based on the snapshot range filter.",
            "format": "int64",
            "type": "integer"
          },
          "percentOfInComplianceSnapshots": {
            "description": "Percent of objects in compliance based on the snapshot range filter.",
            "format": "double",
            "type": "number"
          },
          "percentOfOutOfComplianceSnapshots": {
            "description": "Percent of objects out of compliance based on the snapshot range filter.",
            "format": "double",
            "type": "number"
          },
          "snapshotRange": {
            "$ref": "#/components/schemas/ComplianceRangeFilter"
          },
          "totalProtected": {
            "description": "Total number of protected objects based on the snapshot range filter.",
            "format": "int64",
            "type": "integer"
          },
          "updatedStatus": {
            "$ref": "#/components/schemas/ComplianceSummaryStatus"
          },
          "updatedTime": {
            "description": "The timestamp of the most recent successful update to the compliance summary stats.",
            "format": "date-time",
            "type": "string"
          }
        },
        "required": [
          "snapshotRange",
          "updatedStatus"
        ],
        "type": "object"
      },
      "ComplianceSummaryStatus": {
        "description": "Status of compliance summary.",
        "enum": [
          "Updating",
          "Updated"
        ],
        "type": "string"
      },
      "ComplianceSummaryV1": {
        "properties": {
          "numberOfAwaitingFirstFullSnapshot": {
            "description": "Number of objects awaiting first full backup.",
            "format": "int64",
            "type": "integer"
          },
          "numberOfInComplianceSnapshots": {
            "description": "Number of objects in compliance.",
            "format": "int64",
            "type": "integer"
          },
          "numberOfOutOfComplianceSnapshots": {
            "description": "Number of objects out of compliance.",
            "format": "int64",
            "type": "integer"
          },
          "percentOfInComplianceSnapshots": {
            "description": "Percent of objects in compliance.",
            "format": "double",
            "type": "number"
          },
          "percentOfOutOfComplianceSnapshots": {
            "description": "Percent of objects out of compliance.",
            "format": "double",
            "type": "number"
          },
          "totalProtected": {
            "description": "Total number of protected objects.",
            "format": "int64",
            "type": "integer"
          },
          "updatedTime": {
            "description": "Last updated time.",
            "format": "date-time",
            "type": "string"
          }
        },
        "required": [
          "numberOfAwaitingFirstFullSnapshot",
          "numberOfInComplianceSnapshots",
          "numberOfOutOfComplianceSnapshots",
          "percentOfInComplianceSnapshots",
          "percentOfOutOfComplianceSnapshots",
          "totalProtected"
        ],
        "type": "object"
      },
      "ComputeClusterDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ComputeClusterSummary"
          },
          {
            "properties": {
              "hosts": {
                "items": {
                  "$ref": "#/components/schemas/VmwareHostSummary"
                },
                "type": "array"
              },
              "moid": {
                "type": "string"
              },
              "virtualMachines": {
                "items": {
                  "$ref": "#/components/schemas/VirtualMachineSummary"
                },
                "type": "array"
              }
            },
            "required": [
              "hosts",
              "moid",
              "virtualMachines"
            ],
            "type": "object"
          }
        ]
      },
      "ComputeClusterSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SlaAssignable"
          },
          {
            "$ref": "#/components/schemas/EffectiveSlaHolder"
          },
          {
            "properties": {
              "datacenterId": {
                "type": "string"
              },
              "drsStatus": {
                "description": "Current Drs Status of Cluster.",
                "type": "boolean"
              },
              "hostVersions": {
                "description": "List of Versions of ESXi Hosts in Compute Cluster.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "ioFilterStatus": {
                "$ref": "#/components/schemas/IoFilterStatus"
              },
              "lastUsedFqdn": {
                "type": "string"
              }
            },
            "required": [
              "datacenterId",
              "hostVersions",
              "ioFilterStatus"
            ],
            "type": "object"
          }
        ]
      },
      "ComputeClusterSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/ComputeClusterSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "ComputeClusterUpdate": {
        "properties": {
          "configuredSlaDomainId": {
            "description": "The ID of the SLA Domain that is configured for this Compute Cluster. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ConfigChangeSource": {
        "description": "Source of configuration change.",
        "enum": [
          "Unknown",
          "CustomerApi",
          "Upgrade",
          "ResetNode",
          "Software",
          "Init"
        ],
        "type": "string"
      },
      "ConfigParam": {
        "properties": {
          "keyName": {
            "type": "string"
          },
          "valName": {
            "type": "string"
          }
        },
        "required": [
          "keyName",
          "valName"
        ],
        "type": "object"
      },
      "ConfigurationSummary": {
        "properties": {
          "currentValue": {
            "description": "The current value of the configuration option.",
            "type": "string"
          },
          "defaultValue": {
            "description": "The default value, if any, for this configuration value for this release version.",
            "type": "string"
          },
          "name": {
            "description": "The name of the configuration value.",
            "type": "string"
          },
          "namespace": {
            "description": "The configuration namespace.",
            "type": "string"
          },
          "nodeId": {
            "description": "For local configuration options, the ID of the node. 'cluster' for cluster-wide configuration options.",
            "type": "string"
          },
          "onDate": {
            "description": "The timestamp specified in the input query.",
            "format": "date-time",
            "type": "string"
          },
          "valueOnDate": {
            "description": "Value of the configuration option at the requested time.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ConfigurationSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/ConfigurationSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "ConfigurationUpdateSummary": {
        "properties": {
          "apiUser": {
            "description": "The username of the account that changed the value.",
            "type": "string"
          },
          "configChangeMetadata": {
            "description": "JSON-serialized blob of metadata used to fetch information about the configuration update. For example, the upgrade version, previous state, etc.\n",
            "type": "string"
          },
          "modifiedDateTime": {
            "description": "The timestamp of the change.",
            "format": "date-time",
            "type": "string"
          },
          "name": {
            "description": "The name of the updated configuration option.",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the updated configuration. Changes that do not begin with the string `local_` are cluster-wide changes.",
            "type": "string"
          },
          "newValue": {
            "description": "The value of the configuration option after the update.",
            "type": "string"
          },
          "nodeId": {
            "description": "The updated node. For cluster-wide configuration changes, this value is `all`.",
            "type": "string"
          },
          "oldValue": {
            "description": "The original value of the configuration option.",
            "type": "string"
          },
          "source": {
            "description": "The source of the change.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ConfigurationUpdateSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/ConfigurationUpdateSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "ConfiguredSlaType": {
        "description": "Specifies whether the SLA Domain is used for protection or retention.",
        "enum": [
          "ProtectionSla",
          "RetentionSla"
        ],
        "type": "string"
      },
      "CorsConfiguration": {
        "properties": {
          "allowedHeaders": {
            "description": "The allowed headers as a comma separated string of values. The following headers are allowed by default: 'Accept', 'Accept-Language', 'Content-Language', 'and Content-Type'.\n",
            "type": "string"
          },
          "allowedOrigins": {
            "description": "The allowed origins as a comma separated string of values. Use the special string '*' to allow any origin.",
            "type": "string"
          },
          "isEnabled": {
            "description": "A Boolean value that indicates if CORS support is enabled.",
            "type": "boolean"
          }
        },
        "required": [
          "isEnabled"
        ],
        "type": "object"
      },
      "CorsConfigurationPatch": {
        "properties": {
          "allowedHeaders": {
            "description": "The allowed headers as a comma separated string of values. The following headers are allowed by default: 'Accept', 'Accept-Language', 'Content-Language', 'and Content-Type'.\n",
            "type": "string"
          },
          "allowedOrigins": {
            "description": "The allowed origins as a comma separated string of values. Use the special string '*' to allow any origin.",
            "type": "string"
          },
          "isEnabled": {
            "description": "A Boolean value that indicates if CORS support is enabled.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "CountResponse": {
        "properties": {
          "count": {
            "format": "int64",
            "type": "integer"
          }
        },
        "required": [
          "count"
        ],
        "type": "object"
      },
      "CreateNewVappParams": {
        "properties": {
          "name": {
            "description": "Name of the specified vApp within vCloud.",
            "type": "string"
          },
          "orgVdcId": {
            "description": "ID assigned to the Organization VDC object that will contain the newly created vApp object.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "orgVdcId"
        ],
        "type": "object"
      },
      "CreateVappNetworkParams": {
        "allOf": [
          {
            "$ref": "#/components/schemas/VappNetworkSummary"
          },
          {
            "properties": {
              "newName": {
                "description": "Name to assign to the vApp network that is referenced by the specified new vApp network object. If a name is specified, the Rubrik REST API server uses the name to rename the vApp network within the vCloud. If the value is empty, the vApp network is not renamed.",
                "type": "string"
              }
            },
            "type": "object"
          }
        ]
      },
      "CsrRequest": {
        "properties": {
          "city": {
            "description": "The city where the provided organization is located, for example, New York or London.",
            "type": "string"
          },
          "country": {
            "description": "The two-letter ISO code for the country where the provided organization is located, for example US, GB, or FR.",
            "type": "string"
          },
          "emailAddress": {
            "description": "An email address associated with the organization, if applicable.",
            "type": "string"
          },
          "hostnames": {
            "description": "A comma-separated list of host names that are associated with the certificate. This list accepts wildcard hostnames, such as '*.rubrik.example.com', in addition to fully-qualified domain names.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "organization": {
            "description": "The name of the organization associated with the certificate, for example 'Rubrik, Inc.'.",
            "type": "string"
          },
          "organizationUnit": {
            "description": "The name of the organizational unit associated with the certificate, for example, Engineering.",
            "type": "string"
          },
          "state": {
            "description": "If applicable, the name of the state where the provided organization is located, for example, California.",
            "type": "string"
          },
          "surname": {
            "description": "The surname associated with the certificate, if applicable.",
            "type": "string"
          },
          "uid": {
            "description": "The user ID associated with the certificate, if applicable.",
            "type": "string"
          }
        },
        "required": [
          "hostnames"
        ],
        "type": "object"
      },
      "CsrSummary": {
        "properties": {
          "csr": {
            "description": "Base64 encoded PKCS#10 certificate signing request. The request should start with -----BEGIN CERTIFICATE REQUEST-----.",
            "type": "string"
          },
          "csrId": {
            "description": "ID of the generated CSR.",
            "type": "string"
          },
          "hostnames": {
            "description": "A comma-separated list of host names that are associated with the certificate. This list accepts wildcard hostnames, such as '*.rubrik.example.com', in addition to fully-qualified domain names.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "name": {
            "description": "Display name for the generated CSR.",
            "type": "string"
          },
          "subject": {
            "description": "Subject line of the CSR.",
            "type": "string"
          }
        },
        "required": [
          "csr",
          "csrId",
          "hostnames",
          "name",
          "subject"
        ],
        "type": "object"
      },
      "CsrSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/CsrSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "DataCenterSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SlaAssignable"
          },
          {
            "$ref": "#/components/schemas/EffectiveSlaHolder"
          },
          {
            "properties": {
              "vcenterId": {
                "type": "string"
              }
            },
            "type": "object"
          }
        ]
      },
      "DataGuardGroupMember": {
        "properties": {
          "dbUniqueName": {
            "description": "Unique name of the member Oracle database.",
            "type": "string"
          },
          "racId": {
            "description": "Rubrik ID of the RAC on which this database is hosted. This field is empty when the database is not hosted on a RAC environment.",
            "type": "string"
          },
          "racName": {
            "description": "Cluster name assigned to the Oracle RAC.",
            "type": "string"
          },
          "role": {
            "description": "Current role of the member Oracle database.",
            "type": "string"
          },
          "standaloneHostId": {
            "description": "Rubrik ID of the standalone Oracle host on which this database is hosted. This field is empty when the database is not hosted on a standalone system.",
            "type": "string"
          },
          "standaloneHostName": {
            "description": "Name of the standalone Oracle database host.",
            "type": "string"
          }
        },
        "required": [
          "dbUniqueName",
          "role"
        ],
        "type": "object"
      },
      "DataGuardType": {
        "description": "Specifies whether this database is a Data Guard member, Data Guard group, or a non-Data Guard database.",
        "enum": [
          "DataGuardGroup",
          "DataGuardMember",
          "NonDataGuard"
        ],
        "type": "string"
      },
      "DataStoreSummary": {
        "properties": {
          "capacity": {
            "format": "int64",
            "type": "integer"
          },
          "dataCenterName": {
            "type": "string"
          },
          "dataStoreType": {
            "type": "string"
          },
          "id": {
            "type": "string"
          },
          "isLocal": {
            "type": "boolean"
          },
          "name": {
            "type": "string"
          }
        },
        "required": [
          "id"
        ],
        "type": "object"
      },
      "DatabaseType": {
        "description": "Type of database.",
        "enum": [
          "Oracle",
          "SQL"
        ],
        "type": "string"
      },
      "DbLogReportProperties": {
        "properties": {
          "enableDelayNotification": {
            "description": "Indicates whether the database log backup delay notification is enabled. Set to 'true' to send an email notification when the log backup delay is more than the configured threshold, and 'false' to disable the behavior.",
            "type": "boolean"
          },
          "logDelayNotificationFrequencyInMin": {
            "description": "The frequency for sending an email notification to the customer when the log backup delay is more than the threshold.",
            "format": "int64",
            "type": "integer"
          },
          "logDelayThresholdInMin": {
            "description": "The threshold for the delay in log backup before an email notification should be created.",
            "format": "int64",
            "type": "integer"
          }
        },
        "required": [
          "enableDelayNotification",
          "logDelayNotificationFrequencyInMin",
          "logDelayThresholdInMin"
        ],
        "type": "object"
      },
      "DbLogReportPropertiesUpdate": {
        "properties": {
          "enableDelayNotification": {
            "description": "Indicates whether the database log backup delay notification is enabled. Set to 'true' to send an email notification when the log backup delay is more than the configured threshold, and 'false' to disable the behavior.",
            "type": "boolean"
          },
          "logDelayNotificationFrequencyInMin": {
            "description": "An integer that specifies an interval in minutes. Email notifications about the log backup delay exceeding the specified threshold are sent at a maximum frequency specified by the interval.",
            "format": "int64",
            "type": "integer"
          },
          "logDelayThresholdInMin": {
            "description": "An integer that specifies an interval in minutes. The CDM cluster sends an email notification when a log backup is delayed for longer than the specified interval.",
            "format": "int64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "DbLogReportSummary": {
        "properties": {
          "databaseType": {
            "$ref": "#/components/schemas/DatabaseType"
          },
          "effectiveSlaDomainId": {
            "description": "ID of the SLA Domain controlling the database protection.",
            "type": "string"
          },
          "effectiveSlaDomainName": {
            "description": "Name of the SLA Domain controlling the database protection.",
            "type": "string"
          },
          "id": {
            "type": "string"
          },
          "lastSnapshotTime": {
            "description": "Time, in UTC, of the last database backup.",
            "format": "date-time",
            "type": "string"
          },
          "latestRecoveryTime": {
            "description": "Latest point in time, in UTC, to which the database can be restored.",
            "format": "date-time",
            "type": "string"
          },
          "location": {
            "description": "Location of the customer database. For a standalone SQL database, this includes the host and instance name.",
            "type": "string"
          },
          "logBackupDelay": {
            "description": "Amount of time, in seconds, that has elapsed since the next expected log backup.",
            "format": "int64",
            "type": "integer"
          },
          "logBackupFrequency": {
            "description": "Frequency, in seconds, of the database log backup.",
            "format": "int32",
            "type": "integer"
          },
          "name": {
            "description": "Name of the database.",
            "type": "string"
          },
          "primaryClusterId": {
            "description": "ID of the primary Rubrik cluster on which the database is located.",
            "type": "string"
          }
        },
        "required": [
          "databaseType",
          "effectiveSlaDomainId",
          "effectiveSlaDomainName",
          "id",
          "location",
          "name",
          "primaryClusterId"
        ],
        "type": "object"
      },
      "DbLogReportSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/DbLogReportSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "DbLogReportSummaryListSortAttribute": {
        "description": "Field used to sort when enumerating log report summary information.",
        "enum": [
          "effectiveSlaDomainName",
          "name",
          "location",
          "databaseType",
          "logBackupFrequency",
          "lastSnapshotTime",
          "latestRecoveryTime",
          "logBackupDelay"
        ],
        "type": "string"
      },
      "DiagnosticTaskStatus": {
        "description": "Status of the task.",
        "enum": [
          "Queued",
          "Started",
          "Retried",
          "Succeeded",
          "Failed",
          "Canceled"
        ],
        "type": "string"
      },
      "DisablePerLocationPause": {
        "properties": {
          "shouldSkipOldSnapshots": {
            "description": "Specifies whether to replicate snapshots taken during and before replication pause. When this value is 'true,' snapshots taken during and before the replication pause are not replicated. In all other cases, snapshots taken before and during the replication pause are replicated.\n",
            "type": "boolean"
          },
          "sourceClusterUuids": {
            "description": "Replication from specified Rubrik clusters are resumed. Specified Rubrik clusters must be paused replication sources of local Rubrik cluster.\n",
            "items": {
              "description": "A Rubrik cluster's universally unique identifier.\n",
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "shouldSkipOldSnapshots",
          "sourceClusterUuids"
        ],
        "type": "object"
      },
      "DiscoveredNasShare": {
        "properties": {
          "exportPoint": {
            "description": "The NFS export point or SMB share name for the NAS share.",
            "type": "string"
          },
          "shareType": {
            "description": "The type of NAS Share.",
            "enum": [
              "NFS",
              "SMB"
            ],
            "type": "string"
          }
        },
        "required": [
          "exportPoint",
          "shareType"
        ],
        "type": "object"
      },
      "DissolveLegalHoldDefinition": {
        "properties": {
          "snapshotIds": {
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "snapshotIds"
        ],
        "type": "object"
      },
      "DissolveLegalHoldResponse": {
        "properties": {
          "dissolvedSnapshotIds": {
            "description": "List of snapshots whose legal hold have been successfully dissolved.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "dissolvedSnapshotIds"
        ],
        "type": "object"
      },
      "DownloadFileJobConfig": {
        "properties": {
          "legalHoldDownloadConfig": {
            "$ref": "#/components/schemas/LegalHoldDownloadConfig"
          },
          "path": {
            "description": "Absolute file path.",
            "type": "string"
          }
        },
        "required": [
          "path"
        ],
        "type": "object"
      },
      "DownloadJobInfo": {
        "properties": {
          "eventId": {
            "description": "Event identifier corresponding to the job instance.",
            "type": "string"
          },
          "jobInstanceId": {
            "description": "Identifier corresponding to the download job instance.\n",
            "type": "string"
          },
          "progress": {
            "description": "Progress, as a percentage, of the job. Only populated if the job is currently running.",
            "format": "double",
            "type": "number"
          },
          "remainingTimeEstimateInSeconds": {
            "description": "Remaining time estimate for the job to complete. Only populated if the job is currently running.",
            "format": "int64",
            "type": "integer"
          },
          "status": {
            "description": "Status of the download job instance.\n",
            "type": "string"
          }
        },
        "required": [
          "eventId",
          "jobInstanceId",
          "status"
        ],
        "type": "object"
      },
      "DownloadMssqlBackupFilesByIdJobConfig": {
        "properties": {
          "items": {
            "description": "A list of snapshots and logs to download.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "legalHoldDownloadConfig": {
            "$ref": "#/components/schemas/LegalHoldDownloadConfig"
          }
        },
        "required": [
          "items"
        ],
        "type": "object"
      },
      "DownloadedSnapshotSlaAssignmentInfo": {
        "properties": {
          "objectId": {
            "description": "The managed ID of the object that owns the downloaded snapshots in the provided list.",
            "type": "string"
          },
          "slaDomainId": {
            "description": "The ID of the SLA Domain to assign to the provided list of downloaded snapshots.",
            "type": "string"
          },
          "snapshotIds": {
            "description": "A list of snapshot IDs. The SLA Domain manages retention for the downloaded copy of the snapshots assigned to the snapshot IDs. If a snapshot in the list has no downloaded copy, its retention period remains unchanged.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "objectId",
          "slaDomainId",
          "snapshotIds"
        ],
        "type": "object"
      },
      "EffectiveSlaHolder": {
        "properties": {
          "effectiveSlaDomainId": {
            "description": "The ID of the SLA Domain that controls the protection of the Rubrik object.",
            "type": "string"
          },
          "effectiveSlaDomainName": {
            "description": "The name of the SLA Domain that controls the protection of the Rubrik object.",
            "type": "string"
          },
          "effectiveSlaDomainPolarisManagedId": {
            "description": "Optional. This field contains the managed ID of of the Polaris-managed effective SLA Domain.",
            "type": "string"
          },
          "effectiveSlaSourceObjectId": {
            "description": "The ID of the parent of the Rubrik object from which the SLA Domain that controls the protection of Rubrik object is inherited.",
            "type": "string"
          },
          "effectiveSlaSourceObjectName": {
            "description": "The name of the parent of the Rubrik object from which the SLA Domain that controls the protection of Rubrik object is inherited.",
            "type": "string"
          },
          "isEffectiveSlaDomainRetentionLocked": {
            "description": "Indicates whether the effective SLA Domain is Retention Locked. When this value is 'true', the effective SLA domain is a Retention Lock SLA Domain.",
            "type": "boolean"
          }
        },
        "required": [
          "effectiveSlaDomainId",
          "effectiveSlaDomainName"
        ],
        "type": "object"
      },
      "EnablePerLocationPause": {
        "properties": {
          "shouldCancelImmediately": {
            "description": "Specifies whether replication jobs are canceled immediately. When this value is 'true,' replication jobs will be canceled immediately. In all other cases, current running replication jobs will be allowed to finish before pausing.\n",
            "type": "boolean"
          },
          "sourceClusterUuids": {
            "description": "Replication from specified Rubrik clusters are paused. Specified Rubrik clusters must be active replication sources of local Rubrik cluster.\n",
            "items": {
              "description": "A Rubrik cluster's universally unique identifier.\n",
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "shouldCancelImmediately",
          "sourceClusterUuids"
        ],
        "type": "object"
      },
      "EncryptionStatus": {
        "properties": {
          "cipher": {
            "description": "Cipher method for encryption at rest.",
            "type": "string"
          },
          "isEncrypted": {
            "description": "A Boolean value that specifies whether data on the cluster is encrypted at rest. When this value is 'true,' data stored on the cluster is encrypted. When this value is 'false,' data stored on the cluster is not encrypted.",
            "type": "boolean"
          },
          "keyLength": {
            "description": "Key length for encryption at rest.",
            "format": "int32",
            "type": "integer"
          },
          "keyProtection": {
            "description": "Key protection method for encryption at rest.",
            "type": "string"
          }
        },
        "required": [
          "isEncrypted"
        ],
        "type": "object"
      },
      "EnvoyBulkUpdate": {
        "properties": {
          "id": {
            "description": "ID assigned to a Rubrik Envoy object.",
            "type": "string"
          },
          "updateProperties": {
            "$ref": "#/components/schemas/EnvoyUpdate"
          }
        },
        "required": [
          "id",
          "updateProperties"
        ],
        "type": "object"
      },
      "EnvoyCreate": {
        "properties": {
          "ipAddress": {
            "description": "IPv4 address of a specified Rubrik Envoy object that can be accessed by the specified Rubrik cluster.",
            "type": "string"
          },
          "port": {
            "description": "Rubrik cluster port assigned to the specified organization for tunnel connections to the Rubrik web UI.",
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "ipAddress",
          "port"
        ],
        "type": "object"
      },
      "EnvoyDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/EnvoySummary"
          }
        ]
      },
      "EnvoyDetailList": {
        "properties": {
          "envoyDetails": {
            "description": "A list of detailed view of Rubrik Envoy objects.",
            "items": {
              "$ref": "#/components/schemas/EnvoyDetail"
            },
            "type": "array"
          }
        },
        "required": [
          "envoyDetails"
        ],
        "type": "object"
      },
      "EnvoyIdList": {
        "properties": {
          "envoyIds": {
            "description": "A list of Rubrik Envoy objects IDs.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "envoyIds"
        ],
        "type": "object"
      },
      "EnvoySummary": {
        "properties": {
          "id": {
            "description": "ID assigned to a Rubrik Envoy object.",
            "type": "string"
          },
          "ipAddress": {
            "description": "IPv4 address of a specified Rubrik Envoy object that can be accessed by the specified Rubrik cluster.",
            "type": "string"
          },
          "organizationId": {
            "description": "ID assigned to the organization object that is associated with the specified Rubrik Envoy object.",
            "type": "string"
          },
          "port": {
            "description": "Rubrik cluster port assigned to the specified organization for tunnel connections to the Rubrik web UI.",
            "format": "int32",
            "type": "integer"
          },
          "status": {
            "description": "Connection state of the specified Rubrik Envoy object.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "ipAddress",
          "organizationId",
          "port",
          "status"
        ],
        "type": "object"
      },
      "EnvoyUpdate": {
        "properties": {
          "ipAddress": {
            "description": "IPv4 address of a specified Rubrik Envoy object that can be accessed by the specified Rubrik cluster.",
            "type": "string"
          },
          "port": {
            "description": "Rubrik cluster port assigned to the specified organization for tunnel connections to the Rubrik web UI.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "EnvoyUserInfo": {
        "properties": {
          "password": {
            "description": "Password of a specified Rubrik Envoy object that can be used to access envoy vm.",
            "type": "string"
          },
          "username": {
            "description": "Username of a specified Rubrik Envoy object that can be used to access envoy vm.",
            "type": "string"
          }
        },
        "required": [
          "password",
          "username"
        ],
        "type": "object"
      },
      "EventCsvDownloadResponse": {
        "properties": {
          "afterDate": {
            "description": "The requested after date filter, if applicable.",
            "format": "date-time",
            "type": "string"
          },
          "afterIdResponse": {
            "description": "The serialized AfterId of the response, if any.",
            "type": "string"
          },
          "beforeDate": {
            "description": "The requested before date filter, if applicable.",
            "format": "date-time",
            "type": "string"
          },
          "downloadLink": {
            "description": "The download link for the CSV file.",
            "type": "string"
          },
          "eventSeriesStatus": {
            "$ref": "#/components/schemas/EventSeriesStatusV1"
          },
          "eventSeverity": {
            "$ref": "#/components/schemas/EventSeverityV1"
          },
          "eventStatus": {
            "$ref": "#/components/schemas/EventStatusV1"
          },
          "eventType": {
            "$ref": "#/components/schemas/EventTypeV1"
          },
          "objectIds": {
            "description": "The requested list of object ID to filter events, if applicable.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "objectName": {
            "description": "The requested object name filter, if applicable.",
            "type": "string"
          },
          "objectType": {
            "$ref": "#/components/schemas/ObjectTypeV1"
          }
        },
        "required": [
          "downloadLink"
        ],
        "type": "object"
      },
      "EventNotification": {
        "properties": {
          "event": {
            "description": "An event name.",
            "enum": [
              "upgradeStart",
              "periodicPrechecks",
              "stageCdmSoftware"
            ],
            "type": "string"
          },
          "time": {
            "description": "Timestamp of the event in ISO8601 format.",
            "format": "date-time",
            "type": "string"
          }
        },
        "required": [
          "event",
          "time"
        ],
        "type": "object"
      },
      "EventSeriesStatusV1": {
        "description": "Status of an event series.",
        "enum": [
          "Success",
          "Failure",
          "Scheduled",
          "Active",
          "Canceling",
          "Canceled",
          "SuccessWithWarnings"
        ],
        "type": "string"
      },
      "EventSeriesSummaryV1": {
        "properties": {
          "archiveTargetName": {
            "description": "The name of the archive target related to the archival task.",
            "type": "string"
          },
          "dataToTransfer": {
            "description": "The amount of data the job corresponding to the event needs to transfer.",
            "format": "int64",
            "type": "integer"
          },
          "dataTransferred": {
            "description": "The total amount of data that has been transferred by the event or job to date.",
            "format": "int64",
            "type": "integer"
          },
          "duration": {
            "description": "The current run time of the job that corresponds to the event series. For completed jobs, this time is equal to the total run time of the job (endTime - startTime). For an in-progress job, this time is equal to the Current Time minus the startTime. This field is empty for event series that do not correspond to a job.",
            "type": "string"
          },
          "endTime": {
            "description": "For event series that correspond to a job, the time when the job finished. For a completed event series, the time of the last event in the series. This field is empty for jobs that have not completed or for event series that do not correspond to a job.",
            "format": "date-time",
            "type": "string"
          },
          "estimatedTimeRemaining": {
            "description": "The estimated time remaining of the job that corresponds to the event series. This field is empty for event series that do not correspond to a job.",
            "type": "string"
          },
          "eventDetailList": {
            "description": "List of the events in the event series.",
            "items": {
              "$ref": "#/components/schemas/EventSummaryV1"
            },
            "type": "array"
          },
          "eventSeriesId": {
            "description": "The ID of event series.",
            "type": "string"
          },
          "eventSeriesStatus": {
            "$ref": "#/components/schemas/EventSeriesStatusV1"
          },
          "hasJob": {
            "description": "A Boolean value that specifies whether the event series is linked to a job on the backend. When this value is 'true,' the event series is linked to a job on the backend. When this value is 'false,' the event series is not linked to a job on the backend.",
            "type": "boolean"
          },
          "isFirstFullSnapshot": {
            "description": "A Boolean value that determines whether the job associated with the event is a first full snapshot backup.",
            "type": "boolean"
          },
          "isOnDemand": {
            "description": "Boolean value of true indicates an on demand job.",
            "type": "boolean"
          },
          "isSlaRetentionLocked": {
            "description": "Boolean that indicates whether an SLA Domain is Retention Locked. When the value is true the SLA Domain is a Retention Lock SLA Domain.",
            "type": "boolean"
          },
          "location": {
            "description": "The host of the object associated with the latest event.",
            "type": "string"
          },
          "logicalSize": {
            "description": "The logical size of the object related to the event series.",
            "format": "int64",
            "type": "integer"
          },
          "nodeIds": {
            "description": "The IDs of the nodes where the job associated with the event is running.",
            "type": "string"
          },
          "numberOfRetries": {
            "description": "The number of times the job has been retried.",
            "format": "int64",
            "type": "integer"
          },
          "objectId": {
            "description": "The ID of the object associated with the latest event.",
            "type": "string"
          },
          "objectName": {
            "description": "The name of the object associated with the latest event.",
            "type": "string"
          },
          "objectType": {
            "$ref": "#/components/schemas/ObjectTypeV1"
          },
          "progressPercentage": {
            "description": "The progress percentage of the event series.",
            "type": "string"
          },
          "remoteClusterName": {
            "description": "The name of the remote cluster related to the replication task.",
            "type": "string"
          },
          "slaId": {
            "description": "The ID of the SLA Domain associated with this job.",
            "type": "string"
          },
          "slaName": {
            "description": "The name of the SLA Domain associated with the job, if any. This field is empty for jobs that are not driven by a SLA Domain.",
            "type": "string"
          },
          "startTime": {
            "description": "The time when the job started. Only applicable to the event series that correspond to a job.",
            "format": "date-time",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/EventStatusV1"
          },
          "taskType": {
            "description": "Type of the event series. Matches the event type.\n",
            "type": "string"
          },
          "throughput": {
            "description": "The average rate of data transfer, measured in bytes per second. This rate is the total amount of data transferred divided by the total time required by the transfer.",
            "format": "int64",
            "type": "integer"
          },
          "username": {
            "description": "The username of the user-initiated job. This field is empty for jobs that are not user-initiated.",
            "type": "string"
          }
        },
        "required": [
          "eventDetailList",
          "eventSeriesId",
          "hasJob",
          "status",
          "taskType"
        ],
        "type": "object"
      },
      "EventSeverityV1": {
        "description": "Level of event's severity.",
        "enum": [
          "Critical",
          "Warning",
          "Informational"
        ],
        "type": "string"
      },
      "EventStatusV1": {
        "description": "Status of an event.",
        "enum": [
          "Failure",
          "Warning",
          "Info",
          "Running",
          "Queued",
          "Success",
          "Canceled",
          "Canceling",
          "TaskSuccess"
        ],
        "type": "string"
      },
      "EventSummaryV1": {
        "properties": {
          "afterId": {
            "description": "The serialized AfterId of the response, if any.",
            "type": "string"
          },
          "eventInfo": {
            "description": "A string that contains all the information for this event.",
            "type": "string"
          },
          "eventName": {
            "description": "The event name.",
            "type": "string"
          },
          "eventSeriesId": {
            "description": "The ID of the event series that this event belongs to.",
            "type": "string"
          },
          "eventSeverity": {
            "$ref": "#/components/schemas/EventSeverityV1"
          },
          "eventStatus": {
            "$ref": "#/components/schemas/EventStatusV1"
          },
          "eventType": {
            "$ref": "#/components/schemas/EventTypeV1"
          },
          "id": {
            "description": "The event ID.",
            "type": "string"
          },
          "jobInstanceId": {
            "description": "The ID of the associated job instance, if any.",
            "type": "string"
          },
          "objectId": {
            "description": "The ID of the object associated with the event.",
            "type": "string"
          },
          "objectName": {
            "description": "The name of the object associated with the event.",
            "type": "string"
          },
          "objectType": {
            "$ref": "#/components/schemas/ObjectTypeV1"
          },
          "time": {
            "description": "The time at which this event occurred.",
            "format": "date-time",
            "type": "string"
          }
        },
        "required": [
          "eventInfo",
          "eventSeriesId",
          "eventStatus",
          "eventType",
          "id",
          "objectType",
          "time"
        ],
        "type": "object"
      },
      "EventTypeV1": {
        "description": "Type of an event.",
        "enum": [
          "Archive",
          "Audit",
          "AuthDomain",
          "AwsEvent",
          "Backup",
          "Classification",
          "CloudNativeSource",
          "CloudNativeVm",
          "Configuration",
          "Connection",
          "Conversion",
          "Diagnostic",
          "Discovery",
          "Failover",
          "Fileset",
          "Hardware",
          "HostEvent",
          "HypervScvmm",
          "HypervServer",
          "Index",
          "Instantiate",
          "LegalHold",
          "Maintenance",
          "NutanixCluster",
          "Recovery",
          "Replication",
          "ResourceOperations",
          "Storage",
          "StorageArray",
          "StormResource",
          "Support",
          "System",
          "TestFailover",
          "Upgrade",
          "VCenter",
          "Vcd",
          "VolumeGroup",
          "UnknownEventType"
        ],
        "type": "string"
      },
      "EventsAndSeriesSummariesResponse": {
        "properties": {
          "events": {
            "description": "List of the events.",
            "items": {
              "$ref": "#/components/schemas/EventSummaryV1"
            },
            "type": "array"
          },
          "seriesSummaries": {
            "description": "The event series summaries of all events.",
            "items": {
              "$ref": "#/components/schemas/EventSeriesSummaryV1"
            },
            "type": "array"
          }
        },
        "required": [
          "events"
        ],
        "type": "object"
      },
      "EventsAndSeriesSummariesV1": {
        "properties": {
          "currentTime": {
            "description": "Current cluster time.",
            "format": "date-time",
            "type": "string"
          },
          "data": {
            "$ref": "#/components/schemas/EventsAndSeriesSummariesResponse"
          },
          "hasMore": {
            "description": "Whether there are more events.",
            "type": "boolean"
          }
        },
        "required": [
          "currentTime",
          "data",
          "hasMore"
        ],
        "type": "object"
      },
      "ExampleEnum": {
        "description": "Example enum.",
        "enum": [
          "value1",
          "value2"
        ],
        "type": "string"
      },
      "ExclusionPatternCreateConfig": {
        "properties": {
          "pattern": {
            "description": "The pattern is used for existing and future snapshots. The pattern can be a regular expression or filename. Files or directories that match the pattern are not shown in the results of searches and are excluded from restore and download operations.",
            "type": "string"
          },
          "sourceId": {
            "description": "ID of the protectable object to which the pattern applies.",
            "type": "string"
          }
        },
        "required": [
          "pattern",
          "sourceId"
        ],
        "type": "object"
      },
      "ExclusionPatternDetail": {
        "properties": {
          "id": {
            "description": "ID of the exclusion pattern.",
            "type": "string"
          },
          "isActive": {
            "description": "Indicates if the exclusion pattern applies.",
            "type": "boolean"
          },
          "isMutable": {
            "description": "Specifies whether the pattern is mutable. When this value is false, the pattern can not be altered.",
            "type": "boolean"
          },
          "pattern": {
            "description": "The pattern is used for existing and future snapshots. The pattern can be a regular expression or filename. Files or directories that match the pattern are not shown in the results of searches and are excluded from restore and download operations.",
            "type": "string"
          },
          "patternStatus": {
            "$ref": "#/components/schemas/PatternStatus"
          },
          "primaryClusterId": {
            "type": "string"
          },
          "sourceId": {
            "description": "ID of the protectable object to which the pattern applies.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "isActive",
          "isMutable",
          "pattern",
          "patternStatus",
          "primaryClusterId",
          "sourceId"
        ],
        "type": "object"
      },
      "ExclusionPatternDetailList": {
        "properties": {
          "exclusionPatternDetails": {
            "description": "A list of exclusion pattern objects.",
            "items": {
              "$ref": "#/components/schemas/ExclusionPatternDetail"
            },
            "type": "array"
          }
        },
        "required": [
          "exclusionPatternDetails"
        ],
        "type": "object"
      },
      "ExclusionPatternDetailListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/ExclusionPatternDetail"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "ExclusionPatternUpdateConfig": {
        "properties": {
          "isActive": {
            "description": "Specifies whether or not the exclusion pattern applies. Only applicable to mutable patterns.",
            "type": "boolean"
          },
          "isMutable": {
            "description": "Specifies whether the pattern is mutable. When this value is false, the pattern can not be altered.",
            "type": "boolean"
          },
          "pattern": {
            "description": "The pattern is used for existing and future snapshots. The pattern can be a regular expression or filename. Files or directories that match the pattern are not shown in the results of searches and are excluded from restore and download operations.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ExistingSnapshotRetention": {
        "description": "Specifies the retention policy to apply to existing snapshots when unprotecting an object.",
        "enum": [
          "RetainSnapshots",
          "KeepForever",
          "ExpireImmediately"
        ],
        "type": "string"
      },
      "ExpiredCustomRetentionSnapshotInfo": {
        "properties": {
          "birthSlaDomainName": {
            "description": "The SLA Domain in effect at the time the snapshot was taken. Identical to the SLA Domain assigned to the data source at that time.\n",
            "type": "string"
          },
          "globalExpirationDate": {
            "description": "Timestamp that indicates when the snapshot expires from all cluster-managed locations.\n",
            "format": "date-time",
            "type": "string"
          },
          "id": {
            "description": "The snapshot ID.",
            "type": "string"
          },
          "lastSlaDomainName": {
            "description": "The most recent SLA Domain assigned to the snapshot. Snapshots expire based on the last known configuration for the assigned SLA Domain.\n",
            "type": "string"
          },
          "snapshotDate": {
            "description": "Creation timestamp for the snapshot.",
            "format": "date-time",
            "type": "string"
          }
        },
        "required": [
          "birthSlaDomainName",
          "globalExpirationDate",
          "id",
          "lastSlaDomainName",
          "snapshotDate"
        ],
        "type": "object"
      },
      "ExpiredCustomRetentionSnapshots": {
        "description": "Array containing information of snapshot which have been expired due to snapshot-level SLA domain assignments.\n",
        "properties": {
          "snapshotInfo": {
            "items": {
              "$ref": "#/components/schemas/ExpiredCustomRetentionSnapshotInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "snapshotInfo"
        ],
        "type": "object"
      },
      "ExportMssqlDbJobConfig": {
        "properties": {
          "allowOverwrite": {
            "default": false,
            "description": "A Boolean value that determines whether an existing database can be overwritten by a database this is exported from a backup. Set to false to prevent overwrites. This is the default. Set to true to allow overwrites.",
            "type": "boolean"
          },
          "finishRecovery": {
            "description": "A Boolean value that determines the recovery option to use during database restore. When this value is 'true', the database is restored using the RECOVERY option and is fully functional at the end of the restore operation. When this value is 'false', the database is restored using the NORECOVERY option and remains in recovering mode at the end of the restore operation.",
            "type": "boolean"
          },
          "maxDataStreams": {
            "description": "Maximum number of parallel data streams that can be used to copy data to the target system.",
            "format": "int32",
            "type": "integer"
          },
          "recoveryPoint": {
            "$ref": "#/components/schemas/MssqlRecoveryPoint"
          },
          "targetDataFilePath": {
            "description": "The target path to store all data files.",
            "type": "string"
          },
          "targetDatabaseName": {
            "description": "Name of the new database.",
            "type": "string"
          },
          "targetFilePaths": {
            "description": "One target path for each individual database file. Overrides targetDataFilePath and targetLogFilePath.",
            "items": {
              "$ref": "#/components/schemas/MssqlDbFileExportPath"
            },
            "type": "array"
          },
          "targetInstanceId": {
            "description": "ID of the Microsoft SQL instance for the new database.",
            "type": "string"
          },
          "targetLogFilePath": {
            "description": "The target path to store all log files.",
            "type": "string"
          }
        },
        "required": [
          "recoveryPoint",
          "targetDatabaseName",
          "targetInstanceId"
        ],
        "type": "object"
      },
      "ExportSnapshotJobConfigV1": {
        "allOf": [
          {
            "$ref": "#/components/schemas/MountExportSnapshotJobCommonOptions"
          },
          {
            "properties": {
              "datastoreId": {
                "description": "ID of the datastore to assign to the exported virtual machine.",
                "type": "string"
              },
              "hostId": {
                "description": "ID of the ESXi host to export the new virtual machine to.",
                "type": "string"
              },
              "shouldRecoverTags": {
                "description": "The job recovers any tags that were assigned to the virtual machine.",
                "type": "boolean"
              },
              "unregisterVm": {
                "description": "Determines whether the new virtual machine created from a snapshot is registered with the vCenter Server. Use 'true' to remove the registration from vCenter Server. Use 'false' to keep the registration with the vCenter Server. The default is 'false'.",
                "type": "boolean"
              }
            },
            "required": [
              "datastoreId"
            ],
            "type": "object"
          }
        ]
      },
      "FailoverClusterAppConfig": {
        "properties": {
          "configuredSlaDomainId": {
            "description": "ID of the SLA Domain that is assigned to the specified failover cluster app. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.",
            "type": "string"
          },
          "failoverClusterAppSource": {
            "$ref": "#/components/schemas/FailoverClusterAppSource"
          },
          "failoverClusterId": {
            "description": "Cluster ID of the failover cluster app.",
            "type": "string"
          },
          "failoverClusterType": {
            "$ref": "#/components/schemas/FailoverClusterType"
          },
          "name": {
            "description": "Name of the failover cluster app.",
            "type": "string"
          }
        },
        "required": [
          "failoverClusterAppSource",
          "failoverClusterId",
          "failoverClusterType",
          "name"
        ],
        "type": "object"
      },
      "FailoverClusterAppConnectionStatus": {
        "description": "Connection type options for the failover cluster app.",
        "enum": [
          "Connected",
          "Disconnected",
          "ReplicationTarget"
        ],
        "type": "string"
      },
      "FailoverClusterAppDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FailoverClusterAppSummary"
          },
          {
            "properties": {
              "filesets": {
                "description": "Fileset detail for the failover cluster app object.",
                "items": {
                  "$ref": "#/components/schemas/FilesetDetail"
                },
                "type": "array"
              }
            },
            "required": [
              "filesets"
            ],
            "type": "object"
          }
        ]
      },
      "FailoverClusterAppSource": {
        "properties": {
          "nodeOrders": {
            "description": "Specifies an order for the failover cluster nodes. Failover cluster app backups use the failover cluster nodes in the specified order.",
            "items": {
              "$ref": "#/components/schemas/FailoverClusterNodeOrder"
            },
            "type": "array"
          },
          "virtualIps": {
            "description": "Virtual IP addresses of the failover cluster.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "FailoverClusterAppSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SlaAssignable"
          },
          {
            "$ref": "#/components/schemas/EffectiveSlaHolder"
          },
          {
            "$ref": "#/components/schemas/FailoverClusterAppConfig"
          },
          {
            "properties": {
              "connectionStatus": {
                "$ref": "#/components/schemas/FailoverClusterAppConnectionStatus"
              },
              "failoverClusterName": {
                "description": "The failover cluster name of the failover cluster app. The failover cluster is a group of hosts that provides high availability for running failover clustered applications.",
                "type": "string"
              },
              "id": {
                "description": "ID assigned to the failover cluster app.",
                "type": "string"
              },
              "operatingSystemType": {
                "$ref": "#/components/schemas/FailoverClusterOsType"
              },
              "primaryClusterId": {
                "type": "string"
              },
              "slaAssignment": {
                "$ref": "#/components/schemas/SlaAssignment"
              }
            },
            "required": [
              "connectionStatus",
              "failoverClusterName",
              "id",
              "primaryClusterId"
            ],
            "type": "object"
          }
        ]
      },
      "FailoverClusterAppSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/FailoverClusterAppSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "FailoverClusterConfig": {
        "properties": {
          "configuredSlaDomainId": {
            "description": "ID of the SLA Domain that is assigned to the specified failover cluster. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.",
            "type": "string"
          },
          "hostIds": {
            "description": "Managed ID's of Hosts of the failover cluster.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "name": {
            "description": "Name of the failover cluster.",
            "type": "string"
          }
        },
        "required": [
          "hostIds",
          "name"
        ],
        "type": "object"
      },
      "FailoverClusterConnectionStatus": {
        "description": "Connection type options for the failover cluster.",
        "enum": [
          "Connected",
          "Disconnected",
          "PartiallyConnected",
          "ReplicationTarget"
        ],
        "type": "string"
      },
      "FailoverClusterDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FailoverClusterSummary"
          },
          {
            "properties": {
              "numApps": {
                "description": "Count of the number of failover cluster apps.",
                "format": "int32",
                "type": "integer"
              },
              "numNodes": {
                "description": "Count of the number of nodes on the failover cluster.",
                "format": "int32",
                "type": "integer"
              }
            },
            "required": [
              "numApps",
              "numNodes"
            ],
            "type": "object"
          }
        ]
      },
      "FailoverClusterHierarchyObjectDescendentCount": {
        "properties": {
          "failoverCluster": {
            "format": "int32",
            "type": "integer"
          },
          "failoverClusterApp": {
            "format": "int32",
            "type": "integer"
          },
          "fileset": {
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "FailoverClusterHierarchyObjectSortAttribute": {
        "description": "Attributes that are available to use when sorting query results for failover cluster hierarchy objects.",
        "enum": [
          "name",
          "effectiveSlaDomainName"
        ],
        "type": "string"
      },
      "FailoverClusterHierarchyObjectSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SlaAssignable"
          },
          {
            "$ref": "#/components/schemas/EffectiveSlaHolder"
          },
          {
            "properties": {
              "descendentCount": {
                "$ref": "#/components/schemas/FailoverClusterHierarchyObjectDescendentCount"
              },
              "failoverClusterAppConnectionStatus": {
                "$ref": "#/components/schemas/FailoverClusterAppConnectionStatus"
              },
              "failoverClusterAppName": {
                "description": "Failover cluster app name of this failover cluster hierarchy object. Only valid for failover cluster apps.",
                "type": "string"
              },
              "failoverClusterAppSource": {
                "$ref": "#/components/schemas/FailoverClusterAppSource"
              },
              "failoverClusterConnectionStatus": {
                "$ref": "#/components/schemas/FailoverClusterConnectionStatus"
              },
              "failoverClusterName": {
                "description": "The failover cluster name for the failover cluster hierarchy object. Only valid for failover clusters.",
                "type": "string"
              },
              "failoverClusterType": {
                "$ref": "#/components/schemas/FailoverClusterType"
              },
              "filesets": {
                "description": "Fileset summary for the failover cluster hierarchy object. Only valid for failover cluster apps.",
                "items": {
                  "$ref": "#/components/schemas/FilesetSummary"
                },
                "type": "array"
              },
              "id": {
                "description": "ID assigned to the failover cluster hierarchy object.",
                "type": "string"
              },
              "isDeleted": {
                "description": "A Boolean that indicates whether the failover cluster hierarchy object has been deleted. When this value is 'true,' the hierarchy object has been deleted.",
                "type": "boolean"
              },
              "nodes": {
                "description": "Node details for the failover cluster hierarchy object. Only valid for failover clusters.",
                "items": {
                  "$ref": "#/components/schemas/FailoverClusterNode"
                },
                "type": "array"
              },
              "numFailoverClusterApps": {
                "description": "The number of failover cluster apps in the failover cluster hierarchy object. Only valid for failover clusters.",
                "format": "int32",
                "type": "integer"
              },
              "numNodes": {
                "description": "The number of nodes in the failover cluster hierarchy object. Only valid for failover clusters.",
                "format": "int32",
                "type": "integer"
              },
              "objectType": {
                "$ref": "#/components/schemas/FailoverClusterObjectType"
              },
              "operatingSystemType": {
                "$ref": "#/components/schemas/FailoverClusterOsType"
              },
              "primaryClusterId": {
                "type": "string"
              },
              "slaAssignment": {
                "$ref": "#/components/schemas/SlaAssignment"
              }
            },
            "required": [
              "descendentCount",
              "id",
              "isDeleted",
              "objectType",
              "primaryClusterId"
            ],
            "type": "object"
          }
        ]
      },
      "FailoverClusterHierarchyObjectSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/FailoverClusterHierarchyObjectSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "FailoverClusterNode": {
        "properties": {
          "connectionStatus": {
            "$ref": "#/components/schemas/FailoverClusterNodeConnectionStatus"
          },
          "id": {
            "description": "ID of the node in the failover cluster.",
            "type": "string"
          },
          "name": {
            "description": "Name of the node in the failover cluster.",
            "type": "string"
          },
          "operatingSystem": {
            "description": "Operating system of the node in the failover cluster.",
            "type": "string"
          }
        },
        "required": [
          "connectionStatus",
          "id",
          "name",
          "operatingSystem"
        ],
        "type": "object"
      },
      "FailoverClusterNodeConnectionStatus": {
        "description": "Connection type options for the failover cluster node.",
        "enum": [
          "Connecting",
          "Connected",
          "Disconnected",
          "Deleting",
          "Deleted",
          "ConnectorNotDeployed",
          "PartiallyConnected",
          "ReplicationTarget"
        ],
        "type": "string"
      },
      "FailoverClusterNodeOrder": {
        "properties": {
          "nodeId": {
            "description": "ID of the failover cluster node.",
            "type": "string"
          },
          "nodeName": {
            "description": "The name of the failover cluster node.",
            "type": "string"
          },
          "order": {
            "description": "An integer that specifies the place occupied by this node in the failover cluster app backup order.",
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "nodeId",
          "nodeName",
          "order"
        ],
        "type": "object"
      },
      "FailoverClusterNodeOsType": {
        "description": "Operating system of a specified machine.",
        "enum": [
          "AIX",
          "SunOS",
          "HPUX",
          "Linux",
          "Windows",
          "Unknown"
        ],
        "type": "string"
      },
      "FailoverClusterObjectType": {
        "description": "Types of object that can be present in the failover cluster hierarchy.",
        "enum": [
          "FailoverClusterApp",
          "Fileset",
          "HostFailoverCluster",
          "WindowsCluster"
        ],
        "type": "string"
      },
      "FailoverClusterOsType": {
        "description": "Operating system type of the failover cluster.",
        "enum": [
          "ANY",
          "AIX",
          "HPUX",
          "Linux",
          "SunOS",
          "UnixLike",
          "Windows"
        ],
        "type": "string"
      },
      "FailoverClusterSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SlaAssignable"
          },
          {
            "$ref": "#/components/schemas/EffectiveSlaHolder"
          },
          {
            "properties": {
              "connectionStatus": {
                "$ref": "#/components/schemas/FailoverClusterConnectionStatus"
              },
              "id": {
                "description": "ID assigned to the failover cluster.",
                "type": "string"
              },
              "name": {
                "description": "Cluster name assigned to the failover cluster.",
                "type": "string"
              },
              "nodes": {
                "description": "Details of the nodes of this failover cluster.",
                "items": {
                  "$ref": "#/components/schemas/FailoverClusterNode"
                },
                "type": "array"
              },
              "operatingSystemType": {
                "$ref": "#/components/schemas/FailoverClusterOsType"
              },
              "primaryClusterId": {
                "type": "string"
              },
              "slaAssignment": {
                "$ref": "#/components/schemas/SlaAssignment"
              }
            },
            "required": [
              "connectionStatus",
              "id",
              "name",
              "nodes",
              "primaryClusterId"
            ],
            "type": "object"
          }
        ]
      },
      "FailoverClusterSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/FailoverClusterSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "FailoverClusterType": {
        "description": "Cluster type options for the failover cluster app.",
        "enum": [
          "Windows",
          "UnixLike"
        ],
        "type": "string"
      },
      "FileSystemType": {
        "description": "The type of the file system on this Volume.",
        "enum": [
          "NTFS",
          "ReFS"
        ],
        "type": "string"
      },
      "FileVersion": {
        "properties": {
          "fileMode": {
            "description": "The type of file, either a regular file or a directory.",
            "type": "string"
          },
          "lastModified": {
            "type": "string"
          },
          "size": {
            "format": "int64",
            "type": "integer"
          },
          "snapshotId": {
            "description": "The snapshot this file belongs to.",
            "type": "string"
          },
          "source": {
            "description": "The location where the file is stored, either in the cloud or locally.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "FilesetArraySpec": {
        "properties": {
          "proxyHostId": {
            "description": "ID assigned to a proxy host for array-enabled backups. This property is only required for array-enabled backups.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "FilesetCreate": {
        "allOf": [
          {
            "properties": {
              "arraySpec": {
                "$ref": "#/components/schemas/FilesetArraySpec"
              },
              "enableHardlinkSupport": {
                "description": "A Boolean value that determines whether to recognize and dedupe hardlinks in a fileset. When 'true,' performs a hardlink deduplication. When 'false,' performs a normal backup that treats hardlinks as normal files. If not specified, this defaults to false.",
                "type": "boolean"
              },
              "enableSymlinkResolution": {
                "description": "A Boolean value that determines whether to resolve symlink in a fileset. When 'true,' performs a symlink resolution. When 'false,' performs no symlink resolution. If not specified, this defaults to false.",
                "type": "boolean"
              },
              "failoverClusterAppId": {
                "description": "ID of the failover cluster app.",
                "type": "string"
              },
              "hostId": {
                "type": "string"
              },
              "isPassthrough": {
                "description": "A Boolean value that determines whether to take a direct archive backup. When 'true,' performs a direct archive backup. When 'false,' performs a normal backup. If not specified, this defaults to false.",
                "type": "boolean"
              },
              "shareId": {
                "type": "string"
              },
              "snapMirrorLabelForFullBackup": {
                "description": "Rubrik CDM uses a prefix match to select the latest SnapMirror snapshot that matches this value during a full backup of a SnapMirror destination share.",
                "type": "string"
              },
              "snapMirrorLabelForIncrementalBackup": {
                "description": "Rubrik CDM selects the latest SnapMirror snapshot that matches this value using a prefix match during an incremental backup of a SnapMirror destination share.",
                "type": "string"
              },
              "templateId": {
                "type": "string"
              }
            },
            "required": [
              "templateId"
            ],
            "type": "object"
          }
        ]
      },
      "FilesetDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FilesetUpdate"
          },
          {
            "$ref": "#/components/schemas/FilesetSummary"
          },
          {
            "properties": {
              "archiveStorage": {
                "format": "int64",
                "type": "integer"
              },
              "archivedSnapshotCount": {
                "format": "int32",
                "type": "integer"
              },
              "backupScriptErrorHandling": {
                "description": "Action taken if script fails. Options are \"abort\", \"continue\".",
                "type": "string"
              },
              "backupScriptTimeout": {
                "description": "Number of seconds after which the script is killed if it has not completed execution.",
                "format": "int64",
                "type": "integer"
              },
              "localStorage": {
                "format": "int64",
                "type": "integer"
              },
              "postBackupScript": {
                "description": "Script to run after backup of this Fileset ends.",
                "type": "string"
              },
              "preBackupScript": {
                "description": "Script to run before backup of this Fileset starts.",
                "type": "string"
              },
              "protectionDate": {
                "format": "date-time",
                "type": "string"
              },
              "snapshotCount": {
                "format": "int32",
                "type": "integer"
              },
              "snapshots": {
                "items": {
                  "$ref": "#/components/schemas/FilesetSnapshotSummary"
                },
                "type": "array"
              }
            },
            "required": [
              "snapshotCount"
            ],
            "type": "object"
          }
        ]
      },
      "FilesetDownloadFileJobConfig": {
        "properties": {
          "legalHoldDownloadConfig": {
            "$ref": "#/components/schemas/LegalHoldDownloadConfig"
          },
          "sourceDir": {
            "description": "Source directory to download from.",
            "type": "string"
          }
        },
        "required": [
          "sourceDir"
        ],
        "type": "object"
      },
      "FilesetExportFileJobConfig": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FilesetRestoreFileJobConfig"
          },
          {
            "properties": {
              "hostId": {
                "description": "Host ID.",
                "type": "string"
              },
              "shareId": {
                "description": "Network share ID.",
                "type": "string"
              }
            },
            "required": [
              "hostId"
            ],
            "type": "object"
          }
        ]
      },
      "FilesetOptions": {
        "properties": {
          "allowBackupHiddenFoldersInNetworkMounts": {
            "description": "Include or exclude hidden folders inside locally-mounted remote file systems from backups.",
            "type": "boolean"
          },
          "allowBackupNetworkMounts": {
            "description": "Include or exclude locally-mounted remote file systems from backups.",
            "type": "boolean"
          },
          "useWindowsVss": {
            "description": "Use VSS during Windows backups.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "FilesetRestoreFileJobConfig": {
        "properties": {
          "destinationDir": {
            "description": "Destination directory.",
            "type": "string"
          },
          "ignoreErrors": {
            "description": "Optional field to determine if we should ignore single error during restore. Default value is false.",
            "type": "boolean"
          },
          "sourceDir": {
            "description": "Source directory to restore from.",
            "type": "string"
          }
        },
        "required": [
          "destinationDir",
          "sourceDir"
        ],
        "type": "object"
      },
      "FilesetSnapshotDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FilesetSnapshotSummary"
          },
          {
            "properties": {
              "lastModified": {
                "type": "string"
              },
              "size": {
                "format": "int64",
                "type": "integer"
              },
              "verbose": {
                "$ref": "#/components/schemas/FilesetSnapshotVerbose"
              }
            },
            "required": [
              "lastModified",
              "size"
            ],
            "type": "object"
          }
        ]
      },
      "FilesetSnapshotSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseSnapshotSummary"
          },
          {
            "properties": {
              "fileCount": {
                "format": "int64",
                "type": "integer"
              },
              "filesetName": {
                "type": "string"
              },
              "snapdiffUsed": {
                "type": "boolean"
              }
            },
            "required": [
              "filesetName"
            ],
            "type": "object"
          }
        ]
      },
      "FilesetSnapshotVerbose": {
        "properties": {
          "hasFingerprint": {
            "description": "Whether or not the fileset snapshot has fingerprint info.",
            "type": "boolean"
          },
          "partitionPaths": {
            "description": "List a partition paths for the fileset snapshot.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "hasFingerprint",
          "partitionPaths"
        ],
        "type": "object"
      },
      "FilesetSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FilesetOptions"
          },
          {
            "$ref": "#/components/schemas/SlaAssignable"
          },
          {
            "properties": {
              "arraySpec": {
                "$ref": "#/components/schemas/FilesetArraySpec"
              },
              "effectiveSlaDomainId": {
                "description": "The ID of the effective SLA Domain for this fileset.",
                "type": "string"
              },
              "effectiveSlaDomainName": {
                "description": "The name of the effective SLA Domain for this fileset.",
                "type": "string"
              },
              "effectiveSlaDomainPolarisManagedId": {
                "description": "Optional field containing Polaris managed ID of the effective SLA domain if it is Polaris managed.",
                "type": "string"
              },
              "enableHardlinkSupport": {
                "description": "A Boolean value that determines whether to recognize and dedupe hardlinks in a fileset. When 'true,' performs a hardlink deduplication. When 'false,' performs a normal backup that treats hardlinks as normal files. If not specified, this defaults to false.",
                "type": "boolean"
              },
              "enableSymlinkResolution": {
                "description": "A Boolean value that determines whether to resolve symlink in a fileset. When 'true,' performs a symlink resolution. When 'false,' performs no symlink resolution. If not specified, this defaults to false.",
                "type": "boolean"
              },
              "exceptions": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "excludes": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "failoverClusterAppId": {
                "description": "ID of the failover cluster app.",
                "type": "string"
              },
              "failoverClusterAppName": {
                "description": "The name of the failover cluster app.",
                "type": "string"
              },
              "hostId": {
                "type": "string"
              },
              "hostName": {
                "type": "string"
              },
              "includes": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "isEffectiveSlaDomainRetentionLocked": {
                "description": "An optional Boolean value that specifies whether the effective SLA Domain of a fileset is Retention Locked. When this value is 'true,' the SLA Domain is retention locked. When this value is 'false,' the SLA Domain is not Retention Locked.",
                "type": "boolean"
              },
              "isPassthrough": {
                "description": "A Boolean value that determines whether to take a direct archive backup. When 'true,' performs a direct archive backup. When 'false,' performs a normal backup. If not specified, this defaults to false.",
                "type": "boolean"
              },
              "isRelic": {
                "type": "boolean"
              },
              "operatingSystemType": {
                "type": "string"
              },
              "pendingSlaDomain": {
                "$ref": "#/components/schemas/ManagedObjectPendingSlaInfo"
              },
              "shareId": {
                "type": "string"
              },
              "snapMirrorLabelForFullBackup": {
                "description": "Rubrik CDM uses a prefix match to select the latest SnapMirror snapshot that matches this value during a full backup of a SnapMirror destination share.",
                "type": "string"
              },
              "snapMirrorLabelForIncrementalBackup": {
                "description": "Rubrik CDM selects the latest SnapMirror snapshot that matches this value using a prefix match during an incremental backup of a SnapMirror destination share.",
                "type": "string"
              },
              "templateId": {
                "type": "string"
              },
              "templateName": {
                "type": "string"
              }
            },
            "required": [
              "hostName",
              "includes",
              "isRelic",
              "templateId",
              "templateName"
            ],
            "type": "object"
          }
        ]
      },
      "FilesetSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/FilesetSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "FilesetTemplateCreate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FilesetOptions"
          },
          {
            "properties": {
              "backupScriptErrorHandling": {
                "description": "Action taken if script fails. Options are \"abort\", \"continue\".",
                "type": "string"
              },
              "backupScriptTimeout": {
                "description": "Number of seconds after which the script is killed if it has not completed execution.",
                "format": "int64",
                "type": "integer"
              },
              "exceptions": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "excludes": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "includes": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "isArrayEnabled": {
                "description": "Boolean value that determines whether the fileset is array-enabled. Set to true to indicate that the fileset is array-enabled. Set to false to indicate that the fileset is not array-enabled. When a fileset is array-enabled, the includes must be top-level LVM logical volume mount points.",
                "type": "boolean"
              },
              "name": {
                "type": "string"
              },
              "operatingSystemType": {
                "description": "Operating system type of filesets created by template.",
                "enum": [
                  "UnixLike",
                  "Windows"
                ],
                "type": "string"
              },
              "postBackupScript": {
                "description": "Script to run after backup of this fileset ends.",
                "type": "string"
              },
              "preBackupScript": {
                "description": "Script to run before backup of this fileset starts.",
                "type": "string"
              },
              "shareType": {
                "enum": [
                  "NFS",
                  "SMB"
                ],
                "type": "string"
              }
            },
            "required": [
              "includes",
              "name"
            ],
            "type": "object"
          }
        ]
      },
      "FilesetTemplateDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FilesetTemplateCreate"
          },
          {
            "properties": {
              "hostCount": {
                "description": "Number of hosts where this template has been applied.",
                "format": "int32",
                "type": "integer"
              },
              "id": {
                "type": "string"
              },
              "isArchived": {
                "type": "boolean"
              },
              "isCreatedByKupr": {
                "description": "Specifies whether this is created by a Kupr Host.",
                "type": "boolean"
              },
              "primaryClusterId": {
                "type": "string"
              },
              "shareCount": {
                "description": "Number of shares where this template has been applied.",
                "format": "int32",
                "type": "integer"
              }
            },
            "required": [
              "id",
              "primaryClusterId"
            ],
            "type": "object"
          }
        ]
      },
      "FilesetTemplateDetailListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/FilesetTemplateDetail"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "FilesetTemplatePatch": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FilesetOptions"
          },
          {
            "properties": {
              "backupScriptErrorHandling": {
                "description": "Action taken if script fails. Options are \"abort\", \"continue\".",
                "type": "string"
              },
              "backupScriptTimeout": {
                "description": "Number of seconds after which the script is killed if it has not completed execution.",
                "format": "int64",
                "type": "integer"
              },
              "exceptions": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "excludes": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "id": {
                "type": "string"
              },
              "includes": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "name": {
                "type": "string"
              },
              "operatingSystemType": {
                "description": "Operating system type of filesets created by template.",
                "enum": [
                  "UnixLike",
                  "Windows"
                ],
                "type": "string"
              },
              "postBackupScript": {
                "description": "Script to run after backup of this Fileset ends.",
                "type": "string"
              },
              "preBackupScript": {
                "description": "Script to run before backup of this Fileset starts.",
                "type": "string"
              },
              "shareType": {
                "enum": [
                  "NFS",
                  "SMB"
                ],
                "type": "string"
              }
            },
            "required": [
              "id"
            ],
            "type": "object"
          }
        ]
      },
      "FilesetUpdate": {
        "properties": {
          "configuredSlaDomainId": {
            "description": "Assign Fileset to SLA domain. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.",
            "type": "string"
          },
          "forceFull": {
            "description": "Whether to force a full on the whole fileset or certain partitions of the fileset. If this is set to true and no partitionIds are provided, then a full will be forced on the whole fileset. If set to true and partitionIds are provided, then we will force a full on only those partitions.",
            "type": "boolean"
          },
          "forceFullPartitionIds": {
            "description": "Assign partition ids to set the force full. In order for this to be valid input, forceFull must be set to true.",
            "items": {
              "format": "int32",
              "type": "integer"
            },
            "type": "array"
          },
          "snapMirrorLabelForFullBackup": {
            "description": "Rubrik CDM uses a prefix match to select the latest SnapMirror snapshot that matches this value during a full backup of a SnapMirror destination share.",
            "type": "string"
          },
          "snapMirrorLabelForIncrementalBackup": {
            "description": "Rubrik CDM selects the latest SnapMirror snapshot that matches this value using a prefix match during an incremental backup of a SnapMirror destination share.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "FipsStatus": {
        "properties": {
          "isEnabledInFlight": {
            "description": "Boolean that specifies whether FIPS mode is enabled for in-flight encryption. When this value is true, FIPS mode is enabled for in-flight data encryption.\n",
            "type": "boolean"
          }
        },
        "required": [
          "isEnabledInFlight"
        ],
        "type": "object"
      },
      "FipsStatusPatch": {
        "properties": {
          "isEnabledInFlight": {
            "description": "Boolean that specifies whether FIPS mode is enabled for in-flight encryption. When this value is true, FIPS mode is enabled for in-flight data encryption.\n",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "ForceFullVolumeInfo": {
        "description": "Information to request a forced full snapshot for a volume within a Volume Group.",
        "properties": {
          "shouldDedupe": {
            "default": true,
            "description": "Specifies whether deduplication should be enabled for the forced full snapshot of the Volume. When set to true, deduplication is performed against local data on the cluster.",
            "type": "boolean"
          },
          "volumeId": {
            "description": "The unique ID of the volume within the Volume Group.",
            "type": "string"
          }
        },
        "required": [
          "shouldDedupe",
          "volumeId"
        ],
        "type": "object"
      },
      "ForecastAssumptions": {
        "properties": {
          "annualGrowthRateInPercent": {
            "description": "Annual growth rate of protected data.",
            "format": "double",
            "minimum": 0,
            "type": "number"
          },
          "compressionFactor": {
            "description": "Data compression factor.",
            "format": "double",
            "type": "number"
          },
          "frequencyChangeRates": {
            "$ref": "#/components/schemas/FrequencyChangeRates"
          },
          "logicalDataSizeInGB": {
            "description": "Logical data size protected by the SLA Domain.",
            "format": "double",
            "minimum": 0,
            "type": "number"
          }
        },
        "required": [
          "annualGrowthRateInPercent",
          "compressionFactor",
          "frequencyChangeRates",
          "logicalDataSizeInGB"
        ],
        "type": "object"
      },
      "ForecastConsolidationFilter": {
        "description": "Filter to perform forecasts, with or without archival consolidation enabled.",
        "enum": [
          "ForecastWithConsolidation",
          "ForecastWithoutConsolidation",
          "ForecastWithAndWithoutConsolidation"
        ],
        "type": "string"
      },
      "ForecastGranularity": {
        "description": "Granularity of the cloud utilization forecast.",
        "enum": [
          "Quarter",
          "Year"
        ],
        "type": "string"
      },
      "FrequencyChangeRates": {
        "properties": {
          "dailyChangeRateInPercent": {
            "description": "Daily change rate.",
            "format": "double",
            "minimum": 0,
            "type": "number"
          },
          "monthlyChangeRateInPercent": {
            "description": "Monthly change rate.",
            "format": "double",
            "minimum": 0,
            "type": "number"
          },
          "quarterlyChangeRateInPercent": {
            "description": "Quarterly change rate.",
            "format": "double",
            "minimum": 0,
            "type": "number"
          },
          "weeklyChangeRateInPercent": {
            "description": "Weekly change rate.",
            "format": "double",
            "minimum": 0,
            "type": "number"
          },
          "yearlyChangeRateInPercent": {
            "description": "Yearly change rate.",
            "format": "double",
            "minimum": 0,
            "type": "number"
          }
        },
        "type": "object"
      },
      "FrequencyConfig": {
        "properties": {
          "frequency": {
            "format": "int32",
            "type": "integer"
          },
          "retention": {
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "frequency",
          "retention"
        ],
        "type": "object"
      },
      "FullyQualifiedDomainNameInfo": {
        "properties": {
          "fqdn": {
            "description": "Fully qualified domain name where the filter should be hosted for install/upgrade operations.",
            "type": "string"
          }
        },
        "required": [
          "fqdn"
        ],
        "type": "object"
      },
      "GenericCsrRequest": {
        "properties": {
          "csrRequest": {
            "$ref": "#/components/schemas/CsrRequest"
          },
          "name": {
            "description": "Display name for the generated CSR.",
            "type": "string"
          }
        },
        "required": [
          "csrRequest",
          "name"
        ],
        "type": "object"
      },
      "GlobalBlackoutWindowStatus": {
        "properties": {
          "isGlobalBlackoutActive": {
            "type": "boolean"
          }
        },
        "required": [
          "isGlobalBlackoutActive"
        ],
        "type": "object"
      },
      "HdfsBaseConfig": {
        "properties": {
          "apiToken": {
            "description": "API token to access Hdfs.",
            "type": "string"
          },
          "hosts": {
            "description": "List of Hdfs Namenode Hosts.",
            "items": {
              "$ref": "#/components/schemas/HdfsHost"
            },
            "type": "array"
          },
          "kerberosTicket": {
            "description": "Ticket Cache Path of Kerberos Ticket.",
            "type": "string"
          },
          "nameservices": {
            "description": "Logical name for nameservice for Hdfs HA.",
            "type": "string"
          },
          "username": {
            "description": "Username to access Hdfs API.",
            "type": "string"
          }
        },
        "required": [
          "hosts"
        ],
        "type": "object"
      },
      "HdfsConfig": {
        "allOf": [
          {
            "$ref": "#/components/schemas/HdfsBaseConfig"
          }
        ]
      },
      "HdfsCreate": {
        "properties": {
          "hostId": {
            "type": "string"
          },
          "templateId": {
            "type": "string"
          }
        },
        "required": [
          "templateId"
        ],
        "type": "object"
      },
      "HdfsDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/HdfsUpdate"
          },
          {
            "$ref": "#/components/schemas/HdfsSummary"
          },
          {
            "properties": {
              "localStorage": {
                "format": "int64",
                "type": "integer"
              },
              "protectionDate": {
                "format": "date-time",
                "type": "string"
              },
              "snapshotCount": {
                "format": "int32",
                "type": "integer"
              },
              "snapshots": {
                "items": {
                  "$ref": "#/components/schemas/HdfsSnapshotSummary"
                },
                "type": "array"
              }
            },
            "required": [
              "snapshotCount"
            ],
            "type": "object"
          }
        ]
      },
      "HdfsExportFileJobConfig": {
        "allOf": [
          {
            "$ref": "#/components/schemas/HdfsRestoreFileJobConfig"
          },
          {
            "properties": {
              "hostId": {
                "description": "Host ID.",
                "type": "string"
              }
            },
            "required": [
              "hostId"
            ],
            "type": "object"
          }
        ]
      },
      "HdfsHost": {
        "properties": {
          "hostname": {
            "description": "Hostname or Ip of Namenode.",
            "type": "string"
          },
          "port": {
            "description": "Port number of Namenode.",
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "hostname",
          "port"
        ],
        "type": "object"
      },
      "HdfsRestoreFileJobConfig": {
        "properties": {
          "destinationDir": {
            "description": "The destination directory.",
            "type": "string"
          },
          "shouldIgnoreErrors": {
            "description": "An optional Boolean that determines whether to ignore single errors during the restore process. When this value is 'true', single errors are ignored. This field is 'false' by default.",
            "type": "boolean"
          },
          "sourceDir": {
            "description": "The source directory being restored.",
            "type": "string"
          }
        },
        "required": [
          "destinationDir",
          "sourceDir"
        ],
        "type": "object"
      },
      "HdfsSnapshotDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/HdfsSnapshotSummary"
          },
          {
            "properties": {
              "lastModified": {
                "format": "date-time",
                "type": "string"
              },
              "size": {
                "format": "int64",
                "type": "integer"
              }
            },
            "required": [
              "lastModified",
              "size"
            ],
            "type": "object"
          }
        ]
      },
      "HdfsSnapshotSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseSnapshotSummary"
          },
          {
            "properties": {
              "fileCount": {
                "format": "int64",
                "type": "integer"
              },
              "hdfsName": {
                "type": "string"
              }
            },
            "required": [
              "hdfsName"
            ],
            "type": "object"
          }
        ]
      },
      "HdfsSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SlaAssignable"
          },
          {
            "properties": {
              "effectiveSlaDomainId": {
                "description": "The ID of the effective SLA Domain for a HDFS directory.",
                "type": "string"
              },
              "effectiveSlaDomainName": {
                "description": "The name of the effective SLA Domain for this HDFS directory.",
                "type": "string"
              },
              "effectiveSlaDomainPolarisManagedId": {
                "description": "An optional field that contains the Polaris managed ID of the effective SLA Domain. Only applicable to SLA Domains managed by Polaris.",
                "type": "string"
              },
              "exceptions": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "excludes": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "hostId": {
                "type": "string"
              },
              "hostName": {
                "type": "string"
              },
              "includes": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "isEffectiveSlaDomainRetentionLocked": {
                "description": "An optional Boolean value that specifies whether the effective SLA Domain of a HDFS directory is Retention Locked. When this value is 'true,' the SLA Domain is retention locked. When this value is 'false,' the SLA Domain is not Retention Locked.",
                "type": "boolean"
              },
              "isRelic": {
                "type": "boolean"
              },
              "templateId": {
                "type": "string"
              },
              "templateName": {
                "type": "string"
              }
            },
            "required": [
              "hostName",
              "includes",
              "isRelic",
              "templateId",
              "templateName"
            ],
            "type": "object"
          }
        ]
      },
      "HdfsSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/HdfsSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "HdfsTemplateCreate": {
        "properties": {
          "exceptions": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "excludes": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "includes": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "name": {
            "type": "string"
          }
        },
        "required": [
          "includes",
          "name"
        ],
        "type": "object"
      },
      "HdfsTemplateDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/HdfsTemplateCreate"
          },
          {
            "properties": {
              "hostCount": {
                "description": "Number of hosts where this template has been applied.",
                "format": "int32",
                "type": "integer"
              },
              "id": {
                "type": "string"
              },
              "primaryClusterId": {
                "type": "string"
              }
            },
            "required": [
              "id",
              "primaryClusterId"
            ],
            "type": "object"
          }
        ]
      },
      "HdfsTemplateDetailListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/HdfsTemplateDetail"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "HdfsTemplatePatch": {
        "properties": {
          "exceptions": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "excludes": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "id": {
            "type": "string"
          },
          "includes": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "name": {
            "type": "string"
          }
        },
        "required": [
          "id"
        ],
        "type": "object"
      },
      "HdfsUpdate": {
        "properties": {
          "configuredSlaDomainId": {
            "description": "Assign HDFS to SLA domain. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.",
            "type": "string"
          }
        },
        "required": [
          "configuredSlaDomainId"
        ],
        "type": "object"
      },
      "HealthMonitorPolicy": {
        "properties": {
          "causes": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "configParams": {
            "items": {
              "$ref": "#/components/schemas/ConfigParam"
            },
            "type": "array"
          },
          "dependencies": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "description": {
            "type": "string"
          },
          "isEnabled": {
            "type": "boolean"
          },
          "isHidden": {
            "type": "boolean"
          },
          "kbInfo": {
            "type": "string"
          },
          "notificationConfig": {
            "$ref": "#/components/schemas/NotificationConfig"
          },
          "policyId": {
            "type": "string"
          },
          "policyName": {
            "type": "string"
          },
          "policyType": {
            "$ref": "#/components/schemas/PolicyTypeEnum"
          },
          "remedies": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "runInState": {
            "items": {
              "$ref": "#/components/schemas/NodeStatusEnum"
            },
            "type": "array"
          },
          "scheduleFreqInSec": {
            "format": "int64",
            "type": "integer"
          },
          "scope": {
            "$ref": "#/components/schemas/PolicyScopeEnum"
          },
          "script": {
            "type": "string"
          }
        },
        "required": [
          "causes",
          "configParams",
          "dependencies",
          "description",
          "isEnabled",
          "isHidden",
          "policyId",
          "policyName",
          "policyType",
          "remedies",
          "runInState",
          "scheduleFreqInSec",
          "scope",
          "script"
        ],
        "type": "object"
      },
      "HierarchyObjectIds": {
        "properties": {
          "ids": {
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "ids"
        ],
        "type": "object"
      },
      "HoldConfig": {
        "properties": {
          "isHoldInPlace": {
            "description": "A Boolean that specifies whether snapshots that are currently local will be kept local after archiving. When this value is 'true', a snapshot that is currently local is retained locally after being archived. The default value is 'false'.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "HostConfigurationPropertyEnabled": {
        "description": "Defines the boolean type for host configuration. 'Enabled' specifies true, 'Disabled' specifies False, and 'Default' specifies to delete the entry and default to the global configuration.",
        "enum": [
          "Enabled",
          "Disabled",
          "Default"
        ],
        "type": "string"
      },
      "HostDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/HostSummary"
          },
          {
            "properties": {
              "agentId": {
                "description": "ID of the Rubrik Backup Service (RBS) installed on the host.",
                "type": "string"
              },
              "compressionEnabled": {
                "description": "Indicates if compression is enabled while transferring data between the host and the Rubrik cluster.",
                "type": "boolean"
              },
              "hostVfdDriverState": {
                "$ref": "#/components/schemas/HostVfdState"
              },
              "hostVfdEnabled": {
                "$ref": "#/components/schemas/HostVfdInstallConfig"
              },
              "isOracleHost": {
                "description": "Specifies whether this is an Oracle host. This indicates whether to show Oracle discovery fields in the UI.\n",
                "type": "boolean"
              },
              "isRelic": {
                "description": "A relic host is deleted, but still may have snapshots associated with its children (e.g. Fileset).",
                "type": "boolean"
              },
              "mssqlCbtDriverInstalled": {
                "description": "Indicates if the CBT driver is installed for SQL Server instances on the specified Windows host. Set to true when the CBT driver is installed. Set to false when the CBT driver is not installed.",
                "type": "boolean"
              },
              "oracleQueryUser": {
                "description": "Specifies the Oracle username for an account with query privileges.",
                "type": "string"
              },
              "oracleSysDbaUser": {
                "description": "Specifies the Oracle username for an account with sysdba privileges.\n",
                "type": "string"
              }
            },
            "required": [
              "hostVfdDriverState",
              "isRelic",
              "mssqlCbtDriverInstalled"
            ],
            "type": "object"
          }
        ]
      },
      "HostFilterStatus": {
        "description": "Status of Rubrik Io Filter on Hosts.",
        "enum": [
          "Installed",
          "UnsupportedByVmware",
          "OutOfDate",
          "PastExpectedDate",
          "Uninstalled",
          "Unknown"
        ],
        "type": "string"
      },
      "HostGroupInfo": {
        "properties": {
          "id": {
            "description": "ID of the host group.",
            "type": "string"
          },
          "name": {
            "description": "Name of the host group.",
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "HostHierarchyObjectDescendantCount": {
        "properties": {
          "share": {
            "description": "Number of descendant share objects in a specified hierarchy.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "HostHierarchyObjectSortAttribute": {
        "description": "Attributes that are available to use when sorting query results for host/share hierarchy objects.",
        "enum": [
          "Status",
          "Name",
          "ExportPoint",
          "ShareType",
          "Hostname"
        ],
        "type": "string"
      },
      "HostHierarchyObjectSummary": {
        "allOf": [
          {
            "properties": {
              "alias": {
                "description": "A user-specified string that returns this host in searches for host/share hierarchy objects. Only valid for host object.",
                "type": "string"
              },
              "descendantCount": {
                "$ref": "#/components/schemas/HostHierarchyObjectDescendantCount"
              },
              "domain": {
                "description": "The share domain name. This value is only valid for host share objects.",
                "type": "string"
              },
              "exportPoint": {
                "description": "The export point of host/share hierarchy objects. Only valid for share object.",
                "type": "string"
              },
              "filesets": {
                "description": "Fileset summary for the host/share hierarchy object. Only valid for share object.",
                "items": {
                  "$ref": "#/components/schemas/FilesetSummary"
                },
                "type": "array"
              },
              "hostId": {
                "description": "The host ID of host/share hierarchy objects. Only valid for share object.",
                "type": "string"
              },
              "hostname": {
                "description": "The host name of host/share hierarchy objects. Only valid for share object.",
                "type": "string"
              },
              "id": {
                "description": "ID assigned to the host/share hierarchy object.",
                "type": "string"
              },
              "isChangeList": {
                "description": "A Boolean that specifies whether ChangeList is enabled for the host/share hierarchy object. Only valid for share objects.",
                "type": "boolean"
              },
              "isOnSnapMirrorDestVolume": {
                "description": "Indicates if the NetApp SnapMirror destination volume includes the NAS share. Only valid for share objects.",
                "type": "boolean"
              },
              "isSnapDiff": {
                "description": "A Boolean that specifies whether SnapDiff is enabled for the host/share hierarchy object. Only valid for share objects.",
                "type": "boolean"
              },
              "isilonChangelistEnabledDescendantCount": {
                "description": "The number of host shares that have the Isilon Changelist feature enabled which improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job. This value is only valid for physical host objects.",
                "format": "int32",
                "type": "integer"
              },
              "name": {
                "description": "The name of host/share hierarchy objects. Only valid for host object.",
                "type": "string"
              },
              "nasBaseConfig": {
                "$ref": "#/components/schemas/NasBaseConfig"
              },
              "objectType": {
                "$ref": "#/components/schemas/HostObjectType"
              },
              "operatingSystem": {
                "description": "The operating system detailed information of host/share hierarchy objects. Only valid for physical host object.",
                "type": "string"
              },
              "operatingSystemType": {
                "description": "The operating system type of host/share hierarchy objects. Only valid for physical host object.",
                "type": "string"
              },
              "primaryClusterId": {
                "type": "string"
              },
              "shareType": {
                "enum": [
                  "NFS",
                  "SMB"
                ],
                "type": "string"
              },
              "slaAssignment": {
                "$ref": "#/components/schemas/SlaAssignment"
              },
              "snapDiffEnabledDescendantCount": {
                "description": "The number of host shares that have enabled SnapDiff. This value is only valid for physical host objects.",
                "format": "int32",
                "type": "integer"
              },
              "status": {
                "type": "string"
              },
              "username": {
                "description": "The share user name. This value is only valid for host share objects.",
                "type": "string"
              }
            },
            "required": [
              "descendantCount",
              "id",
              "objectType",
              "primaryClusterId",
              "status"
            ],
            "type": "object"
          }
        ]
      },
      "HostHierarchyObjectSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/HostHierarchyObjectSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "HostInfo": {
        "properties": {
          "hostname": {
            "description": "Name of the host.",
            "type": "string"
          },
          "id": {
            "description": "The managed id of the host.",
            "type": "string"
          },
          "oracleQueryUser": {
            "description": "Oracle discovery user.",
            "type": "string"
          },
          "oracleSysDbaUser": {
            "description": "Oracle sysdba user to use on the host.",
            "type": "string"
          }
        },
        "required": [
          "hostname",
          "id",
          "oracleQueryUser",
          "oracleSysDbaUser"
        ],
        "type": "object"
      },
      "HostMakePrimaryRequest": {
        "properties": {
          "ids": {
            "description": "IDs of hosts to migrate.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "oldPrimaryClusterUuid": {
            "description": "For all hosts and virtual machines registered with this cluster, make itself the primary if the current primary is oldPrimaryClusterUuid.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "HostObjectType": {
        "description": "Types of object that can be present in the host/share hierarchy.",
        "enum": [
          "Host",
          "Share"
        ],
        "type": "string"
      },
      "HostOperatingSystemType": {
        "description": "The host operating system type.",
        "enum": [
          "ANY",
          "NONE",
          "UnixLike",
          "Windows"
        ],
        "type": "string"
      },
      "HostRbsStatus": {
        "description": "The status of the Rubrik Backup Service on the host.",
        "enum": [
          "Installed",
          "NotInstalled",
          "Disconnected"
        ],
        "type": "string"
      },
      "HostRegister": {
        "properties": {
          "alias": {
            "description": "A user-specified string that returns this host in searches.",
            "type": "string"
          },
          "hasAgent": {
            "type": "boolean"
          },
          "hdfsConfig": {
            "$ref": "#/components/schemas/HdfsConfig"
          },
          "hostname": {
            "type": "string"
          },
          "isOracleHost": {
            "description": "A Boolean that specifies whether to discover Oracle information at registration. A value of 'true' discovers Oracle information at registration.\n",
            "type": "boolean"
          },
          "nasConfig": {
            "$ref": "#/components/schemas/NasConfig"
          },
          "oracleQueryUser": {
            "description": "Specifies the Oracle username for an account with query privileges. The account must have query privileges for a specified Oracle installation to enable Oracle discovery queries for that installation.\n",
            "type": "string"
          },
          "oracleSysDbaUser": {
            "description": "Specifies the Oracle username for an account with sysdba privileges. The account must have sysdba privileges for a specified Oracle installation to enable Oracle discovery queries for that installation. This field overrides the configured global sysdba user for the specified Oracle installation.",
            "type": "string"
          },
          "organizationId": {
            "description": "The ID of the organization to which the host is assigned.",
            "type": "string"
          }
        },
        "required": [
          "hostname"
        ],
        "type": "object"
      },
      "HostShareDetail": {
        "properties": {
          "domain": {
            "description": "The domain of the SMB share.",
            "type": "string"
          },
          "exportPoint": {
            "description": "The NFS export point or SMB share name for the NAS share.",
            "type": "string"
          },
          "hostId": {
            "description": "The host ID of the NAS Share host.",
            "type": "string"
          },
          "hostShareParameters": {
            "$ref": "#/components/schemas/HostShareParameters"
          },
          "hostname": {
            "description": "The hostname of the NAS host.",
            "type": "string"
          },
          "id": {
            "description": "The unique ID of the NAS Share.",
            "type": "string"
          },
          "primaryClusterId": {
            "description": "The ID of the primary Rubrik cluster.",
            "type": "string"
          },
          "shareType": {
            "description": "The type of NAS share.",
            "enum": [
              "NFS",
              "SMB"
            ],
            "type": "string"
          },
          "status": {
            "description": "The status of connection between the Rubrik cluster and the NAS Share. Possible responses are Connected and Disconnected.",
            "type": "string"
          },
          "username": {
            "description": "The username to access the NAS share.",
            "type": "string"
          },
          "vendorType": {
            "$ref": "#/components/schemas/NasVendorType"
          }
        },
        "required": [
          "exportPoint",
          "hostname",
          "id",
          "primaryClusterId",
          "shareType",
          "status"
        ],
        "type": "object"
      },
      "HostShareParameters": {
        "properties": {
          "isIsilonChangelistEnabled": {
            "description": "Indicates if Changelist is enabled on Isilon NAS share. When this value is 'true', metadata fetches during backup operations use the Isilon Changelist feature. The Changelist feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.",
            "type": "boolean"
          },
          "isNetAppSnapDiffEnabled": {
            "description": "Indicates if SnapDiff is enabled on NetApp NAS share. When this value is 'true', metadata fetches during backup operations use the NetApp SnapDiff feature. The SnapDiff feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.",
            "type": "boolean"
          },
          "isOnNetAppSnapMirrorDestVolume": {
            "description": "Indicates whether the share is on a SnapMirror destination volume on a NetApp NAS share. When this value is 'true', fileset backup operations pick the latest Netapp snapshot on the volume, subject to the configured label matching. During share registration, Rubrik checks with NetApp NAS to find out whether the share is on SnapMirror destination and sets this parameter.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "HostSharePatch": {
        "properties": {
          "domain": {
            "type": "string"
          },
          "exportPoint": {
            "type": "string"
          },
          "hostShareParameters": {
            "$ref": "#/components/schemas/HostShareParameters"
          },
          "password": {
            "type": "string",
            "x-secret": true
          },
          "username": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "HostShareUpdate": {
        "properties": {
          "shareId": {
            "description": "ID of the network share.",
            "type": "string"
          },
          "updateProperties": {
            "$ref": "#/components/schemas/HostSharePatch"
          }
        },
        "required": [
          "shareId",
          "updateProperties"
        ],
        "type": "object"
      },
      "HostShareVendorType": {
        "description": "The NAS vendor for the host share.",
        "enum": [
          "Isilon",
          "NetApp",
          "FlashBlade"
        ],
        "type": "string"
      },
      "HostSummary": {
        "properties": {
          "alias": {
            "description": "A user-specified string that returns this host in searches.",
            "type": "string"
          },
          "hdfsBaseConfig": {
            "$ref": "#/components/schemas/HdfsBaseConfig"
          },
          "hostname": {
            "description": "Deprecated. Please use 'name' instead.",
            "type": "string"
          },
          "id": {
            "description": "Unique identifier for host.",
            "type": "string"
          },
          "mssqlCbtEffectiveStatus": {
            "$ref": "#/components/schemas/MssqlCbtEffectiveStatusType"
          },
          "mssqlCbtEnabled": {
            "$ref": "#/components/schemas/MssqlCbtStatusType"
          },
          "name": {
            "description": "IP address or hostname of the host.",
            "type": "string"
          },
          "nasBaseConfig": {
            "$ref": "#/components/schemas/NasBaseConfig"
          },
          "operatingSystem": {
            "description": "Operating system of the host. One of Windows, Linux, AIX, HPUX, and SunOS.",
            "type": "string"
          },
          "operatingSystemType": {
            "description": "The operating system of the host. Possible choices are Windows, Linux, AIX, HPUX, SunOS.",
            "type": "string"
          },
          "organizationId": {
            "description": "The ID of the organization to which the host is assigned (set by envoy).",
            "type": "string"
          },
          "organizationName": {
            "description": "The name of the organization to which the host is assigned (set by envoy).",
            "type": "string"
          },
          "primaryClusterId": {
            "description": "ID of the Rubrik cluster to which the host belongs.",
            "type": "string"
          },
          "status": {
            "description": "Specifies the connect status for the host. Status is Refreshing while discovery is running or Connected once discovery was successful and the host is available.",
            "type": "string"
          }
        },
        "required": [
          "hostname",
          "id"
        ],
        "type": "object"
      },
      "HostSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/HostSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "HostUiFilterStatus": {
        "description": "Status of Rubrik Io Filter on ESX Host.",
        "enum": [
          "Ok",
          "InstallInProgress",
          "UninstallInProgress",
          "UpgradeInProgress",
          "UpgradeNeeded",
          "RetryInstall",
          "CheckVcenter",
          "ErrorContactSupport",
          "ErrorMaintenanceMode",
          "NoFilter",
          "Unknown",
          "UnsupportedByVmware"
        ],
        "type": "string"
      },
      "HostUpdate": {
        "properties": {
          "alias": {
            "description": "A user-specified string that returns this host in searches.",
            "type": "string"
          },
          "compressionEnabled": {
            "type": "boolean"
          },
          "hdfsConfig": {
            "$ref": "#/components/schemas/HdfsConfig"
          },
          "hostVfdDriverInstalled": {
            "description": "When VFD is disabled on the specified Windows host, set this property to false to instruct the Rubrik cluster to remove the VFD driver from a specified Windows host. Before using this property, disable VFD on the specified Windows host by setting the value of HostVfdEnabled to Disabled.",
            "type": "boolean"
          },
          "hostVfdEnabled": {
            "$ref": "#/components/schemas/HostVfdInstallConfig"
          },
          "hostname": {
            "type": "string"
          },
          "isOracleHost": {
            "description": "A Boolean that specifies whether to discover Oracle information during host refresh. A value of 'true' discovers Oracle information during host refresh.\n",
            "type": "boolean"
          },
          "mssqlCbtDriverInstalled": {
            "description": "When CBT is disabled on the specified Windows host, set this property to false to instruct the Rubrik cluster to remove the CBT driver from a specified Windows host. Before using this property, disable CBT on the specified Windows host by setting the value of mssqlCbtEnabled to Disabled.",
            "type": "boolean"
          },
          "mssqlCbtEnabled": {
            "$ref": "#/components/schemas/MssqlCbtStatusType"
          },
          "nasConfig": {
            "$ref": "#/components/schemas/NasConfig"
          },
          "oracleQueryUser": {
            "description": "Specifies the Oracle username for an account with query privileges. The account must have query privileges for a specified Oracle installation to enable Oracle discovery queries for that installation.\n",
            "type": "string"
          },
          "oracleSysDbaUser": {
            "description": "Specifies the Oracle username for an account with sysdba privileges. The account must have sysdba privileges for a specified Oracle installation to enable Oracle discovery queries for that installation. This field overrides the configured global sysdba user for the specified Oracle installation.\n",
            "type": "string"
          }
        },
        "type": "object"
      },
      "HostVfdInstallConfig": {
        "description": "VFD host support status.",
        "enum": [
          "Enabled",
          "Disabled"
        ],
        "type": "string"
      },
      "HostVfdState": {
        "description": "VFD host install state.",
        "enum": [
          "NotInstalled",
          "Installed",
          "InstalledButRestartRequired",
          "UninstalledButRestartRequired"
        ],
        "type": "string"
      },
      "HostVolumeSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/VolumeGroupSnapshotVolumeSummary"
          },
          {
            "properties": {
              "isCurrentlyPresentOnSystem": {
                "description": "Indicates whether a volume is present on the host. When 'true', the volume is present. When 'false', the volume is not present. Volumes that are not present on the host are still included in snapshots and trigger warnings until the missing volumes are excluded from snapshots.",
                "type": "boolean"
              },
              "naturalId": {
                "description": "The unique ID of the volume on the Windows host.",
                "type": "string"
              },
              "volumeGroupId": {
                "description": "The unique ID of the Volume Group.",
                "type": "string"
              }
            },
            "required": [
              "isCurrentlyPresentOnSystem",
              "naturalId"
            ],
            "type": "object"
          }
        ]
      },
      "HostVolumeSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/HostVolumeSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "HotAddBandwidthInfo": {
        "properties": {
          "exportLimit": {
            "description": "The HotAdd bandwidth limit in Mbps for export.",
            "format": "int32",
            "type": "integer"
          },
          "ingestLimit": {
            "description": "The HotAdd bandwidth limit in Mbps for ingest.",
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "exportLimit",
          "ingestLimit"
        ],
        "type": "object"
      },
      "HotAddNetworkConfigWithId": {
        "properties": {
          "network_id": {
            "description": "The ID of a user-configured vCenter network selected for HotAdd backup and recovery.",
            "type": "string"
          },
          "static_ip_info": {
            "$ref": "#/components/schemas/StaticIpInfo"
          }
        },
        "required": [
          "network_id"
        ],
        "type": "object"
      },
      "HotAddNetworkConfigWithName": {
        "properties": {
          "networkName": {
            "description": "The name of the HotAdd proxy virtual machine network.",
            "type": "string"
          },
          "staticIpConfig": {
            "$ref": "#/components/schemas/StaticIpInfo"
          }
        },
        "type": "object"
      },
      "HotAddProxiesNeededInfo": {
        "properties": {
          "needed": {
            "description": "The number of HotAdd proxies the vCenter requires.",
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "needed"
        ],
        "type": "object"
      },
      "HotAddProxyVmInfo": {
        "properties": {
          "UsedPortCount": {
            "description": "The number of port in use for the HotAdd proxy virtual machine.",
            "format": "int32",
            "type": "integer"
          },
          "computeClusterName": {
            "description": "The name of the compute cluster that contains the HotAdd proxy virtual machine.",
            "type": "string"
          },
          "datastoreName": {
            "description": "The name of the datastore that the HotAdd proxy virtual machine uses.",
            "type": "string"
          },
          "hostName": {
            "description": "The name of the ESX host that contains the HotAdd proxy virtual machine.",
            "type": "string"
          },
          "id": {
            "description": "The ID of the HotAdd proxy virtual machine.",
            "type": "string"
          },
          "name": {
            "description": "The name of the HotAdd proxy virtual machine.",
            "type": "string"
          },
          "proxyNetworkInfo": {
            "$ref": "#/components/schemas/HotAddNetworkConfigWithName"
          },
          "status": {
            "$ref": "#/components/schemas/HotAddProxyVmStatusType"
          },
          "vcenterName": {
            "description": "The name of the vCenter that contains the HotAdd proxy virtual machine.",
            "type": "string"
          }
        },
        "required": [
          "UsedPortCount",
          "datastoreName",
          "id",
          "name",
          "status",
          "vcenterName"
        ],
        "type": "object"
      },
      "HotAddProxyVmInfoListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/HotAddProxyVmInfo"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "HotAddProxyVmStatusType": {
        "description": "The type of the HotAdd proxy virtual machine.",
        "enum": [
          "Running",
          "Failed",
          "Expired",
          "Maintaining"
        ],
        "type": "string"
      },
      "HypervVirtualDiskForceFullInfo": {
        "description": "Information required to request a force full snapshot for a Hyper-V virtual disk running in a Hyper-V virtual machine.",
        "properties": {
          "shouldDedupe": {
            "default": true,
            "description": "Indicates if deduplication should be enabled for the forced full snapshot of the Virtual Disk. When set to true, deduplication is performed against local data on the Rubrik cluster.",
            "type": "boolean"
          },
          "virtualDiskId": {
            "description": "ID of the virtual disk running in the Hyper-V virtual machine.",
            "type": "string"
          }
        },
        "required": [
          "shouldDedupe",
          "virtualDiskId"
        ],
        "type": "object"
      },
      "HypervVirtualMachineForceFullRequest": {
        "properties": {
          "virtualDiskInfos": {
            "description": "Configuration to force a full snapshot for the virtual disks listed in the request. The configuration specifies which virtual disks in HyperV VM receive forced full snapshots, and whether to perform deduplication. If the configuration is missing, a forced full snapshot is not requested. If the configuration contains an empty array, a forced full snapshot is requested for all virtual disks in the HyperV virtual machine, and deduplication is performed by default. If the configuration array contains specific virtual disks, a forced full snapshot is requested only for these disks. The shouldDedupe flag determines if deduplication is performed. If a forced full snapshot is requested, the next backup job checks the configuration and takes the full snapshot according to the configuration. After the full snapshot is taken, the backup job clears the configuration to prevent additional full snapshots from being taken.",
            "items": {
              "$ref": "#/components/schemas/HypervVirtualDiskForceFullInfo"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "HypervVirtualMachineForceFullResponse": {
        "properties": {
          "virtualDiskInfos": {
            "description": "Configuration for each virtual disk that requested a forced full snapshot. If the configuration does not exist, either a forced full snapshot was not requested for the HyperV virtual machine, or a backup job took the requested full snapshot and cleared the configuration.",
            "items": {
              "$ref": "#/components/schemas/HypervVirtualDiskForceFullInfo"
            },
            "type": "array"
          },
          "vmId": {
            "description": "ID of the Hyper-V virtual machine containing all virtual disks.",
            "type": "string"
          }
        },
        "required": [
          "vmId"
        ],
        "type": "object"
      },
      "HypervVmSlaObjectCount": {
        "properties": {
          "numHypervVms": {
            "description": "The number of Hyper-V virtual machines protected under this SLA domain.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "IdNamePair": {
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          }
        },
        "required": [
          "id",
          "name"
        ],
        "type": "object"
      },
      "IdProviderAuthDomainInfo": {
        "allOf": [
          {
            "$ref": "#/components/schemas/IdProviderSamlInfo"
          },
          {
            "properties": {
              "name": {
                "description": "Human friendly name of the Id Provider (IdP).",
                "type": "string"
              }
            },
            "required": [
              "name"
            ],
            "type": "object"
          }
        ]
      },
      "IdProviderAuthDomainInfoUpdate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/IdProviderSamlInfoUpdate"
          },
          {
            "properties": {
              "name": {
                "description": "Human friendly name of the Id Provider (IdP).",
                "type": "string"
              }
            },
            "type": "object"
          }
        ]
      },
      "IdProviderAuthDomainSummary": {
        "properties": {
          "entityId": {
            "description": "Entity ID of the Id Provider (IdP).",
            "type": "string"
          },
          "id": {
            "description": "ID of this authentication domain.",
            "type": "string"
          },
          "name": {
            "description": "Domain name.",
            "type": "string"
          },
          "organizationId": {
            "description": "ID of the organization that added the authentication domain.",
            "type": "string"
          },
          "signCert": {
            "description": "The Identity Provider (IdP) X509 certificate, stored using the PEM format, used to sign the SAML assertion.",
            "type": "string"
          },
          "signCertExpiryDate": {
            "description": "The expiry date of the Identity Provider (IdP) X509 certificate. The date is a string with the ISO-8601 format like 2017-01-23T20:12:45.000Z with milliseconds precision.",
            "type": "string"
          },
          "skewnessInSec": {
            "description": "The clock skewness tolerance, in seconds, between the Identity Provider (IdP) and the Rubrik cluster.",
            "format": "int64",
            "type": "integer"
          },
          "ssoUrl": {
            "description": "The Identity Provider (IdP) endpoint that Rubrik sends authentication request to in order to initiate SSO login.",
            "type": "string"
          }
        },
        "required": [
          "entityId",
          "id",
          "name",
          "signCert",
          "signCertExpiryDate",
          "skewnessInSec",
          "ssoUrl"
        ],
        "type": "object"
      },
      "IdProviderAuthDomainSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/IdProviderAuthDomainSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "IdProviderSamlInfo": {
        "properties": {
          "metadataXmlBase64": {
            "description": "Identity Provider (IdP) metadata XML file in a base64 encoded format.",
            "type": "string"
          },
          "skewnessInSec": {
            "default": 300,
            "description": "The clock skewness tolerance, in seconds, between the Identity Provider (IdP) and the Rubrik cluster.",
            "format": "int64",
            "minimum": 0,
            "type": "integer"
          }
        },
        "required": [
          "metadataXmlBase64"
        ],
        "type": "object"
      },
      "IdProviderSamlInfoUpdate": {
        "properties": {
          "metadataXmlBase64": {
            "description": "Identity Provider (IdP) metadata XML file in a base64 encoded format.",
            "type": "string"
          },
          "skewnessInSec": {
            "default": 300,
            "description": "The clock skewness tolerance, in seconds, between the Identity Provider (IdP) and the Rubrik cluster.",
            "format": "int64",
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "InstantRecoveryJobConfig": {
        "allOf": [
          {
            "$ref": "#/components/schemas/MountExportSnapshotJobCommonOptions"
          },
          {
            "properties": {
              "hostId": {
                "description": "ID of the ESXi host to use for Instant Recovery.",
                "type": "string"
              },
              "preserveMoid": {
                "default": false,
                "description": "Determines whether to preserve the moid of the source virtual machine in a restore operation. Use 'true' to keep the moid of the source. Use 'false' to assign a new moid. The default is 'false'.",
                "type": "boolean"
              },
              "shouldRecoverTags": {
                "description": "The job recovers the tags that were assigned to the virtual machine.",
                "type": "boolean"
              },
              "vlan": {
                "description": "VLAN ID for the VLAN ESXi host prefer to use for mounting the datastore.",
                "format": "int32",
                "type": "integer"
              }
            },
            "type": "object"
          }
        ]
      },
      "InternalJobInstanceDetail": {
        "properties": {
          "archived": {
            "description": "Whether this job instance has been archived.",
            "type": "boolean"
          },
          "childJobDebugInfo": {
            "description": "Some job types create other 'child' jobs to perform their work. Here we show information on how this job is being affected by its child jobs (if any).",
            "type": "string"
          },
          "endTime": {
            "description": "End time of the job instance.",
            "type": "string"
          },
          "errorInfo": {
            "description": "Error information of the job instance.",
            "type": "string"
          },
          "id": {
            "description": "ID of the instance.",
            "type": "string"
          },
          "isDisabled": {
            "description": "Whether this job is disabled or not.",
            "type": "boolean"
          },
          "jobProgress": {
            "description": "The current progress in terms of percentage of the async request.",
            "format": "double",
            "type": "number"
          },
          "jobType": {
            "description": "Type of the job.",
            "type": "string"
          },
          "nodeId": {
            "description": "ID of the node where the job runs.",
            "type": "string"
          },
          "result": {
            "description": "Result of the job instance. Its meaning depends on the job type but is usually an ID.",
            "type": "string"
          },
          "startTime": {
            "description": "Start time of the job instance.",
            "type": "string"
          },
          "status": {
            "description": "Status of the job instance.",
            "type": "string"
          }
        },
        "required": [
          "archived",
          "id",
          "isDisabled",
          "jobType",
          "nodeId",
          "status"
        ],
        "type": "object"
      },
      "IoFilterStatus": {
        "description": "Status of Rubrik Io Filter on Cluster.",
        "enum": [
          "Uninstalled",
          "InstallInProgress",
          "UpgradeInProgress",
          "UninstallInProgress",
          "OutOfDate",
          "Installed",
          "InstallError",
          "UpgradeError",
          "UninstallError",
          "Unknown",
          "Inconsistent",
          "Unsupported",
          "UnsupportedByRubrik",
          "UnsupportedByVmware",
          "Unavailable"
        ],
        "type": "string"
      },
      "IoFilterSummary": {
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "releaseDate": {
            "type": "string"
          },
          "summary": {
            "type": "string"
          },
          "vendor": {
            "type": "string"
          },
          "version": {
            "type": "string"
          }
        },
        "required": [
          "id",
          "name",
          "vendor",
          "version"
        ],
        "type": "object"
      },
      "IoFilterSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/IoFilterSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "JobMonitoringCsvDownloadResponse": {
        "properties": {
          "downloadLink": {
            "description": "The download link for the CSV file.",
            "type": "string"
          },
          "jobEventStatus": {
            "$ref": "#/components/schemas/JobMonitoringStatus"
          },
          "jobMonitoringState": {
            "$ref": "#/components/schemas/JobMonitoringState"
          },
          "jobTaskType": {
            "$ref": "#/components/schemas/JobMonitoringTaskType"
          },
          "objectName": {
            "description": "The requested object name (if applicable).",
            "type": "string"
          },
          "objectType": {
            "$ref": "#/components/schemas/ReportableObjectType"
          },
          "shouldIncludeLogRelatedJob": {
            "description": "A Boolean that specifies whether log-related jobs are included. When this value is 'true,' log-related jobs are included.",
            "type": "boolean"
          }
        },
        "required": [
          "downloadLink",
          "jobMonitoringState",
          "shouldIncludeLogRelatedJob"
        ],
        "type": "object"
      },
      "JobMonitoringInfo": {
        "properties": {
          "dataToTransfer": {
            "description": "Amount of data to transfer in bytes.",
            "format": "int64",
            "type": "integer"
          },
          "dataTransferred": {
            "description": "The amount of data transferred as part of the job in bytes.",
            "format": "int64",
            "type": "integer"
          },
          "duration": {
            "description": "The number of seconds since the job started to active jobs. The number of seconds the job ran for completed jobs.",
            "format": "int64",
            "type": "integer"
          },
          "endTime": {
            "description": "End time of the job. Leave this value empty for queued and running jobs.",
            "format": "date-time",
            "type": "string"
          },
          "errorInfo": {
            "description": "Description of error information for the job.",
            "type": "string"
          },
          "eventSeriesId": {
            "description": "The event series id associated with the job.",
            "type": "string"
          },
          "isFirstFullSnapshot": {
            "description": "A Boolean value that determines whether or not the job associated with the event is a first full snapshot backup.",
            "type": "boolean"
          },
          "isLogTask": {
            "description": "A boolean value indication if the job is a log related job.",
            "type": "boolean"
          },
          "isOnDemand": {
            "description": "A boolean value indication if the job is a an on demand job.",
            "type": "boolean"
          },
          "jobMonitoringState": {
            "$ref": "#/components/schemas/JobMonitoringState"
          },
          "jobStatus": {
            "$ref": "#/components/schemas/JobMonitoringStatus"
          },
          "jobType": {
            "$ref": "#/components/schemas/JobMonitoringTaskType"
          },
          "lastSuccessfulJobTime": {
            "description": "Time of the last successful job of the same job type. The return value is None if no successful jobs are present.",
            "format": "date-time",
            "type": "string"
          },
          "lastUpdatedTime": {
            "description": "The time the status for the job has been updated.",
            "format": "date-time",
            "type": "string"
          },
          "locationId": {
            "description": "Id of the location of the object.",
            "type": "string"
          },
          "locationName": {
            "description": "Location Name.",
            "type": "string"
          },
          "maximumAttemptsForJob": {
            "description": "The maximum number of times the job will run in case of a failure.",
            "format": "int32",
            "type": "integer"
          },
          "nextJobTime": {
            "description": "Expected start time of the next job of the same job type. The return value is None if no new job is scheduled.",
            "format": "date-time",
            "type": "string"
          },
          "nodeId": {
            "description": "Id of the node the job is running on.",
            "type": "string"
          },
          "objectId": {
            "description": "The managed id of the object.",
            "type": "string"
          },
          "objectLogicalSize": {
            "description": "The object size in bytes.",
            "format": "int64",
            "type": "integer"
          },
          "objectName": {
            "description": "The name of the object in the job.",
            "type": "string"
          },
          "objectType": {
            "$ref": "#/components/schemas/ReportableObjectType"
          },
          "retryCount": {
            "description": "The number of times the job has retired.",
            "format": "int32",
            "type": "integer"
          },
          "retryStatus": {
            "$ref": "#/components/schemas/JobMonitoringRetryStatus"
          },
          "slaDomainId": {
            "description": "Sla Domain Id.",
            "type": "string"
          },
          "slaDomainName": {
            "description": "Sla Domain name.",
            "type": "string"
          },
          "sourceClusterName": {
            "description": "For replication jobs, this stores the source cluster name. Leave this value empty for other jobs.",
            "type": "string"
          },
          "startTime": {
            "description": "Start time for running or completed jobs. It is the scheduled start time for Queued jobs.",
            "format": "date-time",
            "type": "string"
          },
          "throughput": {
            "description": "The throughput for running or completed jobs (measured in bytes/s). When no running or completed jobs exist no value is provided.",
            "format": "int64",
            "type": "integer"
          },
          "warningCount": {
            "description": "The number of warning events in the event series associated with the job.",
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "eventSeriesId",
          "isLogTask",
          "isOnDemand",
          "jobMonitoringState",
          "jobStatus",
          "jobType",
          "lastUpdatedTime",
          "objectId",
          "retryStatus",
          "startTime"
        ],
        "type": "object"
      },
      "JobMonitoringJobProgressInfo": {
        "properties": {
          "dataToTransfer": {
            "description": "Amount of data to transfer in bytes.",
            "format": "int64",
            "type": "integer"
          },
          "dataTransferred": {
            "description": "The amount of data transferred in bytes.",
            "format": "int64",
            "type": "integer"
          },
          "monitoring_id": {
            "description": "Monitoring ID of the row.",
            "type": "string"
          },
          "throughput": {
            "description": "The throughput for active jobs (measured in bytes/s). When no active jobs exist, no value is provided.",
            "format": "int64",
            "type": "integer"
          }
        },
        "required": [
          "monitoring_id"
        ],
        "type": "object"
      },
      "JobMonitoringObjectsCountByState": {
        "properties": {
          "active": {
            "description": "The total count of all jobs with the 'Running' status.",
            "format": "int32",
            "type": "integer"
          },
          "canceled": {
            "description": "The total count of all jobs with the 'Canceled' status.",
            "format": "int32",
            "type": "integer"
          },
          "failure": {
            "description": "The total count of all jobs with the 'Failure' status.",
            "format": "int32",
            "type": "integer"
          },
          "scheduled": {
            "description": "The total count of all jobs with the 'Scheduled' status.",
            "format": "int32",
            "type": "integer"
          },
          "success": {
            "description": "The total count of all jobs with the 'Succeeded' status.",
            "format": "int32",
            "type": "integer"
          },
          "total": {
            "description": "The total count of all jobs.",
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "active",
          "canceled",
          "failure",
          "scheduled",
          "success",
          "total"
        ],
        "type": "object"
      },
      "JobMonitoringObjectsCountByType": {
        "properties": {
          "archival": {
            "description": "The total count of all Archival jobs.",
            "format": "int32",
            "type": "integer"
          },
          "backup": {
            "description": "The total count of all Backup jobs.",
            "format": "int32",
            "type": "integer"
          },
          "conversion": {
            "description": "The total count of all Conversion jobs.",
            "format": "int32",
            "type": "integer"
          },
          "index": {
            "description": "The total count of all Index jobs.",
            "format": "int32",
            "type": "integer"
          },
          "logArchival": {
            "description": "The total count of all Log Archival jobs.",
            "format": "int32",
            "type": "integer"
          },
          "logBackup": {
            "description": "The total count of all Log Backup jobs.",
            "format": "int32",
            "type": "integer"
          },
          "logReplication": {
            "description": "The total count of all Log Replication jobs.",
            "format": "int32",
            "type": "integer"
          },
          "logShipping": {
            "description": "The total count of all Log Shipping jobs.",
            "format": "int32",
            "type": "integer"
          },
          "recovery": {
            "description": "The total count of all Recovery jobs.",
            "format": "int32",
            "type": "integer"
          },
          "replication": {
            "description": "The total count of all Replication jobs.",
            "format": "int32",
            "type": "integer"
          },
          "total": {
            "description": "The total count of all jobs.",
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "archival",
          "backup",
          "conversion",
          "index",
          "logArchival",
          "logBackup",
          "logReplication",
          "logShipping",
          "recovery",
          "replication",
          "total"
        ],
        "type": "object"
      },
      "JobMonitoringResponse": {
        "properties": {
          "afterId": {
            "description": "Cursor of the last table row sent in the response. Used for setting the cursor when getting the next page of the table.",
            "type": "string"
          },
          "effectiveSlaDomainId": {
            "description": "The requested SLA domain id (if applicable).",
            "type": "string"
          },
          "hasMore": {
            "description": "A Boolean value that specifies whether or not the list has more elements. This value is 'true' when the list has more elements. This value is 'false' when the list has no more elements.",
            "type": "boolean"
          },
          "isFirstFull": {
            "description": "A Boolean to specify if the jobs are first full backups or not.",
            "type": "boolean"
          },
          "jobEventStatus": {
            "description": "The requested event status of the jobs (if applicable).",
            "items": {
              "$ref": "#/components/schemas/JobMonitoringStatus"
            },
            "type": "array"
          },
          "jobMonitoringInfoList": {
            "description": "A list of jobs.",
            "items": {
              "$ref": "#/components/schemas/JobMonitoringInfo"
            },
            "type": "array"
          },
          "jobType": {
            "$ref": "#/components/schemas/JobMonitoringTaskType"
          },
          "lastUpdateTime": {
            "description": "The earliest possible time at which the latest update to all rows has been made.",
            "format": "date-time",
            "type": "string"
          },
          "nodeName": {
            "description": "The requested node (if applicable).",
            "type": "string"
          },
          "objectName": {
            "description": "The requested object name (if applicable).",
            "type": "string"
          },
          "objectType": {
            "$ref": "#/components/schemas/ReportableObjectType"
          },
          "shouldIncludeLogRelatedJob": {
            "description": "A Boolean to specify whether or not to include log-related jobs.",
            "type": "boolean"
          }
        },
        "required": [
          "hasMore",
          "jobMonitoringInfoList",
          "shouldIncludeLogRelatedJob"
        ],
        "type": "object"
      },
      "JobMonitoringRetryStatus": {
        "description": "Monitoring retry status of the job (default is NotRetried).",
        "enum": [
          "RequestReceived",
          "ScheduleSuccess",
          "ScheduleFailure",
          "NotRetried"
        ],
        "type": "string"
      },
      "JobMonitoringState": {
        "description": "Monitoring state of the job used for monitoring tabs.",
        "enum": [
          "Failure",
          "Scheduled",
          "Success",
          "Active",
          "Canceled"
        ],
        "type": "string"
      },
      "JobMonitoringStatus": {
        "description": "Monitoring status of the job break down.",
        "enum": [
          "Failure",
          "Success",
          "Queued",
          "Scheduled",
          "Active",
          "Canceling",
          "Canceled",
          "SuccessfulWithWarnings",
          "CancelingScheduled"
        ],
        "type": "string"
      },
      "JobMonitoringStream": {
        "properties": {
          "afterId": {
            "description": "The ID to use with subsequent queries to get entires after this entry.",
            "type": "string"
          },
          "jobMonitoringResponse": {
            "$ref": "#/components/schemas/JobMonitoringInfo"
          },
          "monitoringId": {
            "description": "Monitoring ID of the row.",
            "type": "string"
          },
          "rowType": {
            "$ref": "#/components/schemas/MonitoringRowType"
          }
        },
        "required": [
          "afterId",
          "monitoringId",
          "rowType"
        ],
        "type": "object"
      },
      "JobMonitoringStreamingResponse": {
        "properties": {
          "clusterTime": {
            "description": "Current time of the cluster when the request was made.",
            "format": "date-time",
            "type": "string"
          },
          "data": {
            "description": "Response data.",
            "items": {
              "$ref": "#/components/schemas/JobMonitoringStream"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "True if the list has more elements.",
            "type": "boolean"
          }
        },
        "required": [
          "clusterTime",
          "data",
          "hasMore"
        ],
        "type": "object"
      },
      "JobMonitoringSummaryByState": {
        "properties": {
          "jobTypes": {
            "description": "Job types of the jobs included in the result.",
            "items": {
              "$ref": "#/components/schemas/JobMonitoringTaskType"
            },
            "type": "array"
          },
          "lastUpdatedTime": {
            "description": "The time in the cluster time zone at which the counts were updated.",
            "format": "date-time",
            "type": "string"
          },
          "objectCounts": {
            "$ref": "#/components/schemas/JobMonitoringObjectsCountByState"
          }
        },
        "required": [
          "jobTypes",
          "objectCounts"
        ],
        "type": "object"
      },
      "JobMonitoringSummaryByType": {
        "properties": {
          "jobMonitoringState": {
            "$ref": "#/components/schemas/JobMonitoringState"
          },
          "lastUpdatedTime": {
            "description": "The time in the cluster time zone at which the counts were updated.",
            "format": "date-time",
            "type": "string"
          },
          "objectCounts": {
            "$ref": "#/components/schemas/JobMonitoringObjectsCountByType"
          }
        },
        "required": [
          "jobMonitoringState",
          "objectCounts"
        ],
        "type": "object"
      },
      "JobMonitoringTaskType": {
        "description": "Task type.",
        "enum": [
          "Archival",
          "Backup",
          "Conversion",
          "Recovery",
          "Replication",
          "Index",
          "LogBackup",
          "LogArchival",
          "LogReplication",
          "LogShipping"
        ],
        "type": "string"
      },
      "JobScheduledResponse": {
        "properties": {
          "jobInstanceId": {
            "type": "string"
          }
        },
        "required": [
          "jobInstanceId"
        ],
        "type": "object"
      },
      "KmipClientConfiguration": {
        "properties": {
          "clientCertificateId": {
            "description": "The ID of an imported certificate in the CDM certificate management table.",
            "type": "string"
          },
          "password": {
            "description": "The password for the KMIP server.",
            "type": "string",
            "x-secret": true
          },
          "username": {
            "description": "The username for the KMIP server.",
            "type": "string"
          }
        },
        "required": [
          "username"
        ],
        "type": "object"
      },
      "KmipClientDetail": {
        "properties": {
          "clientCertificateId": {
            "description": "The ID of an imported certificate in the CDM certificate management table.",
            "type": "string"
          },
          "isPasswordSet": {
            "description": "Specifies whether a password is configured for authentication. When a password is configured, this value is 'true'. When a password is not configured, this value is 'false'.",
            "type": "boolean"
          },
          "username": {
            "description": "The username for the KMIP server.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "KmipServerConfiguration": {
        "properties": {
          "serverAddress": {
            "description": "The KMIP server's address.",
            "type": "string"
          },
          "serverCertificateId": {
            "description": "ID corresponding to KMIP server's X.509 certificate in Base64 encoded DER format.",
            "type": "string"
          },
          "serverPort": {
            "description": "The KMIP server's port number.",
            "format": "int32",
            "minimum": 0,
            "type": "integer"
          }
        },
        "required": [
          "serverAddress",
          "serverCertificateId"
        ],
        "type": "object"
      },
      "KmipServerDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/KmipServerConfiguration"
          }
        ]
      },
      "KuprHostRegister": {
        "properties": {
          "agentCertificate": {
            "description": "The agent certificate of the registered host. X.509 certificates in Base64 encoded DER format. Each certificate must start with -----BEGIN CERTIFICATE----- and end with -----END CERTIFICATE-----.\n",
            "type": "string"
          },
          "agentId": {
            "description": "The agent ID of the registered host.",
            "type": "string"
          },
          "hostname": {
            "type": "string"
          },
          "ipv4Addresses": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "operatingSystemInfo": {
            "description": "Operating system information of a specified kupr host.",
            "enum": [
              "Linux",
              "Rhel",
              "Ubuntu",
              "Suse",
              "Centos"
            ],
            "type": "string"
          },
          "operatingSystemType": {
            "description": "Operating system of a specified kupr host.",
            "enum": [
              "Linux"
            ],
            "type": "string"
          },
          "operatingSystemVersion": {
            "description": "Operating system version of a specified kupr host.",
            "type": "string"
          }
        },
        "required": [
          "agentCertificate",
          "agentId",
          "hostname",
          "operatingSystemInfo",
          "operatingSystemType"
        ],
        "type": "object"
      },
      "KuprHostUpdate": {
        "properties": {
          "agentCertificate": {
            "description": "The agent certificate of the registered host. X.509 certificates in Base64 encoded DER format. Each certificate must start with -----BEGIN CERTIFICATE----- and end with -----END CERTIFICATE-----.\n",
            "type": "string"
          },
          "agentId": {
            "description": "The agent ID of the registered host.",
            "type": "string"
          },
          "hostname": {
            "type": "string"
          },
          "ipv4Addresses": {
            "description": "An array containing the IPv4 address to Kupr host.\n",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "operatingSystemInfo": {
            "description": "Operating system information of a specified kupr host.",
            "enum": [
              "Linux",
              "Rhel",
              "Ubuntu",
              "Suse",
              "Centos"
            ],
            "type": "string"
          },
          "operatingSystemType": {
            "description": "Operating system of a specified kupr host.",
            "enum": [
              "Linux"
            ],
            "type": "string"
          },
          "operatingSystemVersion": {
            "description": "Operating system version of a specified kupr host.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "LdapDomainName": {
        "properties": {
          "name": {
            "description": "Name of an LDAP domain.",
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "LdapDomainNameListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/LdapDomainName"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "LdapServiceInfo": {
        "properties": {
          "advancedOptions": {
            "$ref": "#/components/schemas/AdvancedLdapConfiguration"
          },
          "authServers": {
            "description": "An ordered list of authentication servers. Servers on this list have priority over servers discovered using dynamic DNS.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "baseDn": {
            "description": "The path to the directory where searches for users begin.",
            "type": "string",
            "x-hidden": true
          },
          "bindUserName": {
            "description": "The name of the user that searches the authentication server for other users.",
            "type": "string"
          },
          "bindUserPassword": {
            "description": "Password for the bind user.",
            "type": "string",
            "x-secret": true
          },
          "certificateId": {
            "description": "ID of the imported certificate to use for connections to this server.",
            "type": "string"
          },
          "dynamicDnsName": {
            "description": "Dynamic DNS name for locating authentication servers.",
            "type": "string"
          },
          "isTotpEnforced": {
            "description": "Indicates whether the time-based one time password (TOTP) authentication method is being enforced. Returns true when TOTP is enforced and false when TOTP is not enforced.\n",
            "type": "boolean"
          },
          "mfaServerId": {
            "description": "MFA server associated with LDAP service.",
            "type": "string"
          },
          "name": {
            "description": "Human friendly name.",
            "type": "string"
          }
        },
        "required": [
          "bindUserName",
          "bindUserPassword"
        ],
        "type": "object"
      },
      "LdapServiceInfoUpdate": {
        "properties": {
          "advancedOptions": {
            "$ref": "#/components/schemas/AdvancedLdapConfiguration"
          },
          "authServers": {
            "description": "An ordered list of authentication servers. Servers on this list have priority over servers discovered using dynamic DNS.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "baseDn": {
            "description": "The path to the directory where searches for users begin.",
            "type": "string",
            "x-hidden": true
          },
          "bindUserName": {
            "description": "The name of the user that searches the authentication server for other users.",
            "type": "string"
          },
          "bindUserPassword": {
            "description": "Password for the bind user.",
            "type": "string",
            "x-secret": true
          },
          "certificateId": {
            "description": "ID of the imported certificate to use for connections to this server.",
            "type": "string"
          },
          "dynamicDnsName": {
            "description": "Dynamic DNS name for locating authentication servers.",
            "type": "string"
          },
          "isTotpEnforced": {
            "description": "Indicates whether the time-based one time password (TOTP) authentication method is being enforced. Returns true when TOTP is enforced and false when TOTP is not enforced.\n",
            "type": "boolean"
          },
          "mfaServerId": {
            "description": "MFA server associated with LDAP service.",
            "type": "string"
          },
          "name": {
            "description": "Human friendly name.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "LdapServiceSummary": {
        "properties": {
          "advancedOptions": {
            "$ref": "#/components/schemas/AdvancedLdapConfiguration"
          },
          "authServers": {
            "description": "An ordered list of authentication servers. Servers on this list have priority over servers discovered using dynamic DNS.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "baseDn": {
            "description": "The path to the directory where searches for users begin.",
            "type": "string",
            "x-hidden": true
          },
          "bindUserName": {
            "description": "The name of the user that searches the authentication server for other users.",
            "type": "string"
          },
          "certificateId": {
            "description": "ID of the imported certificate to use for connections to this server.",
            "type": "string"
          },
          "domainType": {
            "description": "Domain type, for example local or LDAP/Active Directory.",
            "type": "string"
          },
          "dynamicDnsName": {
            "description": "Dynamic DNS name for locating authentication servers.",
            "type": "string"
          },
          "id": {
            "description": "ID of this authentication domain.",
            "type": "string"
          },
          "initialRefreshStatus": {
            "description": "Status message from the initial refresh.",
            "type": "string",
            "x-hidden": true
          },
          "isTotpEnforced": {
            "description": "Indicates whether the time-based one time password (TOTP) authentication method is being enforced. Returns true when TOTP is enforced and false when TOTP is not enforced.\n",
            "type": "boolean"
          },
          "mfaServerId": {
            "description": "MFA server associated with LDAP service.",
            "type": "string"
          },
          "name": {
            "description": "Domain name.",
            "type": "string"
          },
          "serviceAccount": {
            "description": "Computer account name associated with this cluster.",
            "type": "string"
          }
        },
        "required": [
          "domainType",
          "id",
          "name"
        ],
        "type": "object"
      },
      "LdapServiceSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/LdapServiceSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "LegalHoldDownloadConfig": {
        "properties": {
          "isLegalHoldDownload": {
            "description": "Specifies if the download action is in response to a Legal Hold. This download generates a SHA1 checksum of downloaded data that external bodies can use for integrity verification.",
            "type": "boolean"
          }
        },
        "required": [
          "isLegalHoldDownload"
        ],
        "type": "object"
      },
      "LegalHoldObjectSortAttribute": {
        "description": "Attributes that are available to use when sorting query results for objects whose snapshots are on Legal Hold.",
        "enum": [
          "objectName",
          "objectType",
          "numberOfSnapshotsHeld"
        ],
        "type": "string"
      },
      "LegalHoldSnapshotSortAttribute": {
        "description": "Attributes that are available to use when sorting query results for snapshots on Legal Hold.",
        "enum": [
          "SnapshotTime",
          "PlaceOnHoldTime",
          "SnapshotType"
        ],
        "type": "string"
      },
      "LegalHoldSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ObjectHolder"
          },
          {
            "properties": {
              "expectedExpirationDateWithoutLegalHold": {
                "description": "Date at which the snapshot will expire if the legal hold is dissolved.\n",
                "format": "date-time",
                "type": "string"
              },
              "isCustomRetentionApplied": {
                "description": "A Boolean value that indicates whether custom retention is applied to the specified snapshot. Value is true when custom retention is applied to the snapshot.\n",
                "type": "boolean"
              },
              "isOnDemandSnapshot": {
                "description": "A Boolean that specifies whether a snapshot is an On Demand snapshot. When this value is 'true,' the snapshot is an On Demand snapshot.",
                "type": "boolean"
              },
              "locationsPresent": {
                "description": "Current locations of the snapshot.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "placeOnHoldTime": {
                "description": "Time at which the snapshot was put on hold.",
                "format": "date-time",
                "type": "string"
              },
              "snapshotId": {
                "type": "string"
              },
              "snapshotTime": {
                "description": "Time at which the snapshot was taken.",
                "format": "date-time",
                "type": "string"
              }
            },
            "required": [
              "isCustomRetentionApplied",
              "isOnDemandSnapshot",
              "locationsPresent",
              "placeOnHoldTime",
              "snapshotId",
              "snapshotTime"
            ],
            "type": "object"
          }
        ]
      },
      "LegalHoldSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/LegalHoldSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "Link": {
        "properties": {
          "href": {
            "description": "The destination of the link.",
            "type": "string"
          },
          "rel": {
            "description": "The relation of the destination of this link to the current resource.",
            "type": "string"
          }
        },
        "required": [
          "href",
          "rel"
        ],
        "type": "object"
      },
      "LocalUserAccountLockoutConfig": {
        "properties": {
          "accountLockoutDurationInMinutes": {
            "description": "Specifies the duration in minutes after which a locked user account is automatically unlocked. When set to 0, the user account is not unlocked automatically.\n",
            "format": "int32",
            "type": "integer"
          },
          "enabled": {
            "description": "Specifies whether local user accounts are locked. When 'true' the local user account is locked after 'x' failed consecutive login attempts where 'x' is specified by 'maxFailedLoginsForLocalUser'. When 'false' failed login attempts are not recorded and will not lock the local user account.\n",
            "type": "boolean"
          },
          "maxFailedLoginsForLocalUser": {
            "description": "Specifies the number of consecutive failed logins after which the local user account is locked.\n",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "LocalUserAccountLockoutStatus": {
        "properties": {
          "accountLockoutDurationInMinutes": {
            "description": "Specifies the duration in minutes after which a locked user account is automatically unlocked. When set to 0, the user account is not unlocked automatically.\n",
            "format": "int32",
            "type": "integer"
          },
          "enabled": {
            "description": "Specifies whether local user accounts are locked. When 'true' the local user account is locked after 'x' failed consecutive login attempts where 'x' is specified by 'maxFailedLoginsForLocalUser'. When 'false' failed login attempts are not recorded and will not lock the local user account.\n",
            "type": "boolean"
          },
          "maxFailedLoginsForLocalUser": {
            "description": "Specifies the number of consecutive failed logins after which the local user account is locked.\n",
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "accountLockoutDurationInMinutes",
          "enabled",
          "maxFailedLoginsForLocalUser"
        ],
        "type": "object"
      },
      "LocationPathPoint": {
        "properties": {
          "managedId": {
            "type": "string"
          },
          "name": {
            "type": "string"
          }
        },
        "required": [
          "managedId",
          "name"
        ],
        "type": "object"
      },
      "LsnRecoveryPoint": {
        "properties": {
          "lsn": {
            "description": "LSN of the recovery point.",
            "type": "string"
          },
          "recoveryForkGuid": {
            "description": "Recovery fork GUID of the recovery point. If not provided, the recovery fork GUID of the latest snapshot is used.",
            "type": "string"
          }
        },
        "required": [
          "lsn"
        ],
        "type": "object"
      },
      "ManagedHierarchyObjectAncestor": {
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          }
        },
        "required": [
          "id",
          "name"
        ],
        "type": "object"
      },
      "ManagedHierarchyObjectSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Snappable"
          },
          {
            "properties": {
              "infraPath": {
                "items": {
                  "$ref": "#/components/schemas/ManagedHierarchyObjectAncestor"
                },
                "type": "array"
              },
              "isDeleted": {
                "description": "Indicates whether the managed hierarchy object is deleted.",
                "type": "boolean"
              },
              "isRelic": {
                "description": "Whether this managed object is a relic (an archived snappable with unexpired snapshots).",
                "type": "boolean"
              },
              "slaPath": {
                "items": {
                  "$ref": "#/components/schemas/ManagedHierarchyObjectAncestor"
                },
                "type": "array"
              }
            },
            "required": [
              "isDeleted",
              "isRelic"
            ],
            "type": "object"
          }
        ]
      },
      "ManagedObjectDescendantCountVcdVappFields": {
        "properties": {
          "vapp": {
            "description": "Number of vCD vApps.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "ManagedObjectPendingSlaInfo": {
        "properties": {
          "isPendingSlaDomainRetentionLocked": {
            "type": "boolean"
          },
          "objectId": {
            "description": "Managed ID of the object.",
            "type": "string"
          },
          "pendingSlaDomainId": {
            "type": "string"
          },
          "pendingSlaDomainName": {
            "type": "string"
          }
        },
        "required": [
          "objectId",
          "pendingSlaDomainId",
          "pendingSlaDomainName"
        ],
        "type": "object"
      },
      "ManagedVolumeSlaObjectCount": {
        "properties": {
          "numManagedVolumes": {
            "description": "The number of Managed volumes protected under this SLA Domain.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "ManualDiscoveryNodeInfo": {
        "properties": {
          "nodeInfo": {
            "items": {
              "$ref": "#/components/schemas/BootstrappableNodeInfoV1"
            },
            "type": "array"
          }
        },
        "required": [
          "nodeInfo"
        ],
        "type": "object"
      },
      "ManualDiscoveryNodeIpv4Info": {
        "properties": {
          "nodeInfo": {
            "items": {
              "$ref": "#/components/schemas/BootstrappableNodeIpv4Info"
            },
            "type": "array"
          }
        },
        "required": [
          "nodeInfo"
        ],
        "type": "object"
      },
      "Map_Boolean": {
        "additionalProperties": {
          "type": "boolean"
        },
        "type": "object"
      },
      "Map_String": {
        "additionalProperties": {
          "type": "string"
        },
        "type": "object"
      },
      "MfaServerConfig": {
        "properties": {
          "name": {
            "description": "Specifies the name to identify MFA server configuration.\n",
            "type": "string"
          },
          "timeout": {
            "default": 120,
            "description": "Specifies a number of seconds to wait for server response to a given authentication method.\n",
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "MissedSnapshot": {
        "properties": {
          "archivalLocationType": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "missedSnapshotTime": {
            "format": "date-time",
            "type": "string"
          },
          "missedSnapshotTimeUnits": {
            "items": {
              "$ref": "#/components/schemas/MissedSnapshotTimeUnitConfig"
            },
            "type": "array"
          }
        },
        "required": [
          "archivalLocationType",
          "missedSnapshotTime",
          "missedSnapshotTimeUnits"
        ],
        "type": "object"
      },
      "MissedSnapshotDayOfTimeUnit": {
        "description": "Units for missed snapshot dayOfTime.",
        "enum": [
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday",
          "Sunday",
          "FirstDay",
          "Fifteenth",
          "LastDay"
        ],
        "type": "string"
      },
      "MissedSnapshotListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/MissedSnapshot"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "MissedSnapshotTimeUnitConfig": {
        "properties": {
          "dayOfTime": {
            "$ref": "#/components/schemas/MissedSnapshotDayOfTimeUnit"
          },
          "frequency": {
            "format": "int32",
            "type": "integer"
          },
          "retention": {
            "format": "int32",
            "type": "integer"
          },
          "timeUnit": {
            "$ref": "#/components/schemas/SlaTimeUnit"
          }
        },
        "required": [
          "frequency",
          "retention",
          "timeUnit"
        ],
        "type": "object"
      },
      "MonitoringEmailSubscriptionRequest": {
        "properties": {
          "attachments": {
            "description": "Attachment files to send with the subscription.",
            "items": {
              "$ref": "#/components/schemas/SubscriptionAttachmentType"
            },
            "type": "array"
          },
          "emailAddresses": {
            "description": "Email addresses to send monitoring subscriptions to.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "jobStates": {
            "description": "User-selected job states.",
            "items": {
              "$ref": "#/components/schemas/JobMonitoringState"
            },
            "type": "array"
          },
          "timeAttributes": {
            "$ref": "#/components/schemas/SubscriptionScheduleTimeAttributes"
          }
        },
        "required": [
          "attachments",
          "emailAddresses",
          "jobStates",
          "timeAttributes"
        ],
        "type": "object"
      },
      "MonitoringEmailSubscriptionUpdate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/MonitoringEmailSubscriptionRequest"
          },
          {
            "properties": {
              "assumeOwnership": {
                "description": "Changes the owner of an email subscription object to the username of the account that is logged into the current session.",
                "type": "boolean"
              },
              "id": {
                "description": "ID assigned to an email subscription object.",
                "type": "string"
              }
            },
            "required": [
              "id"
            ],
            "type": "object"
          }
        ]
      },
      "MonitoringRowType": {
        "description": "The job monitoring row type.",
        "enum": [
          "Upsert",
          "Deletion"
        ],
        "type": "string"
      },
      "MonitoringSubscriptionSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/MonitoringEmailSubscriptionRequest"
          },
          {
            "properties": {
              "id": {
                "description": "ID assigned to an email subscription object.",
                "type": "string"
              },
              "owner": {
                "$ref": "#/components/schemas/SubscriptionOwner"
              },
              "status": {
                "$ref": "#/components/schemas/SubscriptionStatus"
              }
            },
            "required": [
              "id",
              "status"
            ],
            "type": "object"
          }
        ]
      },
      "MonthlyConfig": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FrequencyConfig"
          },
          {
            "properties": {
              "dayOfMonth": {
                "$ref": "#/components/schemas/SlaDayOfMonth"
              }
            },
            "required": [
              "dayOfMonth"
            ],
            "type": "object"
          }
        ]
      },
      "MountExportSnapshotJobCommonOptions": {
        "properties": {
          "disableNetwork": {
            "description": "Sets the state of the network interfaces when the virtual machine is mounted or exported. Use 'false' to enable the network interfaces. Use 'true' to disable the network interfaces. Disabling the interfaces can prevent IP conflicts.",
            "type": "boolean"
          },
          "keepMacAddresses": {
            "description": "Determines whether the MAC addresses of the network interfaces on the source virtual machine are assigned to the new virtual machine. Set to 'true' to assign the original MAC addresses to the new virtual machine. Set to 'false' to assign new MAC addresses. The default is 'false'. When removeNetworkDevices is set to true, this property is ignored.",
            "type": "boolean"
          },
          "powerOn": {
            "description": "Determines whether the virtual machine should be powered on after mount or export. Set to 'true' to power on the virtual machine. Set to 'false' to mount or export the virtual machine but not power it on. The default is 'true'.",
            "type": "boolean"
          },
          "removeNetworkDevices": {
            "description": "Determines whether to remove the network interfaces from the mounted or exported virtual machine. Set to 'true' to remove all network interfaces. The default value is 'false'.",
            "type": "boolean"
          },
          "vmName": {
            "description": "Name of the new VM created by mount or export.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "MountMssqlDbConfig": {
        "properties": {
          "mountedDatabaseName": {
            "description": "Name to assign to the mounted database.",
            "type": "string"
          },
          "recoveryModel": {
            "$ref": "#/components/schemas/MssqlDatabaseRecoveryModel"
          },
          "recoveryPoint": {
            "$ref": "#/components/schemas/MssqlRecoveryPoint"
          },
          "targetInstanceId": {
            "description": "ID of the SQL Server instance to mount the database on. For availability source databases, this must be specified. When unspecified for non-availability source databases, the source SQL Server instance is used.",
            "type": "string"
          }
        },
        "required": [
          "mountedDatabaseName",
          "recoveryPoint"
        ],
        "type": "object"
      },
      "MountSnapshotJobConfigForBatchV1": {
        "properties": {
          "config": {
            "$ref": "#/components/schemas/MountSnapshotJobConfigV1"
          },
          "snapshotAfterDate": {
            "description": "Mounts the oldest snapshot taken after the specified date. This parameter is only evaluated when no values are set for snapshotId and snapshotBeforeDate.",
            "format": "date-time",
            "type": "string"
          },
          "snapshotBeforeDate": {
            "description": "Mounts the most recent snapshot taken prior to the specified date. This parameter is only evaluated when no value is set for snapshotId.",
            "format": "date-time",
            "type": "string"
          },
          "snapshotId": {
            "description": "The ID of the snapshot to export. This parameter is optional if either of the `snapshotBeforeDate` or `snapshotAfterDate` parameters is configured.",
            "type": "string"
          },
          "vmId": {
            "description": "ID of the virtual machine whose snapshot needs to be mounted.",
            "type": "string"
          }
        },
        "required": [
          "config",
          "vmId"
        ],
        "type": "object"
      },
      "MountSnapshotJobConfigV1": {
        "allOf": [
          {
            "$ref": "#/components/schemas/MountExportSnapshotJobCommonOptions"
          },
          {
            "properties": {
              "createDatastoreOnly": {
                "description": "The job creates a datastore that contains the VMDK, but does not create the corresponding virtual machine.",
                "type": "boolean"
              },
              "dataStoreName": {
                "description": "Obsolete parameter.",
                "type": "string"
              },
              "hostId": {
                "description": "ID of the ESXi host to mount the new virtual machine on.",
                "type": "string"
              },
              "shouldRecoverTags": {
                "description": "The job recovers the tags that were assigned to the virtual machine.",
                "type": "boolean"
              },
              "vlan": {
                "description": "VLAN ID for the VLAN ESXi host prefer to use for mounting the datastore.",
                "format": "int32",
                "type": "integer"
              }
            },
            "type": "object"
          }
        ]
      },
      "MssqlAvailabilityGroupDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/MssqlAvailabilityGroupSummary"
          }
        ]
      },
      "MssqlAvailabilityGroupSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Snappable"
          },
          {
            "$ref": "#/components/schemas/MssqlSlaRelatedProperties"
          }
        ]
      },
      "MssqlAvailabilityGroupSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/MssqlAvailabilityGroupSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "MssqlAvailabilityGroupUpdate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/MssqlSlaPatchProperties"
          }
        ]
      },
      "MssqlBackup": {
        "properties": {
          "backupId": {
            "description": "The unique identifier for the object.",
            "type": "string"
          },
          "backupSize": {
            "description": "The total uncompressed size of the files in bytes.",
            "format": "int64",
            "type": "integer"
          },
          "backupType": {
            "$ref": "#/components/schemas/MssqlBackupType"
          },
          "date": {
            "description": "Timestamp of the backup.",
            "format": "date-time",
            "type": "string"
          },
          "lsn": {
            "description": "LSN of the backup.",
            "type": "string"
          },
          "path": {
            "description": "The file path the backup will be stored at in downloaded zip files containing it.",
            "type": "string"
          },
          "recoveryForkGuid": {
            "description": "GUID of the recovery fork attached to the LSN.",
            "type": "string"
          }
        },
        "required": [
          "backupId",
          "backupSize",
          "backupType",
          "date",
          "lsn",
          "path",
          "recoveryForkGuid"
        ],
        "type": "object"
      },
      "MssqlBackupJobConfig": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseOnDemandSnapshotConfig"
          },
          {
            "properties": {
              "forceFullSnapshot": {
                "description": "Whether to force a full snapshot or an incremental.",
                "type": "boolean"
              }
            },
            "type": "object"
          }
        ]
      },
      "MssqlBackupSelection": {
        "properties": {
          "backupType": {
            "$ref": "#/components/schemas/MssqlBackupType"
          },
          "endPoint": {
            "$ref": "#/components/schemas/MssqlRecoveryPoint"
          },
          "legalHoldDownloadConfig": {
            "$ref": "#/components/schemas/LegalHoldDownloadConfig"
          },
          "recoveryPoint": {
            "$ref": "#/components/schemas/MssqlRecoveryPoint"
          },
          "startPoint": {
            "$ref": "#/components/schemas/MssqlRecoveryPoint"
          }
        },
        "type": "object"
      },
      "MssqlBackupType": {
        "description": "The type of the backup.",
        "enum": [
          "Snapshot",
          "Log"
        ],
        "type": "string"
      },
      "MssqlBackups": {
        "properties": {
          "items": {
            "description": "A list of snapshots and logs.",
            "items": {
              "$ref": "#/components/schemas/MssqlBackup"
            },
            "type": "array"
          }
        },
        "required": [
          "items"
        ],
        "type": "object"
      },
      "MssqlBatchBackupCanceledSummary": {
        "properties": {
          "databaseId": {
            "description": "ID of the Microsoft SQL database.",
            "type": "string"
          }
        },
        "required": [
          "databaseId"
        ],
        "type": "object"
      },
      "MssqlBatchBackupFailureSummary": {
        "properties": {
          "databaseId": {
            "description": "ID of the Microsoft SQL database.",
            "type": "string"
          },
          "error": {
            "description": "Information specifying why this snapshot failed.",
            "type": "string"
          }
        },
        "required": [
          "databaseId",
          "error"
        ],
        "type": "object"
      },
      "MssqlBatchBackupJobConfig": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseOnDemandSnapshotConfig"
          },
          {
            "properties": {
              "availabilityGroupIds": {
                "description": "IDs of the Microsoft SQL availability groups. All databases with a `rootId` belonging to this list are considered for taking an on demand snapshot.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "databaseIds": {
                "description": "IDs of the Microsoft SQL databases. All databases in this list are considered for taking an on demand snapshot.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "forceFullSnapshot": {
                "description": "Determines whether to force a full or incremental snapshot.",
                "type": "boolean"
              },
              "hostIds": {
                "description": "IDs of the hosts. All databases with a `rootId` belonging to this list are considered for taking an on demand snapshot.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "instanceIds": {
                "description": "IDs of the Microsoft SQL instances. All non-availability databases on these instances are considered for taking an on demand snapshot.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "windowsClusterIds": {
                "description": "IDs of the Windows clusters. All databases with a `rootId` belonging to this list are considered for taking an on demand snapshot.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            },
            "type": "object"
          }
        ]
      },
      "MssqlBatchBackupSuccessSummary": {
        "properties": {
          "databaseId": {
            "description": "ID of the Mirosoft SQL database.",
            "type": "string"
          },
          "snapshotId": {
            "description": "ID of the snapshot.",
            "type": "string"
          }
        },
        "required": [
          "databaseId",
          "snapshotId"
        ],
        "type": "object"
      },
      "MssqlBatchBackupSummary": {
        "properties": {
          "canceledSnapshots": {
            "description": "List of summary information for each canceled snapshot.",
            "items": {
              "$ref": "#/components/schemas/MssqlBatchBackupCanceledSummary"
            },
            "type": "array"
          },
          "failedSnapshots": {
            "description": "List of summary information for each failed snapshot.",
            "items": {
              "$ref": "#/components/schemas/MssqlBatchBackupFailureSummary"
            },
            "type": "array"
          },
          "id": {
            "description": "ID of the on-demand backup request.",
            "type": "string"
          },
          "successfulSnapshots": {
            "description": "List of summary information for each successful snapshot.",
            "items": {
              "$ref": "#/components/schemas/MssqlBatchBackupSuccessSummary"
            },
            "type": "array"
          }
        },
        "required": [
          "canceledSnapshots",
          "failedSnapshots",
          "id",
          "successfulSnapshots"
        ],
        "type": "object"
      },
      "MssqlCbtEffectiveStatusType": {
        "description": "Effective CBT host status.",
        "enum": [
          "On",
          "Off",
          "OnDefault",
          "OffDefault"
        ],
        "type": "string"
      },
      "MssqlCbtStatusType": {
        "description": "CBT host support status.",
        "enum": [
          "Enabled",
          "Disabled",
          "Default"
        ],
        "type": "string"
      },
      "MssqlDatabaseFileType": {
        "description": "File type of a database file.",
        "enum": [
          "Data",
          "Log",
          "Filestream"
        ],
        "type": "string"
      },
      "MssqlDatabaseListSortAttribute": {
        "description": "The field by which to sort when enumerating database summary information.",
        "enum": [
          "copyOnly",
          "effectiveSlaDomainName",
          "logBackupRetentionHours",
          "name"
        ],
        "type": "string"
      },
      "MssqlDatabaseRecoveryModel": {
        "description": "Recovery model for a SQL Server database.",
        "enum": [
          "SIMPLE",
          "FULL",
          "BULK_LOGGED"
        ],
        "type": "string"
      },
      "MssqlDbDefaults": {
        "properties": {
          "cbtStatus": {
            "description": "True to enable a CBT-based backup, false to disable a CBT-based backup.",
            "type": "boolean"
          },
          "logBackupFrequencyInSeconds": {
            "format": "int64",
            "type": "integer"
          },
          "logRetentionTimeInHours": {
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "cbtStatus",
          "logBackupFrequencyInSeconds",
          "logRetentionTimeInHours"
        ],
        "type": "object"
      },
      "MssqlDbDefaultsUpdate": {
        "properties": {
          "cbtStatus": {
            "description": "True to enable a CBT-based backup, false to disable a CBT-based backup.",
            "type": "boolean"
          },
          "logBackupFrequencyInSeconds": {
            "format": "int64",
            "type": "integer"
          },
          "logRetentionTimeInHours": {
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "MssqlDbDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/MssqlDbSummary"
          },
          {
            "$ref": "#/components/schemas/BlackoutWindowResponseInfo"
          },
          {
            "properties": {
              "archiveStorage": {
                "format": "int64",
                "type": "integer"
              },
              "isLocal": {
                "type": "boolean"
              },
              "isStandby": {
                "description": "This field is deprecated. Use the isStandby field on the replicas list instead. This field will continue to work for non-availability databases, but it is meaningless for availability databases.",
                "type": "boolean"
              },
              "latestRecoveryPoint": {
                "format": "date",
                "type": "string"
              },
              "localStorage": {
                "format": "int64",
                "type": "integer"
              },
              "maxDataStreams": {
                "format": "int32",
                "type": "integer"
              },
              "oldestRecoveryPoint": {
                "format": "date",
                "type": "string"
              },
              "postBackupScript": {
                "$ref": "#/components/schemas/MssqlScriptDetail"
              },
              "preBackupScript": {
                "$ref": "#/components/schemas/MssqlScriptDetail"
              },
              "protectionDate": {
                "format": "date",
                "type": "string"
              },
              "recoveryForkGuid": {
                "description": "This field is deprecated. Use the recoveryForkGuid field on the replicas list instead. This field will continue to work for non-availability databases, but it is meaningless for availability databases.",
                "type": "string"
              },
              "snapshotCount": {
                "format": "int32",
                "type": "integer"
              }
            },
            "required": [
              "snapshotCount"
            ],
            "type": "object"
          }
        ]
      },
      "MssqlDbFileExportPath": {
        "properties": {
          "exportPath": {
            "description": "The target path for the database file.",
            "type": "string"
          },
          "logicalName": {
            "description": "Logical name of the database file.",
            "type": "string"
          },
          "newFilename": {
            "description": "New filename for the database file.",
            "type": "string"
          },
          "newLogicalName": {
            "description": "New logical name for the database file.",
            "type": "string"
          }
        },
        "required": [
          "exportPath",
          "logicalName"
        ],
        "type": "object"
      },
      "MssqlDbReplica": {
        "properties": {
          "availabilityInfo": {
            "$ref": "#/components/schemas/MssqlDbReplicaAvailabilityInfo"
          },
          "hasPermissions": {
            "description": "`True` when the Rubrik cluster has sufficient permissions to perform all necessary operations.",
            "type": "boolean"
          },
          "instanceId": {
            "description": "ID of the SQL Server instance managing the replica.",
            "type": "string"
          },
          "instanceName": {
            "description": "Name of the SQL Server instance managing the replica.",
            "type": "string"
          },
          "isArchived": {
            "description": "Deprecated. Please use 'isDeleted' instead.",
            "type": "boolean"
          },
          "isDeleted": {
            "description": "`True` when the replica is deleted.",
            "type": "boolean"
          },
          "isStandby": {
            "description": "`True` when the replica is in standby mode.",
            "type": "boolean"
          },
          "recoveryForkGuid": {
            "description": "The recovery fork GUID of the replica.",
            "type": "string"
          },
          "recoveryModel": {
            "description": "The recovery model of the replica.",
            "enum": [
              "SIMPLE",
              "FULL",
              "BULK_LOGGED"
            ],
            "type": "string"
          },
          "rootProperties": {
            "$ref": "#/components/schemas/MssqlRootProperties"
          },
          "state": {
            "description": "The state of the replica.",
            "type": "string"
          }
        },
        "required": [
          "hasPermissions",
          "instanceId",
          "instanceName",
          "isArchived",
          "isDeleted",
          "isStandby",
          "recoveryModel",
          "rootProperties",
          "state"
        ],
        "type": "object"
      },
      "MssqlDbReplicaAvailabilityInfo": {
        "properties": {
          "role": {
            "description": "Role of the availability database replica. Possible values are: `PRIMARY`, `SECONDARY`, or `RESOLVING`.",
            "enum": [
              "PRIMARY",
              "SECONDARY",
              "RESOLVING"
            ],
            "type": "string"
          }
        },
        "required": [
          "role"
        ],
        "type": "object"
      },
      "MssqlDbSlaObjectCount": {
        "properties": {
          "numDbs": {
            "description": "The number of actively protected databases under this SLA domain.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "MssqlDbSnapshotDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseSnapshotSummary"
          },
          {
            "$ref": "#/components/schemas/BaseSnapshotDetail"
          },
          {
            "properties": {
              "canLiveMount": {
                "type": "boolean"
              },
              "database": {
                "$ref": "#/components/schemas/MssqlDbSummary"
              }
            },
            "required": [
              "canLiveMount"
            ],
            "type": "object"
          }
        ]
      },
      "MssqlDbSnapshotSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseSnapshotSummary"
          },
          {
            "properties": {
              "canLiveMount": {
                "type": "boolean"
              },
              "databaseName": {
                "type": "string"
              }
            },
            "required": [
              "canLiveMount",
              "databaseName"
            ],
            "type": "object"
          }
        ]
      },
      "MssqlDbSnapshotSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/MssqlDbSnapshotSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "MssqlDbSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Snappable"
          },
          {
            "properties": {
              "availabilityGroupId": {
                "description": "For an availability database, the ID of the availability group that the database belongs to.",
                "type": "string"
              },
              "copyOnly": {
                "description": "Boolean value that specifies whether or not to perform copy-only backups of the database. When true, database backups are copy-only backups. When false, database backups are full backups.",
                "type": "boolean"
              },
              "currentBackupTaskInfo": {
                "$ref": "#/components/schemas/BackupTaskDiagnosticInfo"
              },
              "hasPermissions": {
                "description": "A Boolean value that specifies whether the cluster has permission to back up the database. When this value is 'true', the cluster has permission to back up the database.",
                "type": "boolean"
              },
              "id": {
                "type": "string"
              },
              "includeBackupTaskInfo": {
                "description": "True/false value indicating if backup task information is included in the response.",
                "type": "boolean"
              },
              "instanceId": {
                "description": "This field is deprecated. Use the instanceId field on the replicas list instead. This field will continue to work for non-availability databases, but it is meaningless for availability databases.",
                "type": "string"
              },
              "instanceName": {
                "description": "This field is deprecated. Use the instanceName field on the replicas list instead. This field will continue to work for non-availability databases, but it is meaningless for availability databases.",
                "type": "string"
              },
              "isInAvailabilityGroup": {
                "type": "boolean"
              },
              "isLiveMount": {
                "description": "Boolean value that specifies whether a database object is a Live Mount. Value is 'true' when the database object is a Live Mount.",
                "type": "boolean"
              },
              "isLogShippingSecondary": {
                "description": "Boolean value that specifies whether a database object represents a secondary database. Value is 'true' when the database object represents a secondary database in a log shipping configuration.",
                "type": "boolean"
              },
              "isOnline": {
                "description": "A Boolean value that specifies whether the database is in the ONLINE state. When this value is 'true', the database is in the ONLINE state.",
                "type": "boolean"
              },
              "isRelic": {
                "type": "boolean"
              },
              "lastSnapshotTime": {
                "description": "The timestamp of the previous snapshot.. Only available in the /v1/mssql/db endpoint request body. The information will not be available for other endpoints.",
                "format": "date-time",
                "type": "string"
              },
              "logBackupFrequencyInSeconds": {
                "format": "int32",
                "type": "integer"
              },
              "logBackupRetentionHours": {
                "description": "Hours to keep a log backup. A value of -1 indicates that a log will only expire when the preceding snapshots have expired.",
                "format": "int32",
                "type": "integer"
              },
              "name": {
                "type": "string"
              },
              "numMissedSnapshot": {
                "description": "An integer that specifies the number of missed snapshots. Only available in the /v1/mssql/db endpoint request body. The information will not be available for other endpoints.",
                "format": "int32",
                "type": "integer"
              },
              "pendingSlaDomain": {
                "$ref": "#/components/schemas/ManagedObjectPendingSlaInfo"
              },
              "primaryClusterId": {
                "type": "string"
              },
              "recoveryModel": {
                "description": "This field is deprecated. Use the recoveryModel field on the replicas list instead. This field will continue to work for non-availability databases, but it is meaningless for availability databases.",
                "enum": [
                  "SIMPLE",
                  "FULL",
                  "BULK_LOGGED"
                ],
                "type": "string"
              },
              "replicas": {
                "description": "List of replicas of this database. An availability database may have multiple replicas, while other databases will have only one replica.",
                "items": {
                  "$ref": "#/components/schemas/MssqlDbReplica"
                },
                "type": "array"
              },
              "rootProperties": {
                "$ref": "#/components/schemas/MssqlRootProperties"
              },
              "state": {
                "description": "This field is deprecated. Use the state field on the replicas list instead. This field will continue to work for non-availability databases, but it is meaningless for availability databases.",
                "type": "string"
              },
              "unprotectableReasons": {
                "description": "A list of reasons that a SQL Server database cannot be protected by the Rubrik CDM.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            },
            "required": [
              "copyOnly",
              "hasPermissions",
              "id",
              "isInAvailabilityGroup",
              "isLiveMount",
              "isLogShippingSecondary",
              "isOnline",
              "isRelic",
              "logBackupFrequencyInSeconds",
              "logBackupRetentionHours",
              "name",
              "numMissedSnapshot",
              "primaryClusterId",
              "replicas",
              "rootProperties",
              "unprotectableReasons"
            ],
            "type": "object"
          }
        ]
      },
      "MssqlDbSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/MssqlDbSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "MssqlDbUpdate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/MssqlSlaPatchProperties"
          },
          {
            "properties": {
              "isPaused": {
                "description": "Whether to pause or resume backups/archival for this database.",
                "type": "boolean"
              },
              "maxDataStreams": {
                "description": "Maximum number of parallel data streams that can be used to back up the database.",
                "format": "int32",
                "type": "integer"
              },
              "postBackupScript": {
                "$ref": "#/components/schemas/MssqlScriptDetail"
              },
              "preBackupScript": {
                "$ref": "#/components/schemas/MssqlScriptDetail"
              },
              "shouldForceFull": {
                "description": "Determines whether to force a full for the next snapshot of a SQL Server database. When this value is true, the Rubrik cluster takes a full snapshot. This value is false by default and is reset to false after a successful full snapshot.",
                "type": "boolean"
              }
            },
            "type": "object"
          }
        ]
      },
      "MssqlDbUpdateId": {
        "properties": {
          "databaseId": {
            "description": "ID of the Microsoft SQL database.",
            "type": "string"
          },
          "updateProperties": {
            "$ref": "#/components/schemas/MssqlDbUpdate"
          }
        },
        "required": [
          "databaseId",
          "updateProperties"
        ],
        "type": "object"
      },
      "MssqlDownloadFromArchiveConfig": {
        "properties": {
          "recoveryPoint": {
            "$ref": "#/components/schemas/MssqlRecoveryPoint"
          }
        },
        "required": [
          "recoveryPoint"
        ],
        "type": "object"
      },
      "MssqlHierarchyObjectDescendantCount": {
        "properties": {
          "MssqlDatabase": {
            "format": "int32",
            "type": "integer"
          },
          "MssqlInstance": {
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "MssqlHierarchyObjectSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ManagedHierarchyObjectSummary"
          },
          {
            "$ref": "#/components/schemas/MssqlSlaRelatedProperties"
          },
          {
            "properties": {
              "cbtEffectiveStatus": {
                "$ref": "#/components/schemas/MssqlHostCbtEffectiveStatusType"
              },
              "cbtEnabled": {
                "$ref": "#/components/schemas/MssqlHostCbtStatusType"
              },
              "clusterInstanceAddress": {
                "description": "Property that indicates the address of the instance in a Windows Server failover cluster. This property is only set when the value of objectType is MssqlInstance, when the instance belongs to a Windows Server failover cluster, and when the address is known.\n",
                "type": "string"
              },
              "descendantCount": {
                "$ref": "#/components/schemas/MssqlHierarchyObjectDescendantCount"
              },
              "descendantSlaDomains": {
                "description": "Lists the effective SLA Domains of this object's child SQL Server instances. This property is set when the value of objectType is Host or WindowsCluster.\n",
                "items": {
                  "$ref": "#/components/schemas/MssqlSlaDomainInfo"
                },
                "type": "array"
              },
              "hasInstances": {
                "description": "A Boolean that specifies whether the object has children of type MssqlInstance. This property is only set when the value of objectType is Host or WindowsCluster.\n",
                "type": "boolean"
              },
              "hasPermissions": {
                "description": "Boolean value that specifies whether the cluster has permission to back up the database. This property is only set when the value of objectType is MssqlDatabase.",
                "type": "boolean"
              },
              "hostStatus": {
                "description": "Property that indicates the current connection status of a Windows host.This property is only set when the value of objectType is Host.",
                "type": "string"
              },
              "hosts": {
                "description": "This property is only used with SQL Server availability groups. Every object in a SQL Server availability group has the Host rootType.\n",
                "items": {
                  "$ref": "#/components/schemas/MssqlRootProperties"
                },
                "type": "array"
              },
              "instanceChildren": {
                "description": "A list of children of type MssqlInstance. This property is only set when the value of objectType is Host or WindowsCluster.\n",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "instanceChildrenInfo": {
                "description": "MssqlInstanceShortSummary list providing information about MssqlInstance children. This property is set only when the value of objectType is WindowsCluster.\n",
                "items": {
                  "$ref": "#/components/schemas/MssqlInstanceShortSummary"
                },
                "type": "array"
              },
              "isClustered": {
                "description": "A Boolean that specifies whether the object is clustered. This property is only set when the value of objectType is MssqlInstance or MssqlDatabase.\n",
                "type": "boolean"
              },
              "isInAvailabilityGroup": {
                "description": "Boolean value that specifies whether this database is part of an availability group. This property is only set when the value of objectType is MssqlDatabase.",
                "type": "boolean"
              },
              "isLiveMount": {
                "description": "Boolean value that specifies whether a database object is a Live Mount. Value is 'true' when the database object is a Live Mount. This property is only set when the value of objectType is MssqlDatabase.",
                "type": "boolean"
              },
              "isLogShippingSecondary": {
                "description": "Boolean value that specifies whether a database object represents a secondary database. Value is 'true' when the database object represents a secondary database in a log shipping configuration. This property is only set when the value of objectType is MssqlDatabase.",
                "type": "boolean"
              },
              "objectType": {
                "$ref": "#/components/schemas/MssqlHierarchyObjectType"
              },
              "pendingSlaDomain": {
                "$ref": "#/components/schemas/ManagedObjectPendingSlaInfo"
              },
              "replicas": {
                "description": "A list of the replicas available for the specified database. Databases that are not in an availability group have only a single replica. This property is only set when the value of objectType is MssqlDatabase.\n",
                "items": {
                  "$ref": "#/components/schemas/MssqlDbReplica"
                },
                "type": "array"
              },
              "unprotectableReasons": {
                "description": "A list of reasons that a SQL Server database cannot be protected by the Rubrik CDM. This property is only set when the value of objectType is MssqlDatabase.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            },
            "required": [
              "descendantCount",
              "objectType"
            ],
            "type": "object"
          }
        ]
      },
      "MssqlHierarchyObjectSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/MssqlHierarchyObjectSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "MssqlHierarchyObjectType": {
        "description": "The type of the SQL Server hierarchy object.",
        "enum": [
          "Host",
          "MssqlInstance",
          "MssqlDatabase",
          "WindowsCluster",
          "MssqlAvailabilityGroup"
        ],
        "type": "string"
      },
      "MssqlHostCbtEffectiveStatusType": {
        "description": "Effective CBT status for Host/Windows Failover Cluster.",
        "enum": [
          "On",
          "Off",
          "PartiallyEnabled",
          "OnDefault",
          "OffDefault"
        ],
        "type": "string"
      },
      "MssqlHostCbtStatusType": {
        "description": "CBT host support status.",
        "enum": [
          "Enabled",
          "Disabled",
          "Default"
        ],
        "type": "string"
      },
      "MssqlHostConfiguration": {
        "properties": {
          "enableDatabaseBatchSnapshots": {
            "$ref": "#/components/schemas/HostConfigurationPropertyEnabled"
          },
          "enableGroupFetch": {
            "$ref": "#/components/schemas/HostConfigurationPropertyEnabled"
          },
          "enableVdi": {
            "$ref": "#/components/schemas/HostConfigurationPropertyEnabled"
          },
          "enableVdiDb": {
            "$ref": "#/components/schemas/HostConfigurationPropertyEnabled"
          },
          "fileRestoreReadParallelism": {
            "description": "Number of concurrent read requests for restoring a file from the Rubrik cluster to a remote host.",
            "format": "int32",
            "type": "integer"
          },
          "fileRestoreWriteParallelism": {
            "description": "Number of concurrent write requests for restoring a file from the Rubrik cluster to a remote host.",
            "format": "int32",
            "type": "integer"
          },
          "fileTransferParallelism": {
            "description": "Number of concurrent requests for transferring a file from a remote host to the Rubrik cluster.",
            "format": "int32",
            "type": "integer"
          },
          "mssqlDefaultMaxDataStreamsPerDatabase": {
            "description": "The default value for maximum number of data streams per database.",
            "format": "int32",
            "type": "integer"
          },
          "physicalHostDatabaseRestoreThrottleMaxRefCount": {
            "description": "The maximum number of concurrent database restore job running on a host.",
            "format": "int32",
            "type": "integer"
          },
          "physicalHostLogBackupThrottleMaxRefCount": {
            "description": "Maximum number of concurrent SQL Server log backup jobs per physical host.",
            "format": "int32",
            "type": "integer"
          },
          "throttlePhysicalHostMaxRefCount": {
            "description": "Maximum number of concurrent snapshots per physical host.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "MssqlHostConfigurationWithHostId": {
        "allOf": [
          {
            "$ref": "#/components/schemas/MssqlHostConfiguration"
          },
          {
            "properties": {
              "hostId": {
                "description": "the ID of the host.",
                "type": "string"
              }
            },
            "required": [
              "hostId"
            ],
            "type": "object"
          }
        ]
      },
      "MssqlHostConfigurationWithHostIdListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/MssqlHostConfigurationWithHostId"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "MssqlInstanceDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/MssqlInstanceSummary"
          }
        ]
      },
      "MssqlInstanceShortSummary": {
        "properties": {
          "activeNode": {
            "description": "Active node of the instance in a Windows server failover cluster. Populated only if the node belongs to a Windows server failover cluster.",
            "type": "string"
          },
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "networkName": {
            "description": "Network name of the instance in a Windows server failover cluster. Populated only if the node belongs to a Windows server failover cluster.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "name"
        ],
        "type": "object"
      },
      "MssqlInstanceSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/MssqlSlaRelatedProperties"
          },
          {
            "properties": {
              "clusterInstanceAddress": {
                "description": "The address of the instance in a Windows server failover cluster, populated only if it belongs to one.",
                "type": "string"
              },
              "configuredSlaDomainId": {
                "description": "SLA Domain ID assigned to instance.",
                "type": "string"
              },
              "configuredSlaDomainName": {
                "description": "SLA Domain name assigned to instance.",
                "type": "string"
              },
              "configuredSlaDomainType": {
                "description": "Specifies whether the SLA Domain is used for protection or retention.",
                "type": "string"
              },
              "id": {
                "type": "string"
              },
              "internalTimestamp": {
                "format": "int64",
                "type": "integer"
              },
              "isRetentionLocked": {
                "description": "Boolean value that identifies a Retention Lock SLA Domain. Value is true when the SLA Domain assigned to the instance is Retention Locked and false when it is not.",
                "type": "boolean"
              },
              "name": {
                "type": "string"
              },
              "primaryClusterId": {
                "type": "string"
              },
              "protectionDate": {
                "format": "date",
                "type": "string"
              },
              "rootProperties": {
                "$ref": "#/components/schemas/MssqlRootProperties"
              },
              "unprotectableReasons": {
                "description": "A list of reasons that all the SQL Server databases in a SQL Server instance cannot be protected by the Rubrik CDM.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "version": {
                "type": "string"
              }
            },
            "required": [
              "id",
              "primaryClusterId",
              "rootProperties"
            ],
            "type": "object"
          }
        ]
      },
      "MssqlInstanceSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/MssqlInstanceSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "MssqlInstanceUpdate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/MssqlSlaPatchProperties"
          }
        ]
      },
      "MssqlLogShippingCreateConfig": {
        "allOf": [
          {
            "$ref": "#/components/schemas/MssqlLogShippingTargetStateOptions"
          },
          {
            "properties": {
              "maxDataStreams": {
                "description": "Maximum number of parallel data streams that can be used to copy data to the target system.",
                "format": "int32",
                "type": "integer"
              },
              "targetDataFilePath": {
                "description": "The path to the default target location for data file storage.",
                "type": "string"
              },
              "targetDatabaseName": {
                "description": "The name of the secondary database.",
                "type": "string"
              },
              "targetFilePaths": {
                "description": "Array of database file storage paths. Each path is the target storage location for a database file. Values in this array override the values in targetDataFilePath and targetLogFilePath for the specified database files.",
                "items": {
                  "$ref": "#/components/schemas/MssqlDbFileExportPath"
                },
                "type": "array"
              },
              "targetInstanceId": {
                "description": "The ID of the SQL Server instance that hosts the secondary database.",
                "type": "string"
              },
              "targetLogFilePath": {
                "description": "The path to the location of the log files.",
                "type": "string"
              }
            },
            "required": [
              "targetDatabaseName",
              "targetInstanceId"
            ],
            "type": "object"
          }
        ]
      },
      "MssqlLogShippingDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/MssqlLogShippingSummary"
          },
          {
            "properties": {
              "links": {
                "$ref": "#/components/schemas/MssqlLogShippingLinks"
              },
              "shouldDisconnectStandbyUsers": {
                "description": "Whether to automatically disconnect users from a secondary database in Standby mode when a restore operation is performed. If this value is false and users remain connected, then any scheduled restore operations will fail. This is only returned when the secondary database is in Standby mode.",
                "type": "boolean"
              }
            },
            "required": [
              "links"
            ],
            "type": "object"
          }
        ]
      },
      "MssqlLogShippingLinks": {
        "properties": {
          "primaryDatabase": {
            "$ref": "#/components/schemas/Link"
          },
          "secondaryDatabase": {
            "$ref": "#/components/schemas/Link"
          },
          "secondaryInstance": {
            "$ref": "#/components/schemas/Link"
          },
          "seedRequest": {
            "$ref": "#/components/schemas/Link"
          }
        },
        "required": [
          "primaryDatabase",
          "secondaryInstance"
        ],
        "type": "object"
      },
      "MssqlLogShippingListSortAttribute": {
        "description": "Field used for sorts when enumerating log shipping entries.",
        "enum": [
          "secondaryDatabaseName",
          "primaryDatabaseName",
          "lastAppliedPoint",
          "location"
        ],
        "type": "string"
      },
      "MssqlLogShippingOkState": {
        "description": "Secondary database states for log shipping configurations with a status of OK.",
        "enum": [
          "RESTORING",
          "STANDBY"
        ],
        "type": "string"
      },
      "MssqlLogShippingReseedConfig": {
        "allOf": [
          {
            "$ref": "#/components/schemas/MssqlLogShippingTargetStateOptions"
          }
        ]
      },
      "MssqlLogShippingStatus": {
        "description": "Status of the log shipping configuration.",
        "enum": [
          "OK",
          "Broken",
          "Initializing",
          "Stale"
        ],
        "type": "string"
      },
      "MssqlLogShippingStatusInfo": {
        "properties": {
          "message": {
            "description": "Detailed message describing the status of the log shipping configuration.",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/MssqlLogShippingStatus"
          }
        },
        "required": [
          "message",
          "status"
        ],
        "type": "object"
      },
      "MssqlLogShippingSummary": {
        "properties": {
          "id": {
            "description": "ID assigned to the log shipping configuration object.",
            "type": "string"
          },
          "lagTime": {
            "description": "Number of milliseconds elapsed since the latest backup was applied to the secondary database and the time the backup was taken on the primary database.",
            "format": "int64",
            "type": "integer"
          },
          "lastAppliedPoint": {
            "description": "Timestamp of the last transaction applied using the specified log shipping configuration object.",
            "format": "date-time",
            "type": "string"
          },
          "location": {
            "description": "Location of a specified secondary database. Location uses this format: \"host/instance\".",
            "type": "string"
          },
          "primaryDatabaseId": {
            "description": "ID of the primary database.",
            "type": "string"
          },
          "primaryDatabaseLogBackupFrequency": {
            "description": "Log backup frequency, in seconds, of the primary database.",
            "format": "int64",
            "type": "integer"
          },
          "primaryDatabaseName": {
            "description": "Name of the primary database.",
            "type": "string"
          },
          "secondaryDatabaseId": {
            "description": "ID of the secondary database.",
            "type": "string"
          },
          "secondaryDatabaseName": {
            "description": "Name of the secondary database.",
            "type": "string"
          },
          "state": {
            "description": "The current state of the secondary database.",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/MssqlLogShippingStatusInfo"
          }
        },
        "required": [
          "id",
          "location",
          "primaryDatabaseId",
          "primaryDatabaseLogBackupFrequency",
          "primaryDatabaseName",
          "secondaryDatabaseName",
          "status"
        ],
        "type": "object"
      },
      "MssqlLogShippingSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/MssqlLogShippingSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "MssqlLogShippingTargetStateOptions": {
        "properties": {
          "shouldDisconnectStandbyUsers": {
            "description": "Specifies whether to automatically disconnect users from a secondary database in standby mode when a restore operation is performed. If this value is set to false and users remain connected, any scheduled restore operations fail. If the \"state\" field is `RESTORING`, this value can be omitted and is ignored.",
            "type": "boolean"
          },
          "state": {
            "$ref": "#/components/schemas/MssqlLogShippingOkState"
          }
        },
        "required": [
          "state"
        ],
        "type": "object"
      },
      "MssqlLogShippingUpdate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/MssqlLogShippingTargetStateOptions"
          }
        ]
      },
      "MssqlMissedRecoverableRange": {
        "properties": {
          "beginTime": {
            "format": "date-time",
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "endTime": {
            "format": "date-time",
            "type": "string"
          },
          "errorType": {
            "type": "string"
          },
          "firstError": {
            "$ref": "#/components/schemas/MssqlMissedRecoverableRangeError"
          },
          "lastError": {
            "$ref": "#/components/schemas/MssqlMissedRecoverableRangeError"
          }
        },
        "required": [
          "beginTime",
          "description",
          "endTime",
          "errorType"
        ],
        "type": "object"
      },
      "MssqlMissedRecoverableRangeError": {
        "properties": {
          "eventMessage": {
            "type": "string"
          },
          "eventSeriesId": {
            "type": "string"
          },
          "time": {
            "format": "date-time",
            "type": "string"
          }
        },
        "required": [
          "time"
        ],
        "type": "object"
      },
      "MssqlMissedRecoverableRangeListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/MssqlMissedRecoverableRange"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "MssqlMountDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/MssqlMountSummary"
          },
          {
            "properties": {
              "links": {
                "$ref": "#/components/schemas/MssqlMountLinks"
              },
              "mountRequestId": {
                "description": "ID of the async request object for the mount task.",
                "type": "string"
              },
              "unmountRequestId": {
                "description": "ID of the async request object for the delete task.",
                "type": "string"
              }
            },
            "required": [
              "links"
            ],
            "type": "object"
          }
        ]
      },
      "MssqlMountLinks": {
        "properties": {
          "mountRequest": {
            "$ref": "#/components/schemas/Link"
          },
          "mountedDatabase": {
            "$ref": "#/components/schemas/Link"
          },
          "sourceDatabase": {
            "$ref": "#/components/schemas/Link"
          },
          "targetInstance": {
            "$ref": "#/components/schemas/Link"
          },
          "unmountRequest": {
            "$ref": "#/components/schemas/Link"
          }
        },
        "required": [
          "sourceDatabase",
          "targetInstance"
        ],
        "type": "object"
      },
      "MssqlMountSummary": {
        "properties": {
          "creationDate": {
            "description": "The date this mount was created.",
            "format": "date-time",
            "type": "string"
          },
          "id": {
            "type": "string"
          },
          "mountedDatabaseId": {
            "description": "ID for the mounted SQL Server database, once it is available.",
            "type": "string"
          },
          "mountedDatabaseName": {
            "description": "Name for the mounted SQL Server database.",
            "type": "string"
          },
          "ownerId": {
            "description": "ID of the user who created this mount.",
            "type": "string"
          },
          "ownerName": {
            "description": "Name of the user who created this mount.",
            "type": "string"
          },
          "sourceDatabaseId": {
            "type": "string"
          },
          "sourceDatabaseName": {
            "type": "string"
          },
          "sourceRecoveryPoint": {
            "$ref": "#/components/schemas/MssqlRecoveryPoint"
          },
          "status": {
            "description": "The status of this mount. The status is **_Available_** when the database is successfully mounted and ready to use.",
            "enum": [
              "Available",
              "Unavailable",
              "Mounting",
              "Unmounting"
            ],
            "type": "string"
          },
          "targetInstanceId": {
            "type": "string"
          },
          "targetInstanceName": {
            "type": "string"
          },
          "targetRootName": {
            "description": "Name of the top-level object on which the target instance resides.",
            "type": "string"
          }
        },
        "required": [
          "creationDate",
          "id",
          "mountedDatabaseName",
          "sourceDatabaseId",
          "sourceDatabaseName",
          "sourceRecoveryPoint",
          "status",
          "targetInstanceId",
          "targetInstanceName",
          "targetRootName"
        ],
        "type": "object"
      },
      "MssqlMountSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/MssqlMountSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "MssqlRecoverableRange": {
        "properties": {
          "beginTime": {
            "format": "date-time",
            "type": "string"
          },
          "endTime": {
            "format": "date-time",
            "type": "string"
          },
          "isMountAllowed": {
            "type": "boolean"
          },
          "status": {
            "type": "string"
          }
        },
        "required": [
          "beginTime",
          "endTime",
          "isMountAllowed",
          "status"
        ],
        "type": "object"
      },
      "MssqlRecoverableRangeListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/MssqlRecoverableRange"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "MssqlRecoveryPoint": {
        "properties": {
          "date": {
            "description": "Recovery point specified in ISO8601 format, such as \"2016-01-01T01:23:45.678\".",
            "format": "date-time",
            "type": "string"
          },
          "lsnPoint": {
            "$ref": "#/components/schemas/LsnRecoveryPoint"
          },
          "timestampMs": {
            "description": "Recovery point specified in the form of a timestamp (in milliseconds). Deprecated. Please use 'date' instead.",
            "format": "int64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "MssqlRestoreEstimateResult": {
        "properties": {
          "bytesFromCloud": {
            "description": "Estimate of the number of bytes to be downloaded from the cloud.",
            "format": "int64",
            "type": "integer"
          }
        },
        "required": [
          "bytesFromCloud"
        ],
        "type": "object"
      },
      "MssqlRestoreFile": {
        "properties": {
          "fileId": {
            "description": "Original file ID of the database file to be restored.",
            "format": "int64",
            "type": "integer"
          },
          "fileType": {
            "$ref": "#/components/schemas/MssqlDatabaseFileType"
          },
          "logicalName": {
            "description": "Logical name of the database file to be restored.",
            "type": "string"
          },
          "originalName": {
            "description": "Original filename of the database file to be restored.",
            "type": "string"
          },
          "originalPath": {
            "description": "Original path to the database file to be restored.",
            "type": "string"
          }
        },
        "required": [
          "fileId",
          "fileType",
          "logicalName",
          "originalName",
          "originalPath"
        ],
        "type": "object"
      },
      "MssqlRootProperties": {
        "properties": {
          "rootId": {
            "description": "ID of the root of this object.",
            "type": "string"
          },
          "rootName": {
            "description": "Name of the root of this object.",
            "type": "string"
          },
          "rootRole": {
            "description": "Role of the root object for this object if the root object is a Host and part of a **_MssqlAvailabilityGroup_**.",
            "type": "string"
          },
          "rootType": {
            "description": "Type of the root object for this object. The root object is the top-level object from which this object is derived. If this object is an availability database, the root object is **_MssqlAvailabilityGroup_**. Otherwise, if this object is part of a cluster, the root object is **_WindowsCluster_**. Otherwise, the root object is **_Host_**.",
            "enum": [
              "Host",
              "WindowsCluster",
              "MssqlAvailabilityGroup"
            ],
            "type": "string"
          }
        },
        "required": [
          "rootName",
          "rootType"
        ],
        "type": "object"
      },
      "MssqlScriptDetail": {
        "properties": {
          "scriptErrorAction": {
            "$ref": "#/components/schemas/ScriptErrorAction"
          },
          "scriptPath": {
            "description": "The script to be run.",
            "type": "string"
          },
          "timeoutMs": {
            "description": "Time (in ms) after which the script will be terminated if it has not completed.",
            "format": "int64",
            "type": "integer"
          }
        },
        "required": [
          "scriptErrorAction",
          "scriptPath",
          "timeoutMs"
        ],
        "type": "object",
        "x-rk-nullable-properties": [
          "scriptPath",
          "timeoutMs",
          "scriptErrorAction"
        ]
      },
      "MssqlSlaDomainAssignInfo": {
        "allOf": [
          {
            "$ref": "#/components/schemas/MssqlSlaPatchProperties"
          },
          {
            "properties": {
              "existingSnapshotRetention": {
                "$ref": "#/components/schemas/ExistingSnapshotRetention"
              },
              "ids": {
                "description": "List of SQL Server object IDs which should be assigned these properties.\n",
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            },
            "required": [
              "ids"
            ],
            "type": "object"
          }
        ]
      },
      "MssqlSlaDomainInfo": {
        "properties": {
          "id": {
            "description": "The ID of the SLA Domain.",
            "type": "string"
          },
          "isRetentionLocked": {
            "description": "Boolean value that identifies a Retention Lock SLA Domain. Value is true when an SLA Domain is Retention Locked and false when it is not.",
            "type": "boolean"
          },
          "name": {
            "description": "The name of the SLA Domain.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "isRetentionLocked",
          "name"
        ],
        "type": "object"
      },
      "MssqlSlaPatchProperties": {
        "allOf": [
          {
            "$ref": "#/components/schemas/MssqlSlaRelatedProperties"
          },
          {
            "properties": {
              "configuredSlaDomainId": {
                "description": "SLA Domain ID assigned to instance. Existing snapshots of the instance will be retained with the configuration of specified SLA Domain.",
                "type": "string"
              },
              "useConfiguredDefaultLogRetention": {
                "description": "Determines whether to use the configured default value of log backup retention.",
                "type": "boolean"
              }
            },
            "type": "object"
          }
        ]
      },
      "MssqlSlaRelatedProperties": {
        "properties": {
          "copyOnly": {
            "description": "Boolean value that specifies whether or not to perform copy-only backups of the database. When true, database backups are copy-only backups. When false, database backups are full backups.",
            "type": "boolean"
          },
          "logBackupFrequencyInSeconds": {
            "description": "Seconds between two log backups. A value of 0 disables log backup.",
            "format": "int32",
            "type": "integer"
          },
          "logRetentionHours": {
            "description": "Number of hours to retain a log backup. When the value is set to -1 the Rubrik cluster retains the log backup until the database snapshots that precede the log backup have expired.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "MssqlSnappableId": {
        "properties": {
          "snappableId": {
            "description": "ID of the protected object.",
            "type": "string"
          }
        },
        "required": [
          "snappableId"
        ],
        "type": "object"
      },
      "NasBaseConfig": {
        "properties": {
          "apiCertificate": {
            "description": "TLS certification to validate NAS server.",
            "type": "string"
          },
          "apiEndpoint": {
            "description": "API endpoint to access NAS API 'FLASHBLADE'.",
            "type": "string"
          },
          "apiHostname": {
            "description": "Hostname or IP used in the NAS API calls.",
            "type": "string"
          },
          "apiUsername": {
            "description": "Username to access NAS API.",
            "type": "string"
          },
          "isIsilonChangelistEnabled": {
            "description": "Indicates if Changelist is enabled on Isilon NAS share. When this value is 'true', metadata fetches during backup operations use the Isilon Changelist feature. The Changelist feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.",
            "type": "boolean"
          },
          "isNetAppSnapDiffEnabled": {
            "description": "Indicates if SnapDiff is enabled on NetApp NAS share. When this value is 'true', metadata fetches during backup operations use the NetApp SnapDiff feature. The SnapDiff feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.",
            "type": "boolean"
          },
          "isShareAutoDiscoveryEnabled": {
            "description": "Specifies whether shares on the NAS host are automatically discovered. When this value is 'true', Rubrik periodically (every 30 minutes by default) connects to the NAS host to discover NFS and SMB shares.",
            "type": "boolean"
          },
          "vendorType": {
            "description": "Type of NAS vendor 'ISILON/NETAPP/FLASHBLADE'.",
            "type": "string"
          },
          "zoneName": {
            "description": "Name of the Isilon zone that data IP belongs to.",
            "type": "string"
          }
        },
        "required": [
          "vendorType"
        ],
        "type": "object"
      },
      "NasConfig": {
        "properties": {
          "apiCertificate": {
            "description": "TLS certification to validate NAS server.",
            "type": "string"
          },
          "apiEndpoint": {
            "description": "API endpoint to access NAS API 'FLASHBLADE'.",
            "type": "string"
          },
          "apiHostname": {
            "description": "Hostname or IP used in the NAS API calls.",
            "type": "string"
          },
          "apiPassword": {
            "description": "Password to access NAS API 'ISILON/NETAPP'.",
            "type": "string",
            "x-secret": true
          },
          "apiToken": {
            "description": "API token to access NAS API 'FLASHBLADE'.",
            "type": "string",
            "x-secret": true
          },
          "apiUsername": {
            "description": "Username to access NAS API 'ISILON/NETAPP'.",
            "type": "string"
          },
          "isIsilonChangelistEnabled": {
            "description": "Indicates if Changelist is enabled on Isilon NAS share. When this value is 'true', metadata fetches during backup operations use the Isilon Changelist feature. The Changelist feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.",
            "type": "boolean"
          },
          "isNetAppSnapDiffEnabled": {
            "description": "Indicates if SnapDiff is enabled on NetApp NAS share. When this value is 'true', metadata fetches during backup operations use the NetApp SnapDiff feature. The SnapDiff feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.",
            "type": "boolean"
          },
          "isShareAutoDiscoveryEnabled": {
            "description": "Specifies whether shares on the NAS host are automatically discovered. When this value is 'true', Rubrik periodically (every 30 minutes by default) connects to the NAS host to discover NFS and SMB shares.",
            "type": "boolean"
          },
          "vendorType": {
            "description": "Type of NAS vendor 'ISILON/NETAPP/FLASHBLADE'.",
            "type": "string"
          },
          "zoneName": {
            "description": "Name of the Isilon zone that data IP belongs to.",
            "type": "string"
          }
        },
        "required": [
          "vendorType"
        ],
        "type": "object"
      },
      "NasSharesToAdd": {
        "properties": {
          "hostId": {
            "description": "The host ID of the NAS Share host.",
            "type": "string"
          },
          "nasShares": {
            "description": "The NAS shares to bulk add for the NAS host.",
            "items": {
              "$ref": "#/components/schemas/DiscoveredNasShare"
            },
            "type": "array"
          }
        },
        "required": [
          "hostId",
          "nasShares"
        ],
        "type": "object"
      },
      "NasVendorType": {
        "description": "NAS Vendor Type.",
        "enum": [
          "NETAPP",
          "ISILON",
          "FLASHBLADE"
        ],
        "type": "string"
      },
      "NetworkInfo": {
        "properties": {
          "id": {
            "description": "The ID of a user-configured vCenter network.",
            "type": "string"
          },
          "name": {
            "description": "The name of a user-configured vCenter network.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "name"
        ],
        "type": "object"
      },
      "NetworkInfoListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/NetworkInfo"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "NodeHostnameInfo": {
        "properties": {
          "hostname": {
            "description": "Hostname of a Rubrik node.",
            "type": "string"
          },
          "id": {
            "description": "ID of a Rubrik node.",
            "type": "string"
          }
        },
        "required": [
          "hostname",
          "id"
        ],
        "type": "object"
      },
      "NodeHostnameInfoListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/NodeHostnameInfo"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "NodeId": {
        "properties": {
          "id": {
            "type": "string"
          }
        },
        "required": [
          "id"
        ],
        "type": "object"
      },
      "NodePolicyCheckResult": {
        "properties": {
          "checkResults": {
            "items": {
              "$ref": "#/components/schemas/PolicyCheckResult"
            },
            "type": "array"
          },
          "nodeId": {
            "type": "string"
          }
        },
        "required": [
          "checkResults",
          "nodeId"
        ],
        "type": "object"
      },
      "NodeStatusEnum": {
        "description": "Node status.",
        "enum": [
          "UNKNOWN",
          "OK",
          "BAD",
          "PRE_MAINTENANCE",
          "MAINTENANCE",
          "BOOTSTRAPPING",
          "UPGRADE",
          "REMOVED"
        ],
        "type": "string"
      },
      "NotificationConfig": {
        "properties": {
          "criticalDetails": {
            "$ref": "#/components/schemas/NotificationDetails"
          },
          "infoDetails": {
            "$ref": "#/components/schemas/NotificationDetails"
          },
          "name": {
            "description": "Name of notification config.",
            "type": "string"
          },
          "notificationMessage": {
            "description": "Notification Message.",
            "type": "string"
          },
          "notificationType": {
            "$ref": "#/components/schemas/NotificationTypeEnum"
          },
          "warnDetails": {
            "$ref": "#/components/schemas/NotificationDetails"
          }
        },
        "required": [
          "name",
          "notificationMessage",
          "notificationType"
        ],
        "type": "object"
      },
      "NotificationDetails": {
        "properties": {
          "action": {
            "$ref": "#/components/schemas/ActionDetails"
          },
          "failureWindow": {
            "description": "Window to check for number of failures.",
            "format": "int64",
            "type": "integer"
          },
          "numFailures": {
            "description": "Number of failures before notification is triggered.",
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "failureWindow",
          "numFailures"
        ],
        "type": "object"
      },
      "NotificationTypeEnum": {
        "description": "Notification type.",
        "enum": [
          "NOTIFICATION_TYPE_UNKNOWN",
          "DIAGNOSTIC"
        ],
        "type": "string"
      },
      "NutanixVmSlaObjectCount": {
        "properties": {
          "numNutanixVms": {
            "description": "The number of Nutanix virtual machines protected under this SLA domain.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "ObjectHoldSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ObjectHolder"
          },
          {
            "properties": {
              "numberOfSnapshotsHeld": {
                "description": "Number of snapshots for the object currently under legal hold.",
                "format": "int32",
                "type": "integer"
              }
            },
            "required": [
              "numberOfSnapshotsHeld"
            ],
            "type": "object"
          }
        ]
      },
      "ObjectHoldSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/ObjectHoldSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "ObjectHolder": {
        "properties": {
          "objectId": {
            "type": "string"
          },
          "objectName": {
            "type": "string"
          },
          "objectType": {
            "type": "string"
          }
        },
        "required": [
          "objectId",
          "objectName",
          "objectType"
        ],
        "type": "object"
      },
      "ObjectTypeV1": {
        "description": "Type of the object associated with the event.",
        "enum": [
          "AggregateAhvVm",
          "AggregateAwsAzure",
          "AggregateHypervVm",
          "AggregateLinuxUnixHosts",
          "AggregateNasShares",
          "AggregateOracleDb",
          "AggregateSapHanaDb",
          "AggregateStorageArrays",
          "AggregateVcdVapps",
          "AggregateVsphereVm",
          "AggregateWindowsHosts",
          "AppBlueprint",
          "AppFlows",
          "AuthDomain",
          "AwsAccount",
          "AwsEventType",
          "Certificate",
          "Cluster",
          "ComputeInstance",
          "DataLocation",
          "Ec2Instance",
          "Envoy",
          "Host",
          "HypervScvmm",
          "HypervServer",
          "HypervVm",
          "JobInstance",
          "Ldap",
          "LinuxHost",
          "LinuxFileset",
          "ManagedVolume",
          "Mssql",
          "NasHost",
          "NutanixCluster",
          "NutanixVm",
          "OracleDb",
          "OracleHost",
          "OracleRac",
          "PublicCloudMachineInstance",
          "SamlSso",
          "SapHanaDb",
          "SapHanaSystem",
          "ShareFileset",
          "SlaDomain",
          "SmbDomain",
          "StorageArray",
          "StorageArrayVolumeGroup",
          "Storm",
          "SupportBundle",
          "UnknownObjectType",
          "Upgrade",
          "UserActionAudit",
          "Vcd",
          "VcdVapp",
          "Vcenter",
          "VmwareVm",
          "VolumeGroup",
          "WindowsHost",
          "WindowsFileset"
        ],
        "type": "string"
      },
      "OperatingSystemFamily": {
        "description": "The family type of the host operating system.",
        "enum": [
          "AIX",
          "HPUX",
          "Linux",
          "Solaris"
        ],
        "type": "string"
      },
      "OperationMode": {
        "description": "The operation mode determines if the API call waits until the operation is completed or returns immediately. The default operation mode is synchronous.",
        "enum": [
          "Synchronous",
          "Asynchronous"
        ],
        "type": "string"
      },
      "OracleAcoParameterDetail": {
        "properties": {
          "parameter": {
            "description": "Name of the Advanced Cloning Options (ACO) parameter.",
            "type": "string"
          },
          "value": {
            "description": "Value for the Advanced Cloning Options (ACO) parameter.",
            "type": "string"
          }
        },
        "required": [
          "parameter",
          "value"
        ],
        "type": "object"
      },
      "OracleAcoParameterList": {
        "properties": {
          "parameters": {
            "description": "An array that contains the supported Advanced Cloning Options (ACO) parameters.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "parameters"
        ],
        "type": "object"
      },
      "OracleAcoValidationResult": {
        "properties": {
          "acoMap": {
            "description": "List of Advanced Cloning Options (ACO) parameter values that were parsed.",
            "items": {
              "$ref": "#/components/schemas/OracleAcoParameterDetail"
            },
            "type": "array"
          },
          "acoParameterErrors": {
            "description": "Other generic errors with the Advanced Cloning Options (ACO) parameters.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "acoValueValidationErrors": {
            "description": "List of Advanced Cloning Options (ACO) errors pertaining to the specified values.",
            "items": {
              "$ref": "#/components/schemas/OracleAcoValueErrorDetail"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "OracleAcoValueErrorDetail": {
        "properties": {
          "error": {
            "description": "Validation error message for the provided value.",
            "type": "string"
          },
          "parameter": {
            "description": "Name of the Advanced Cloning Options (ACO) parameter.",
            "type": "string"
          }
        },
        "required": [
          "error",
          "parameter"
        ],
        "type": "object"
      },
      "OracleBulkUpdate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/OracleUpdate"
          },
          {
            "properties": {
              "ids": {
                "description": "An array containing the IDs assigned to Oracle host, Oracle RAC, and Oracle Database objects.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            },
            "required": [
              "ids"
            ],
            "type": "object"
          }
        ]
      },
      "OracleDataGuardGroupUpdate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/OracleUpdateCommon"
          },
          {
            "properties": {
              "preferredDGMemberUniqueNames": {
                "description": "Ordered list of database unique names to use for backup.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "shouldBackupFromPrimaryOnly": {
                "description": "Value that indicates whether to backup from the PRIMARY member only, or from any available member.",
                "type": "boolean"
              }
            },
            "type": "object"
          }
        ]
      },
      "OracleDbDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/OracleDbSummary"
          },
          {
            "$ref": "#/components/schemas/OracleNonSlaProperties"
          },
          {
            "properties": {
              "hostsInfo": {
                "description": "An array that contains the host info for each instance.",
                "items": {
                  "$ref": "#/components/schemas/HostInfo"
                },
                "type": "array"
              },
              "isLiveMount": {
                "description": "Value that indicates whether an Oracle database object is a Live Mount or not. A true value indicates that the object is a Live Mount.",
                "type": "boolean"
              },
              "lastValidationResult": {
                "$ref": "#/components/schemas/OracleLastValidationResult"
              },
              "latestRecoveryPoint": {
                "description": "The time stamp of the most recent recovery point for this database.",
                "format": "date",
                "type": "string"
              },
              "oldestRecoveryPoint": {
                "description": "The time stamp of the earliest recovery point for this database.",
                "format": "date",
                "type": "string"
              },
              "oracleHome": {
                "description": "Oracle Home of the Oracle database.",
                "type": "string"
              },
              "pendingSlaDomain": {
                "$ref": "#/components/schemas/ManagedObjectPendingSlaInfo"
              },
              "preferredDGMemberUniqueNames": {
                "description": "Ordered list of database unique names to use for backup in a Data Guard group.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "shouldBackupFromPrimaryDGGroupMemberOnly": {
                "description": "Indicates whether to backup only from the PRIMARY Data Guard member or from any available member.",
                "type": "boolean"
              },
              "snapshotCount": {
                "format": "int32",
                "type": "integer"
              },
              "tablespaces": {
                "description": "An array that contains tablespace names of the specified Oracle database.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            },
            "required": [
              "snapshotCount",
              "tablespaces"
            ],
            "type": "object"
          }
        ]
      },
      "OracleDbSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Snappable"
          },
          {
            "properties": {
              "archiveLogDestinations": {
                "description": "An array that contains the archive log destinations for the specified Oracle database.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "currentBackupTaskInfo": {
                "$ref": "#/components/schemas/BackupTaskDiagnosticInfo"
              },
              "dataGuardGroupId": {
                "description": "Rubrik ID of the Data Guard group to which this database belongs.",
                "type": "string"
              },
              "dataGuardGroupMembers": {
                "description": "List of Data Guard group members.",
                "items": {
                  "$ref": "#/components/schemas/DataGuardGroupMember"
                },
                "type": "array"
              },
              "dataGuardGroupName": {
                "description": "Name of the Data Guard group to which this database belongs.",
                "type": "string"
              },
              "dataGuardType": {
                "$ref": "#/components/schemas/DataGuardType"
              },
              "databaseRole": {
                "description": "Current role of the database.",
                "type": "string"
              },
              "dbUniqueName": {
                "description": "Unique name for the Oracle database (DB_UNIQUE_NAME).",
                "type": "string"
              },
              "hostLogRetentionHours": {
                "description": "Specifies an interval in hours. The next log snapshot job deletes archived Oracle redo log files whose 'nextTime' field specifies a time more than the specified number of hours ago. To immediately delete archived redo log files regardless of age, specify an interval of -1. To preserve all archived redo log files, specify an interval of -2.",
                "format": "int32",
                "type": "integer"
              },
              "id": {
                "description": "ID assigned to the Oracle database.",
                "type": "string"
              },
              "includeBackupTaskInfo": {
                "description": "True/false value indicating if backup task information is included in the response.",
                "type": "boolean"
              },
              "infraPath": {
                "description": "An array that contains information about the objects in the infrastructure path of a specified Oracle database.",
                "items": {
                  "$ref": "#/components/schemas/ManagedHierarchyObjectAncestor"
                },
                "type": "array"
              },
              "instances": {
                "description": "Details of the instances of the Oracle database.",
                "items": {
                  "$ref": "#/components/schemas/OracleInstanceProperties"
                },
                "type": "array"
              },
              "isArchiveLogModeEnabled": {
                "description": "Boolean value that indicates whether the ARCHIVELOG mode is enabled on the Oracle database or not.",
                "type": "boolean"
              },
              "isDbLocalToTheCluster": {
                "description": "A Boolean value that specifies whether the Oracle database is local to the cluster. When this value is 'true', the Oracle database is local to the cluster.",
                "type": "boolean"
              },
              "isPrimary": {
                "description": "Indicates whether the current DATABASE_ROLE is PRIMARY which specifies the database is accepting read/write transactions as the primary database in a Data Guard configuration.",
                "type": "boolean"
              },
              "isRelic": {
                "description": "Boolean value that indicates whether a Oracle database object is in an archived state and has retained snapshots. Value is true when the object is archived with retained snapshots.",
                "type": "boolean"
              },
              "lastSnapshotTime": {
                "description": "The timestamp of the previous snapshot.",
                "format": "date-time",
                "type": "string"
              },
              "logBackupFrequencyInMinutes": {
                "description": "Specifies an interval in minutes. This interval is the period between successive log backups.",
                "format": "int32",
                "type": "integer"
              },
              "name": {
                "description": "Service name of the Oracle database.",
                "type": "string"
              },
              "numInstances": {
                "description": "Count of the number of instances of the Oracle database.",
                "format": "int32",
                "type": "integer"
              },
              "numMissedSnapshot": {
                "description": "An integer that specifies the number of missed snapshots.",
                "format": "int32",
                "type": "integer"
              },
              "numTablespaces": {
                "description": "Count of the number of table spaces in Oracle database.",
                "format": "int32",
                "type": "integer"
              },
              "primaryClusterId": {
                "type": "string"
              },
              "racId": {
                "description": "Rubrik ID of the RAC on which this database is hosted. This field will be empty if the database is not hosted on a RAC environment.",
                "type": "string"
              },
              "racName": {
                "description": "RAC name of the cluster database.",
                "type": "string"
              },
              "sid": {
                "description": "System identifier (SID) of the Oracle database.",
                "type": "string"
              },
              "standaloneHostId": {
                "description": "Rubrik ID of the standalone Oracle host on which this database is hosted. This field will be empty if the database is not hosted on a standalone system.",
                "type": "string"
              },
              "standaloneHostName": {
                "description": "Hostname of the standalone Oracle database host.",
                "type": "string"
              }
            },
            "required": [
              "hostLogRetentionHours",
              "id",
              "infraPath",
              "isDbLocalToTheCluster",
              "isRelic",
              "name",
              "numMissedSnapshot",
              "numTablespaces",
              "primaryClusterId"
            ],
            "type": "object"
          }
        ]
      },
      "OracleDbSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/OracleDbSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "OracleFileDownloadLink": {
        "properties": {
          "downloadLink": {
            "description": "Link for file download.",
            "type": "string"
          }
        },
        "required": [
          "downloadLink"
        ],
        "type": "object"
      },
      "OracleHostDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/OracleHostSummary"
          },
          {
            "$ref": "#/components/schemas/OracleNonSlaProperties"
          }
        ]
      },
      "OracleHostSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SlaAssignable"
          },
          {
            "properties": {
              "id": {
                "description": "ID assigned to the standalone Oracle host.",
                "type": "string"
              },
              "infraPath": {
                "description": "An array that contains information about the objects in the infrastructure path of a specified Oracle database.",
                "items": {
                  "$ref": "#/components/schemas/ManagedHierarchyObjectAncestor"
                },
                "type": "array"
              },
              "name": {
                "description": "Hostname of the standalone Oracle host.",
                "type": "string"
              },
              "numDbs": {
                "description": "Count of the number of databases on the Oracle RAC.",
                "format": "int32",
                "type": "integer"
              },
              "primaryClusterId": {
                "type": "string"
              },
              "status": {
                "description": "Connectivity status of the Oracle RAC.",
                "type": "string"
              }
            },
            "required": [
              "id",
              "infraPath",
              "name",
              "numDbs",
              "primaryClusterId",
              "status"
            ],
            "type": "object"
          }
        ]
      },
      "OracleInstanceProperties": {
        "properties": {
          "hostName": {
            "description": "Name of the Oracle host.",
            "type": "string"
          },
          "instanceSid": {
            "description": "System identifier (SID) of the Oracle database instance.",
            "type": "string"
          }
        },
        "required": [
          "hostName",
          "instanceSid"
        ],
        "type": "object"
      },
      "OracleLastValidationResult": {
        "properties": {
          "eventSeriesId": {
            "description": "The eventseries ID for the last validation job.",
            "type": "string"
          },
          "isSuccess": {
            "description": "A Boolean that specifies whether the last validation successfully completed.",
            "type": "boolean"
          },
          "validationTime": {
            "description": "The timestamp of the recovery point to validate.",
            "format": "date-time",
            "type": "string"
          }
        },
        "required": [
          "eventSeriesId",
          "isSuccess",
          "validationTime"
        ],
        "type": "object"
      },
      "OracleNodeOrder": {
        "properties": {
          "nodeName": {
            "description": "Nodename of the Oracle RAC node.",
            "type": "string"
          },
          "order": {
            "description": "Order in which Rubrik uses this node for automated Oracle backup.",
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "nodeName",
          "order"
        ],
        "type": "object"
      },
      "OracleNodeProperties": {
        "properties": {
          "nodeName": {
            "description": "Node name of the Oracle RAC node.",
            "type": "string"
          },
          "status": {
            "description": "Connectivity status of the Oracle RAC node.",
            "type": "string"
          }
        },
        "required": [
          "nodeName",
          "status"
        ],
        "type": "object"
      },
      "OracleNonSlaProperties": {
        "properties": {
          "hostLogRetentionHours": {
            "description": "Specifies an interval in hours. The next log snapshot job deletes archived Oracle redo log files whose 'nextTime' field specifies a time more than the specified number of hours ago. To immediately delete archived redo log files regardless of age, specify an interval of -1. To preserve all archived redo log files, specify an interval of -2.",
            "format": "int32",
            "type": "integer"
          },
          "hostMount": {
            "description": "Path where the NFS share is mounted on the host.",
            "type": "string"
          },
          "logBackupFrequencyInMinutes": {
            "description": "Specifies an interval in minutes. This interval is the period between successive log backups.",
            "format": "int32",
            "type": "integer"
          },
          "logRetentionHours": {
            "description": "Specifies an interval in hours. Log backups are retained for the duration of the interval.",
            "format": "int32",
            "type": "integer"
          },
          "numChannels": {
            "description": "Number of channels used to backup the Oracle database.",
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "hostLogRetentionHours",
          "hostMount",
          "logBackupFrequencyInMinutes",
          "logRetentionHours",
          "numChannels"
        ],
        "type": "object"
      },
      "OracleRacDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/OracleRacSummary"
          },
          {
            "$ref": "#/components/schemas/OracleNonSlaProperties"
          },
          {
            "properties": {
              "scan": {
                "description": "Single Client Access Name (SCAN) of the Oracle RAC cluster.",
                "type": "string"
              }
            },
            "required": [
              "scan"
            ],
            "type": "object"
          }
        ]
      },
      "OracleRacSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SlaAssignable"
          },
          {
            "properties": {
              "id": {
                "description": "ID assigned to the Oracle RAC.",
                "type": "string"
              },
              "name": {
                "description": "Cluster name assigned to the Oracle RAC.",
                "type": "string"
              },
              "nodeOrder": {
                "description": "Specifies an order for the RAC nodes. Automated Oracle backups use the RAC nodes in the specified order.",
                "items": {
                  "$ref": "#/components/schemas/OracleNodeOrder"
                },
                "type": "array"
              },
              "nodes": {
                "description": "Details of the nodes of this Oracle RAC.",
                "items": {
                  "$ref": "#/components/schemas/OracleNodeProperties"
                },
                "type": "array"
              },
              "numDbs": {
                "description": "Count of the number of databases on the Oracle RAC.",
                "format": "int32",
                "type": "integer"
              },
              "numNodes": {
                "description": "Count of the number of nodes on the Oracle RAC.",
                "format": "int32",
                "type": "integer"
              },
              "primaryClusterId": {
                "type": "string"
              },
              "status": {
                "description": "Connectivity status of the Oracle RAC.",
                "type": "string"
              }
            },
            "required": [
              "id",
              "name",
              "nodeOrder",
              "nodes",
              "numDbs",
              "numNodes",
              "primaryClusterId",
              "status"
            ],
            "type": "object"
          }
        ]
      },
      "OracleRecoveryApiValidationErrors": {
        "allOf": [
          {
            "$ref": "#/components/schemas/OracleAcoValidationResult"
          },
          {
            "properties": {
              "otherErrors": {
                "description": "Other generic validation error messages in the API.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "postScriptError": {
                "description": "Error message when post-script path is invalid.",
                "type": "string"
              },
              "preScriptError": {
                "description": "Error message when pre-script path is invalid.",
                "type": "string"
              }
            },
            "type": "object"
          }
        ]
      },
      "OracleRecoveryPoint": {
        "properties": {
          "snapshotId": {
            "description": "Snapshot ID of the Oracle database.",
            "type": "string"
          },
          "timestampMs": {
            "description": "A timestamp in milliseconds that specifies a recovery point.",
            "format": "int64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "OracleRestoreEstimateResult": {
        "properties": {
          "bytesToRestore": {
            "description": "The estimated size, in bytes required to restore an Oracle database.",
            "format": "int64",
            "type": "integer"
          }
        },
        "required": [
          "bytesToRestore"
        ],
        "type": "object"
      },
      "OracleUpdate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/OracleUpdateCommon"
          },
          {
            "properties": {
              "configuredSlaDomainIdDeprecated": {
                "description": "ID of the SLA domain protecting the specified Oracle object. Log backup jobs are no longer scheduled if the SLA domain indicates the Oracle object is unprotected. The specified SLA domain is not used to configure the protection or retention for this Oracle object. This is a DEPRECATED field, and will be removed in later releases.",
                "type": "string"
              },
              "nodeOrder": {
                "description": "Specifies an order for the RAC nodes. Automated Oracle backups use the RAC nodes in the specified order.",
                "items": {
                  "$ref": "#/components/schemas/OracleNodeOrder"
                },
                "type": "array"
              }
            },
            "type": "object"
          }
        ]
      },
      "OracleUpdateCommon": {
        "properties": {
          "hostLogRetentionHours": {
            "description": "Specifies an interval in hours. For Oracle archived redo log files whose nextTime is before (now - interval), the next log snapshot job will delete them from the host. Set to 0 for inheriting the value from its parent; -1 for immediate deletion; and -2 to skip log deletion.",
            "format": "int32",
            "type": "integer"
          },
          "hostMount": {
            "description": "Path where the NFS share is mounted on the host.",
            "type": "string"
          },
          "logBackupFrequencyInMinutes": {
            "description": "Specifies an interval in minutes. This interval is the period between successive log backups.",
            "format": "int32",
            "type": "integer"
          },
          "logRetentionHours": {
            "description": "Specifies an interval in hours. Log backups are retained for the duration of the interval.",
            "format": "int32",
            "type": "integer"
          },
          "numChannels": {
            "description": "Number of channels used to backup the Oracle database.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "OracleValidateConfig": {
        "properties": {
          "numChannels": {
            "description": "Number of channels used during backup validation.",
            "format": "int32",
            "type": "integer"
          },
          "recoveryPoint": {
            "$ref": "#/components/schemas/OracleRecoveryPoint"
          },
          "sgaMaxSizeInMb": {
            "description": "System Global Area(SGA) size used to create the instance on the target host with unit in MB. SGA is a group of shared memory structures for one Oracle Database instance.",
            "format": "int64",
            "type": "integer"
          },
          "targetMountPath": {
            "description": "The full path on the target host where the NFS share with the snapshot files will be mounted.",
            "type": "string"
          },
          "targetOracleHome": {
            "description": "The full path on the target host for the Oracle Home which is the directory location where all Oracle software is installed.",
            "type": "string"
          },
          "targetOracleHostOrRacId": {
            "description": "ID of the Oracle host or Oracle RAC object that is the target for the validation job. The referenced Oracle host or Oracle RAC must have the Rubrik Backup Service (RBS) installed and connected.",
            "type": "string"
          }
        },
        "required": [
          "recoveryPoint",
          "targetOracleHostOrRacId"
        ],
        "type": "object"
      },
      "ParentAppInfo": {
        "properties": {
          "id": {
            "description": "ID assigned to the vApp object that manages a specified virtual machine.",
            "type": "string"
          },
          "isProtectedThruHierarchy": {
            "description": "Boolean value that indicates whether a virtual machine is protected through the SLA Domain assigned to the parent vApp. Set to 'true' when the virtual machine is protected through the parent vApp, otherwise set to 'false'. Direct assignment of a virtual machine to an SLA Domain is not possible when this value is 'true'. Also, setting this value to true is not possible when the virtual machine has an existing direct assignment to an SLA Domain.",
            "type": "boolean"
          }
        },
        "required": [
          "isProtectedThruHierarchy"
        ],
        "type": "object"
      },
      "PasswordRequirementsPatchRequest": {
        "properties": {
          "blockPreviousPasswords": {
            "type": "boolean"
          },
          "clearApiTokens": {
            "type": "boolean"
          },
          "clearWebSessions": {
            "type": "boolean"
          },
          "minLength": {
            "format": "int32",
            "type": "integer"
          },
          "minLowerCase": {
            "format": "int32",
            "type": "integer"
          },
          "minNumerics": {
            "format": "int32",
            "type": "integer"
          },
          "minSpecial": {
            "format": "int32",
            "type": "integer"
          },
          "minUpperCase": {
            "format": "int32",
            "type": "integer"
          },
          "useZxcvbn": {
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "PasswordRequirementsSummary": {
        "properties": {
          "blockPreviousPasswords": {
            "type": "boolean"
          },
          "clearApiTokens": {
            "type": "boolean"
          },
          "clearWebSessions": {
            "type": "boolean"
          },
          "maxLength": {
            "format": "int32",
            "type": "integer"
          },
          "minLength": {
            "format": "int32",
            "type": "integer"
          },
          "minLowerCase": {
            "format": "int32",
            "type": "integer"
          },
          "minNumerics": {
            "format": "int32",
            "type": "integer"
          },
          "minSpecial": {
            "format": "int32",
            "type": "integer"
          },
          "minUpperCase": {
            "format": "int32",
            "type": "integer"
          },
          "useZxcvbn": {
            "type": "boolean"
          }
        },
        "required": [
          "blockPreviousPasswords",
          "clearApiTokens",
          "clearWebSessions",
          "maxLength",
          "minLength",
          "minLowerCase",
          "minNumerics",
          "minSpecial",
          "minUpperCase",
          "useZxcvbn"
        ],
        "type": "object"
      },
      "PatternStatus": {
        "description": "Status of the exclusion pattern. The 'Applied' state indicates that a pattern is already in force. The 'Applying' state indicates that the index job that applies the pattern is still running. The 'Queued' state indicates that the indexing job to apply the pattern has not launched yet.",
        "enum": [
          "Applied",
          "Applying",
          "Queued"
        ],
        "type": "string"
      },
      "PerLocationCloudOutForecastSummary": {
        "properties": {
          "computeForecast": {
            "$ref": "#/components/schemas/CloudOutComputeForecastSummaries"
          },
          "instanceType": {
            "description": "Type of compute instance used at the cloud archival location.",
            "type": "string"
          },
          "locationName": {
            "description": "Name of the cloud archival location.",
            "type": "string"
          },
          "locationRegion": {
            "description": "Region of the cloud archival location.",
            "type": "string"
          },
          "locationType": {
            "description": "Type of cloud archival location.",
            "type": "string"
          },
          "storageForecast": {
            "$ref": "#/components/schemas/CloudOutStorageForecastSummaries"
          }
        },
        "required": [
          "locationName",
          "locationType",
          "storageForecast"
        ],
        "type": "object"
      },
      "PerStorageClassCloudOutStorageForecastSummary": {
        "properties": {
          "storageClass": {
            "description": "Storage class of the cloud archival location.",
            "type": "string"
          },
          "storageCostInUSD": {
            "description": "Storage costs, in USD, for a particular storage class in the cloud archival location. The list contains forecastPeriodInGranularityUnit values, one for each granularity period. For example, for a 3-year forecast period with a granularity of 'year', the list contains 3 values. The first value corresponds to the first year, the second value corresponds to the second year, and the third value corresponds to the third year.",
            "items": {
              "format": "int64",
              "minimum": 0,
              "type": "integer"
            },
            "type": "array"
          },
          "storageUsedInGB": {
            "description": "Storage values, in GBs, used on a particular storage class in the cloud archival location. The number of values in the list is specified by the value of the forecastPeriodInGranularityUnit parameter. Each value in the list is for the last day of the granularity period. For example, for a 3-year forecast period with a granularity of 'year', the list contains 3 values. First value corresponds to the last day of the first year. Second value corresponds to the last day of the second year. Third value corresponds to the last day of the third year.",
            "items": {
              "format": "int64",
              "minimum": 0,
              "type": "integer"
            },
            "type": "array"
          }
        },
        "required": [
          "storageClass",
          "storageCostInUSD",
          "storageUsedInGB"
        ],
        "type": "object"
      },
      "PolicyCheckResult": {
        "properties": {
          "checkOutput": {
            "description": "Output from the policy.",
            "type": "string"
          },
          "isCheckPassed": {
            "description": "Individual check results.",
            "type": "boolean"
          },
          "nodeId": {
            "description": "Node ID on which policy is enforced.",
            "type": "string"
          },
          "policyId": {
            "description": "Policy ID for which result is collected.",
            "type": "string"
          }
        },
        "required": [
          "isCheckPassed",
          "nodeId",
          "policyId"
        ],
        "type": "object"
      },
      "PolicyScopeEnum": {
        "description": "Scope of a policy.",
        "enum": [
          "POLICY_SCOPE_UNKNOWN",
          "NODE",
          "CLUSTER",
          "CHASSIS"
        ],
        "type": "string"
      },
      "PolicyTypeEnum": {
        "description": "Type of policy.",
        "enum": [
          "POLICY_TYPE_UNKNOWN",
          "CHECKER",
          "COLLECTOR",
          "NOTIFIER"
        ],
        "type": "string"
      },
      "PrecheckFailureResult": {
        "properties": {
          "cause": {
            "description": "The cause of the failure.",
            "type": "string"
          },
          "errorCode": {
            "description": "The precheck failure error code. This is used as a reference to a KB article about the error.",
            "type": "string"
          },
          "errorMessage": {
            "description": "The precheck failure message.",
            "type": "string"
          },
          "id": {
            "description": "The ID of the precheck error message.",
            "type": "string"
          },
          "isUpgradeBlocker": {
            "description": "Specifies whether a failed precheck prevents an upgrade from starting.",
            "type": "boolean"
          },
          "isUserRemediable": {
            "description": "Can the user fix this precheck failure.",
            "type": "boolean"
          },
          "precheckName": {
            "description": "The name of the failed upgrade precheck.",
            "type": "string"
          },
          "remedy": {
            "description": "The user action needed to recover from this failure.",
            "type": "string"
          }
        },
        "required": [
          "errorCode",
          "errorMessage",
          "id",
          "isUpgradeBlocker",
          "isUserRemediable",
          "precheckName"
        ],
        "type": "object"
      },
      "PrecheckStatusNextRunInfo": {
        "properties": {
          "jobInstanceId": {
            "description": "Identifier corresponding to the currently running or next upgrade prechecks job instance.\n",
            "type": "string"
          },
          "startTime": {
            "description": "The Unix epoch timestamp, in milliseconds, corresponding to the start of the currently running or next upgrade prechecks job instance.\n",
            "format": "int64",
            "type": "integer"
          },
          "status": {
            "description": "Status of the currently running or next upgrade prechecks job instance.\n",
            "type": "string"
          }
        },
        "required": [
          "jobInstanceId",
          "startTime",
          "status"
        ],
        "type": "object"
      },
      "PrecheckStatusResponse": {
        "properties": {
          "endTime": {
            "description": "The Unix epoch timestamp, in milliseconds, corresponding to the end of the last completed upgrade prechecks job instance.\n",
            "format": "int64",
            "type": "integer"
          },
          "failureResults": {
            "description": "The results of the failed prechecks. This includes the name of the failed prechecks and details of the error.",
            "items": {
              "$ref": "#/components/schemas/PrecheckFailureResult"
            },
            "type": "array"
          },
          "isOnDemand": {
            "description": "Specifies whether this result is from a user-triggered job.",
            "type": "boolean"
          },
          "nextRunInfo": {
            "$ref": "#/components/schemas/PrecheckStatusNextRunInfo"
          },
          "numPrechecksRun": {
            "description": "Total number of upgrade prechecks that were run.",
            "format": "int32",
            "type": "integer"
          },
          "runPeriodInMinutes": {
            "description": "Time, in minutes, between consecutive runs of scheduled upgrade prechecks job instances.\n",
            "format": "int32",
            "type": "integer"
          },
          "startTime": {
            "description": "The Unix epoch timestamp, in milliseconds, corresponding to the start of the last completed upgrade prechecks job instance.\n",
            "format": "int64",
            "type": "integer"
          }
        },
        "required": [
          "endTime",
          "failureResults",
          "isOnDemand",
          "numPrechecksRun",
          "runPeriodInMinutes",
          "startTime"
        ],
        "type": "object"
      },
      "PreferredCdpNetworkProtocol": {
        "description": "The preferred network protocol to use for transferring CDP data.",
        "enum": [
          "IPv4",
          "IPv6"
        ],
        "type": "string"
      },
      "PreferredCdpNetworkProtocolObject": {
        "properties": {
          "preferredCdpNetworkProtocol": {
            "$ref": "#/components/schemas/PreferredCdpNetworkProtocol"
          }
        },
        "required": [
          "preferredCdpNetworkProtocol"
        ],
        "type": "object"
      },
      "PrincipalSearchSortAttribute": {
        "description": "Attributes used to sort principal search results.",
        "enum": [
          "Name",
          "PrincipalType",
          "Description",
          "FirstName",
          "LastName",
          "EmailAddress",
          "DisplayName"
        ],
        "type": "string"
      },
      "PrincipalSummaryV1": {
        "properties": {
          "authDomainId": {
            "description": "ID of the authentication domain for a specified principal.",
            "type": "string"
          },
          "authDomainType": {
            "$ref": "#/components/schemas/AuthDomainType"
          },
          "description": {
            "description": "Short description for a principal of type group. For all other types the value is null.\n",
            "type": "string"
          },
          "emailAddress": {
            "description": "Email address associated with a principal.",
            "type": "string"
          },
          "firstName": {
            "description": "First name of a principal of type user. For all other types the value is null.\n",
            "type": "string"
          },
          "id": {
            "description": "ID of a principal in an authentication domain.",
            "type": "string"
          },
          "isAssignedRoles": {
            "description": "A Boolean that specifies whether the principal has any roles assigned. When this value is 'true,' the principal has one or more roles assigned.\n",
            "type": "boolean"
          },
          "isAssignedRolesOrIsLocal": {
            "description": "A Boolean that specifies whether the principal is a local user or has any roles assigned. When this value is 'true,' the principal either has one or more roles assigned or is a local user.\n",
            "type": "boolean"
          },
          "isLocked": {
            "description": "Boolean value that shows the lock state of a user account. Value is true when the account is locked and false when the account is not locked.\n",
            "type": "boolean"
          },
          "isTotpEnabled": {
            "description": "Indicates if the principal has TOTP authentication enabled. Returns true when TOTP is enabled, returns false when TOTP is not enabled.\n",
            "type": "boolean"
          },
          "isTotpEnforced": {
            "description": "Indicates if the TOTP authentication is enforced. Returns true when TOTP is enforced, returns false when TOTP is not enforced.\n",
            "type": "boolean"
          },
          "lastName": {
            "description": "Last name of a principal of type user. For all other types the value is null.\n",
            "type": "string"
          },
          "mfaServerName": {
            "description": "Name of the MFA server assgined to the user.\n",
            "type": "string"
          },
          "name": {
            "description": "The name of a principal in an authentication domain.",
            "type": "string"
          },
          "principalType": {
            "$ref": "#/components/schemas/PrincipalType"
          },
          "roles": {
            "description": "Roles assigned to this principal.",
            "items": {
              "$ref": "#/components/schemas/RoleInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "authDomainId",
          "authDomainType",
          "id",
          "isAssignedRoles",
          "isAssignedRolesOrIsLocal",
          "isLocked",
          "name",
          "principalType",
          "roles"
        ],
        "type": "object"
      },
      "PrincipalSummaryV1ListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/PrincipalSummaryV1"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "PrincipalType": {
        "description": "The Type of a principal in an authentication domain. Type can be user or group.\n",
        "enum": [
          "User",
          "Group"
        ],
        "type": "string"
      },
      "PrincipalWithRoleInfo": {
        "properties": {
          "principal": {
            "description": "The principal that is assigned the roles.",
            "type": "string"
          },
          "roles": {
            "description": "The roles that are assigned to the principal.",
            "items": {
              "$ref": "#/components/schemas/RoleInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "principal",
          "roles"
        ],
        "type": "object"
      },
      "ProtectedObjectsCount": {
        "properties": {
          "numDoNotProtect": {
            "format": "int64",
            "type": "integer"
          },
          "numNoSla": {
            "format": "int64",
            "type": "integer"
          },
          "numProtected": {
            "format": "int64",
            "type": "integer"
          },
          "numTotal": {
            "format": "int64",
            "type": "integer"
          }
        },
        "required": [
          "numProtected",
          "numTotal"
        ],
        "type": "object"
      },
      "QuarterlyConfig": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FrequencyConfig"
          },
          {
            "properties": {
              "dayOfQuarter": {
                "$ref": "#/components/schemas/SlaDayOfQuarter"
              },
              "firstQuarterStartMonth": {
                "$ref": "#/components/schemas/SlaMonth"
              }
            },
            "required": [
              "dayOfQuarter",
              "firstQuarterStartMonth"
            ],
            "type": "object"
          }
        ]
      },
      "RbsHostOperationRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/RbsHostUserConfig"
          },
          {
            "properties": {
              "operationMode": {
                "$ref": "#/components/schemas/OperationMode"
              }
            },
            "type": "object"
          }
        ]
      },
      "RbsHostOperationResponse": {
        "properties": {
          "asyncRequestStatus": {
            "$ref": "#/components/schemas/AsyncRequestStatus"
          },
          "rbsHostSummary": {
            "$ref": "#/components/schemas/RbsHostSummary"
          }
        },
        "type": "object"
      },
      "RbsHostSummary": {
        "properties": {
          "agentId": {
            "description": "UUID that uniquely identifies the Rubrik Backup Service on the Rubrik cluster.",
            "type": "string"
          },
          "agentVersion": {
            "description": "Version of the Rubrik Backup Service.",
            "type": "string"
          },
          "name": {
            "description": "IP address or hostname of the host.",
            "type": "string"
          },
          "osInfo": {
            "description": "Version of the operating system that the host is running.",
            "type": "string"
          },
          "osType": {
            "description": "Type of the operating system that the host is running.",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/HostRbsStatus"
          }
        },
        "required": [
          "name",
          "status"
        ],
        "type": "object"
      },
      "RbsHostUserConfig": {
        "properties": {
          "name": {
            "description": "IP address or hostname of the host.",
            "type": "string"
          },
          "operationTimeout": {
            "default": 600,
            "description": "Number of seconds after which the operation is terminated if it has not completed execution. Default value is 600 seconds.",
            "format": "int64",
            "type": "integer"
          },
          "password": {
            "description": "Password associated with the username that has access to the host.",
            "type": "string",
            "x-secret": true
          },
          "username": {
            "description": "Name of the user account that has sudo/admin privileges on the RBS host. This is required to install/uninstall/upgrade RBS packages on the RBS host.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "password",
          "username"
        ],
        "type": "object"
      },
      "ReaderRefreshDataSourcesRequest": {
        "properties": {
          "archivalDataSourceIds": {
            "description": "The owner cluster assigned IDs for data sources previously recovered from a reader archival location, which is a read only archival location connected from the local cluster to the archival location owned by some other cluster through connect-as-reader operation.\n",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "localDataSourceIds": {
            "description": "The locally assigned IDs for data sources previously recovered from a reader archival location, which is a read only archival location connected from the local cluster to the archival location owned by some other cluster through connect-as-reader operation.\n",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "RefreshableObjectConnectionStatus": {
        "properties": {
          "message": {
            "description": "Details about the object status. Will be populated if the status is \"BadlyConfigured\".",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/RefreshableObjectConnectionStatusType"
          }
        },
        "required": [
          "status"
        ],
        "type": "object"
      },
      "RefreshableObjectConnectionStatusType": {
        "description": "Status of the refreshable object. Possible values are \"Disconnected\" (no communication possible with object), \"Refreshing\" (able to communicate with object but has not refreshed yet), \"Connected\" (refreshed the metadata for the object), \"BadlyConfigured\" (object not configured correctly), \"Deleting\" (in process of removing the object), and \"Remote\" (replicated object that we should not connect to).",
        "enum": [
          "Disconnected",
          "Refreshing",
          "Connected",
          "BadlyConfigured",
          "Deleting",
          "Remote"
        ],
        "type": "string"
      },
      "RelocateMountConfig": {
        "properties": {
          "datastoreId": {
            "description": "The ID of the datastore that is the target of relocation.",
            "type": "string"
          }
        },
        "required": [
          "datastoreId"
        ],
        "type": "object"
      },
      "RemediationRequest": {
        "properties": {
          "config": {
            "$ref": "#/components/schemas/RemediationRequestRunConfig"
          },
          "spec": {
            "description": "List of identifiers to uniquely identify failed tasks.\n",
            "items": {
              "$ref": "#/components/schemas/RemediationRequestSpec"
            },
            "type": "array"
          }
        },
        "required": [
          "config",
          "spec"
        ],
        "type": "object"
      },
      "RemediationRequestRunConfig": {
        "properties": {
          "runNow": {
            "description": "If false, Rubrik CDM uses the configured SLA domain backup window to reschedule the task.\n",
            "type": "boolean"
          }
        },
        "required": [
          "runNow"
        ],
        "type": "object"
      },
      "RemediationRequestSpec": {
        "properties": {
          "eventSeriesId": {
            "description": "Event series ID of the failed or cancelled task.\n",
            "type": "string"
          },
          "objectId": {
            "description": "Object id.\n",
            "type": "string"
          }
        },
        "required": [
          "eventSeriesId",
          "objectId"
        ],
        "type": "object"
      },
      "RemediationResponse": {
        "properties": {
          "asyncRequestStatus": {
            "$ref": "#/components/schemas/AsyncRequestStatus"
          },
          "eventSeriesId": {
            "description": "Aggregated ID for the series of events, including the status for all retry attempts.\n",
            "type": "string"
          }
        },
        "required": [
          "asyncRequestStatus",
          "eventSeriesId"
        ],
        "type": "object"
      },
      "ReplicationSpec": {
        "properties": {
          "locationId": {
            "type": "string"
          },
          "locationName": {
            "type": "string"
          },
          "logRetentionLimit": {
            "description": "Specifies an interval in seconds. Logs are retained at the replication location until the specified interval expires.",
            "format": "int64",
            "type": "integer"
          },
          "replicationType": {
            "$ref": "#/components/schemas/ReplicationType"
          },
          "retentionLimit": {
            "format": "int64",
            "type": "integer"
          }
        },
        "required": [
          "locationId",
          "retentionLimit"
        ],
        "type": "object"
      },
      "ReplicationType": {
        "description": "The type of replication for an SLA Domain.",
        "enum": [
          "REPLICATION_TO_CLUSTER",
          "REPLICATION_TO_CLOUD_LOCATION"
        ],
        "type": "string"
      },
      "ReportConfigPatch": {
        "properties": {
          "cleanupReportJobInstanceForLogJobs": {
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "ReportConfigResponse": {
        "properties": {
          "cleanupReportJobInstanceForLogJobs": {
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "ReportableObjectType": {
        "description": "Object types that are reported on.",
        "enum": [
          "AppBlueprint",
          "Ec2Instance",
          "Hdfs",
          "HypervVirtualMachine",
          "LinuxFileset",
          "ManagedVolume",
          "Mssql",
          "NutanixVirtualMachine",
          "OracleDatabase",
          "SapHanaDatabase",
          "ShareFileset",
          "StorageArrayVolumeGroup",
          "VcdVapp",
          "VmwareVirtualMachine",
          "WindowsFileset",
          "WindowsVolumeGroup"
        ],
        "type": "string"
      },
      "RequestErrorInfo": {
        "properties": {
          "message": {
            "description": "The error message for failed IDs.",
            "type": "string"
          }
        },
        "required": [
          "message"
        ],
        "type": "object"
      },
      "RequestFailedException": {
        "properties": {
          "code": {
            "type": "string"
          },
          "errorType": {
            "type": "string"
          },
          "message": {
            "type": "string"
          },
          "param": {
            "type": "string"
          }
        },
        "required": [
          "errorType",
          "message"
        ],
        "type": "object"
      },
      "ResourceTagDefinition": {
        "description": "Provides the definition to create a new user-defined resource tag.\n",
        "properties": {
          "key": {
            "description": "The key of the resource tag.",
            "type": "string"
          },
          "scopeRefId": {
            "description": "The ID of the archival location associated with the resource that has the specified user-defined resource tag.\n",
            "type": "string"
          },
          "value": {
            "description": "The value of the resource tag.",
            "type": "string"
          }
        },
        "required": [
          "key",
          "scopeRefId",
          "value"
        ],
        "type": "object"
      },
      "ResourceTagDeleteResponse": {
        "description": "Lists the IDs of resource tags that were deleted successfully.\n",
        "properties": {
          "ids": {
            "description": "List of deleted IDs.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "ids"
        ],
        "type": "object"
      },
      "ResourceTagDetail": {
        "description": "Provides the details for a user-defined resource tag, which tags cloud compute resources created by CloudOn and CloudOut.\n",
        "properties": {
          "id": {
            "description": "The ID of the resource tag.",
            "type": "string"
          },
          "key": {
            "description": "The key of the resource tag.",
            "type": "string"
          },
          "lastUpdateTime": {
            "description": "A timestamp (in UTC) that indicates when the resource tag was last updated.\n",
            "type": "string"
          },
          "scopeRefId": {
            "description": "The ID of the archival location associated with the resource that has the specified user-defined resource tag.\n",
            "type": "string"
          },
          "value": {
            "description": "The value of the resource tag.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "key",
          "lastUpdateTime",
          "scopeRefId",
          "value"
        ],
        "type": "object"
      },
      "ResourceTagGetResponse": {
        "description": "Returns the results of a query on user-defined resource tags.\n",
        "properties": {
          "resourceTags": {
            "description": "List of resource tags.",
            "items": {
              "$ref": "#/components/schemas/ResourceTagDetail"
            },
            "type": "array"
          }
        },
        "required": [
          "resourceTags"
        ],
        "type": "object"
      },
      "ResourceTagUpdate": {
        "description": "Updates an existing user-defined resource tag.\n",
        "properties": {
          "value": {
            "description": "The value of the resource tag.",
            "type": "string"
          }
        },
        "required": [
          "value"
        ],
        "type": "object"
      },
      "RestoreFileJobConfig": {
        "properties": {
          "domainName": {
            "description": "Domain name (Use . for local admin).",
            "type": "string"
          },
          "ignoreErrors": {
            "default": false,
            "description": "Optional Boolean field to determine whether to ignore errors during restore jobs that use the Rubrik Backup Service. When 'true', errors are ignored. Default value is 'false', errors are not ignored.",
            "type": "boolean"
          },
          "password": {
            "description": "Password.",
            "type": "string",
            "x-secret": true
          },
          "path": {
            "description": "Absolute file path.",
            "type": "string"
          },
          "restorePath": {
            "description": "Directory of folder to copy files into.",
            "type": "string"
          },
          "shouldRestoreXAttrs": {
            "description": "Boolean value that determines restore file settings for Linux systems and for Windows systems. For Linux, use 'true' to include the extended attributes of restored files. For Window, use 'true' to include alternate data streams for restored files. For both, use 'false' to exclude this additional metadata.",
            "type": "boolean"
          },
          "shouldSaveCredentials": {
            "description": "A Boolean value that specifies whether to save the user-entered credentials. When 'true', the user-entered credentials are saved.",
            "type": "boolean"
          },
          "shouldUseAgent": {
            "default": true,
            "description": "A Boolean that specifies whether to use the Rubrik Backup Service or VMware tools to restore file. When 'true', the RBS restores file. When 'false', the VMware tools restores file.",
            "type": "boolean"
          },
          "username": {
            "description": "Username.",
            "type": "string"
          }
        },
        "required": [
          "path",
          "restorePath"
        ],
        "type": "object"
      },
      "RestoreMssqlDbJobConfig": {
        "properties": {
          "finishRecovery": {
            "description": "A Boolean value that determines the recovery option to use during database restore. When this value is 'true', the database is restored using the RECOVERY option and is fully functional at the end of the restore operation. When this value is 'false', the database is restored using the NORECOVERY option and remains in recovering mode at the end of the restore operation.",
            "type": "boolean"
          },
          "maxDataStreams": {
            "description": "Maximum number of parallel data streams that can be used to copy data to the target system.",
            "format": "int32",
            "type": "integer"
          },
          "recoveryPoint": {
            "$ref": "#/components/schemas/MssqlRecoveryPoint"
          }
        },
        "required": [
          "recoveryPoint"
        ],
        "type": "object"
      },
      "RoleAssignmentRequest": {
        "properties": {
          "principals": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "roles": {
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "principals",
          "roles"
        ],
        "type": "object"
      },
      "RoleInfo": {
        "properties": {
          "description": {
            "description": "The description of the role.",
            "type": "string"
          },
          "name": {
            "description": "The name of the role.",
            "type": "string"
          },
          "organizationId": {
            "description": "The ID of the organization that owns the role.",
            "type": "string"
          },
          "roleId": {
            "description": "The ID of the role.",
            "type": "string"
          },
          "roleTemplate": {
            "description": "The role template associated with the role.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "organizationId",
          "roleId"
        ],
        "type": "object"
      },
      "RoleInfoCreate": {
        "properties": {
          "description": {
            "description": "The description of the role.",
            "type": "string"
          },
          "name": {
            "description": "The name of the role.",
            "type": "string"
          },
          "organizationId": {
            "description": "The ID of the organization that owns the role.",
            "type": "string"
          },
          "roleTemplate": {
            "description": "The role template associated with the role.",
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "RoleInfoListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/RoleInfo"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "RoleInfoUpdate": {
        "properties": {
          "description": {
            "description": "The description of the role.",
            "type": "string"
          },
          "name": {
            "description": "The name of the role.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "RoleInfoWithPrincipals": {
        "properties": {
          "principals": {
            "description": "The principals that are assigned the role.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "role": {
            "$ref": "#/components/schemas/RoleInfo"
          }
        },
        "required": [
          "principals",
          "role"
        ],
        "type": "object"
      },
      "RoleListSortAttributes": {
        "description": "Attributes that are available to use when sorting query results for roles.\n",
        "enum": [
          "Name",
          "Description",
          "RoleTemplate"
        ],
        "type": "string"
      },
      "RsaMfaServerConfig": {
        "allOf": [
          {
            "$ref": "#/components/schemas/RsaMfaServerConfigWithoutSecrets"
          },
          {
            "properties": {
              "restApiAccessId": {
                "description": "A unique string that RSA SecurID Access uses to identify individual REST API clients (not to be confused with a REST API Key described above).\n",
                "type": "string",
                "x-secret": true
              },
              "restApiKey": {
                "description": "A unique string that RSA SecurID Access generates and uses as a shared secret with REST API clients.\n",
                "type": "string",
                "x-secret": true
              }
            },
            "required": [
              "restApiKey"
            ],
            "type": "object"
          }
        ]
      },
      "RsaMfaServerConfigUpdate": {
        "allOf": [
          {
            "properties": {
              "assurancePolicyName": {
                "description": "The name of a Cloud Authentication Service policy. This setting is only required for RSA Cloud Service configurations.\n",
                "type": "string"
              },
              "baseUrl": {
                "description": "The base url for RSA REST API server including the host name and port number. A valid input looks like https://<SECURID_ACCESS_HOST >:<REST_API_PORT>/mfa/v1_1.\n",
                "type": "string"
              },
              "certificateId": {
                "description": "ID corresponding to the imported certificate.",
                "type": "string"
              },
              "clientId": {
                "description": "A unique name to identify the client. When the client is configured to use RSA Authentication Manager, the client ID must match an authentication agent name.\n",
                "type": "string"
              },
              "ldapUsernameAttribute": {
                "description": "LDAP attribute to query the username used for performing MFA.\n",
                "type": "string"
              },
              "name": {
                "description": "Unique name to identify MFA server configuration.",
                "type": "string"
              },
              "restApiAccessId": {
                "description": "A unique string that RSA SecurID Access uses to identify individual REST API clients (not to be confused with a REST API Key described above).\n",
                "type": "string",
                "x-secret": true
              },
              "restApiKey": {
                "description": "A unique string that RSA SecurID Access generates and uses as a shared secret with REST API clients.\n",
                "type": "string",
                "x-secret": true
              },
              "timeout": {
                "description": "Specifies a number of seconds to wait for server response to a given authentication method.\n",
                "format": "int32",
                "type": "integer"
              }
            },
            "type": "object"
          }
        ]
      },
      "RsaMfaServerConfigWithoutSecrets": {
        "allOf": [
          {
            "$ref": "#/components/schemas/MfaServerConfig"
          },
          {
            "properties": {
              "assurancePolicyName": {
                "description": "The name of a Cloud Authentication Service policy. This setting is only required for RSA Cloud Service configurations.\n",
                "type": "string"
              },
              "baseUrl": {
                "description": "The base url for RSA REST API server including the host name and port number. A valid input looks like https://<SECURID_ACCESS_HOST >:<REST_API_PORT>/mfa/v1_1.\n",
                "type": "string"
              },
              "certificateId": {
                "description": "ID corresponding to the imported certificate.",
                "type": "string"
              },
              "clientId": {
                "description": "A unique name to identify the client. When the client is configured to use RSA Authentication Manager, the client ID must match an authentication agent name.\n",
                "type": "string"
              },
              "ldapUsernameAttribute": {
                "description": "LDAP attribute to query the username used for performing MFA.\n",
                "type": "string"
              }
            },
            "required": [
              "baseUrl"
            ],
            "type": "object"
          }
        ]
      },
      "RsaMfaServerDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/RsaMfaServerConfigWithoutSecrets"
          },
          {
            "properties": {
              "id": {
                "description": "Unique server identifier.",
                "type": "string"
              },
              "ldapUsernameAttribute": {
                "description": "LDAP attribute to query the username used for performing MFA.\n",
                "type": "string"
              },
              "timeout": {
                "description": "Specifies a number of seconds to wait for server response to a given authentication method.\n",
                "format": "int32",
                "type": "integer"
              }
            },
            "required": [
              "id",
              "ldapUsernameAttribute",
              "timeout"
            ],
            "type": "object"
          }
        ]
      },
      "RsaMfaServerDetailListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/RsaMfaServerDetail"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "RubrikMibFileDownloadLink": {
        "properties": {
          "downloadLink": {
            "description": "Rubrik MIB file download link.",
            "type": "string"
          }
        },
        "required": [
          "downloadLink"
        ],
        "type": "object"
      },
      "RubrikSamlMetadataDetail": {
        "properties": {
          "metadataXmlBase64": {
            "description": "Rubrik metadata XML file in a base64 encoded format.",
            "type": "string"
          }
        },
        "required": [
          "metadataXmlBase64"
        ],
        "type": "object"
      },
      "RubrikSamlMetadataInfo": {
        "properties": {
          "hostAddress": {
            "description": "The IP address or FQDN of the host that consumes the SAML assertions from the ID provider. When hostAddress is blank, an arbitrary floating IP address is assigned as the host.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "RubrikSamlMetadataSummary": {
        "properties": {
          "metadataUrl": {
            "description": "URL of the metadata file for downloading.",
            "type": "string"
          }
        },
        "required": [
          "metadataUrl"
        ],
        "type": "object"
      },
      "RunPolicyArg": {
        "properties": {
          "nodeIds": {
            "description": "List of node IDs where policies will be enforced.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "policyIds": {
            "description": "List of policy IDs.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "policyIds"
        ],
        "type": "object"
      },
      "SamlSsoAuthnRequestDetail": {
        "properties": {
          "idpSsoUrl": {
            "description": "The SSO endpoint where the SAML authentication request is sent.",
            "type": "string"
          },
          "relayState": {
            "description": "The SAML relay state associated with the SAML response and request.",
            "type": "string"
          },
          "samlRequest": {
            "description": "SAML authentication request XML in base-64 encoding.",
            "type": "string"
          }
        },
        "required": [
          "idpSsoUrl",
          "relayState",
          "samlRequest"
        ],
        "type": "object"
      },
      "SamlSsoAuthnRequestInfo": {
        "properties": {
          "isForIdpTest": {
            "default": false,
            "description": "A Boolean that determines whether the authentication request is part of an identity provider test. A value of 'true' indicates that the authentication request is part of an identity provider test. A value of 'false' indicates that the authentication request is not part of an identity provider test.",
            "type": "boolean"
          },
          "redirectPath": {
            "description": "The resource location that the Rubrik cluster redirects the browser to after a successful login. The value is the resource path portion of the URL of the resource. For example, for resource1 at http://example-host.com/resources/resource1, the value is \"/resources/resource1\".",
            "type": "string"
          }
        },
        "type": "object"
      },
      "SamlSsoStatus": {
        "properties": {
          "defaultIdp": {
            "description": "The name of the default IdP authentication domain used for SSO.",
            "type": "string"
          },
          "isGpsLoginEnabled": {
            "description": "To specify whether Federated Login is enabled. When the value is 'true', Federated Login is enabled. When this value is 'false', or this field not present, Federated Login is disabled. Federated login enables the inheritance of user roles and privileges from Polaris to CDM clusters registered on Polaris.",
            "type": "boolean"
          },
          "isSsoEnabled": {
            "description": "A Boolean value that specifies whether SAML SSO is enabled. When this value is 'true', SAML SSO is enabled. When this value is 'false', SAML SSO is disabled.",
            "type": "boolean"
          }
        },
        "required": [
          "isSsoEnabled"
        ],
        "type": "object"
      },
      "SapHanaAddSystemResponse": {
        "properties": {
          "asyncRequestStatus": {
            "$ref": "#/components/schemas/AsyncRequestStatus"
          },
          "id": {
            "description": "The ID of the added SAP HANA system.",
            "type": "string"
          }
        },
        "required": [
          "asyncRequestStatus",
          "id"
        ],
        "type": "object"
      },
      "SapHanaDataPathSpec": {
        "properties": {
          "name": {
            "description": "The name of the data backup storage. For on-premises backups, this value is the name of the Managed Volume. For GCP backups, this value is the name of the Google Cloud Platform bucket.",
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "SapHanaDataPathType": {
        "description": "Data path of the SAP HANA BACKINT interface specifying the location where the BACKINT interface stores backups. Supported data path types are MANAGED_VOLUME, GCP, and LOCAL. MANAGED_VOLUME specifies a data path used by the BACKINT interface to store backups on an on-premises Rubrik CDM cluster. GCP specifies that backups are stored on Google Cloud Platform. LOCAL indicates the backup is stored locally.",
        "enum": [
          "GCP",
          "MANAGED_VOLUME",
          "LOCAL"
        ],
        "type": "string"
      },
      "SapHanaDatabaseDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SapHanaDatabaseSummary"
          },
          {
            "properties": {
              "dataPathSpec": {
                "$ref": "#/components/schemas/SapHanaDataPathSpec"
              },
              "forceFull": {
                "description": "Determines whether to force a full snapshot for the next backup of the SAP HANA database. Use true to force a full snapshot and false to use the default. The backup job resets the parameter to false after a successful full backup.",
                "type": "boolean"
              },
              "latestRecoveryPoint": {
                "description": "The most recent recovery point for the database.",
                "format": "date-time",
                "type": "string"
              },
              "logSnapshotJobIntervalInMinutes": {
                "description": "The log snapshot job interval in minutes.",
                "format": "int32",
                "type": "integer"
              },
              "numChannels": {
                "description": "The number of channels for multistream backups.",
                "format": "int32",
                "type": "integer"
              },
              "oldestRecoveryPoint": {
                "description": "The earliest recovery point for the database.",
                "format": "date-time",
                "type": "string"
              },
              "previousFailedBackupPrefixes": {
                "description": "The Prefixes of previous failed backup jobs. Prefix is an identifier used by SAP HANA BACKINT to uniquely identify backups.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "snapshotCount": {
                "description": "The total number of SAP HANA snapshots that have been taken.",
                "format": "int32",
                "type": "integer"
              }
            },
            "required": [
              "forceFull",
              "logSnapshotJobIntervalInMinutes",
              "previousFailedBackupPrefixes",
              "snapshotCount"
            ],
            "type": "object"
          }
        ]
      },
      "SapHanaDatabaseListSortAttribute": {
        "description": "The SAP HANA database attribute to use in sorting the responses.",
        "enum": [
          "effectiveSlaDomainName",
          "name",
          "sapHanaSystemName"
        ],
        "type": "string"
      },
      "SapHanaDatabasePatch": {
        "properties": {
          "configuredSlaDomainId": {
            "description": "The ID of the SLA Domain that is configured for the SAP HANA database.",
            "type": "string"
          },
          "logSnapshotJobIntervalInMinutes": {
            "description": "The log snapshot job interval in minutes.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "SapHanaDatabaseSnapshotDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseSnapshotDetail"
          },
          {
            "$ref": "#/components/schemas/SapHanaDatabaseSnapshotSummary"
          }
        ]
      },
      "SapHanaDatabaseSnapshotSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseSnapshotSummary"
          },
          {
            "properties": {
              "backupId": {
                "description": "ID of the SAP HANA backup. This ID uniquely identifies a backup to SAP HANA. All backup files from a single backup share the same backup ID.",
                "format": "int64",
                "type": "integer"
              },
              "backupPrefix": {
                "description": "The backup prefix that was used while taking the backup.",
                "type": "string"
              },
              "backupType": {
                "description": "Type of the SAP HANA backup.",
                "enum": [
                  "FULL",
                  "INCREMENTAL"
                ],
                "type": "string"
              },
              "baseBackupId": {
                "description": "The backup ID of the full data backup or the delta backup on which the current delta backup is based.",
                "format": "int64",
                "type": "integer"
              },
              "isExternalBackup": {
                "description": "This specifies whether the backup was triggered by HANA studio, SAP HANA cockpit, or using HDBSQL commands.",
                "type": "boolean"
              },
              "isRubrikTriggeredOnDemandBackup": {
                "description": "This specifies whether the backup was triggered by Rubrik and and whether the backup is an on-demand snapshot.",
                "type": "boolean"
              },
              "rubrikSnapshotEndTime": {
                "description": "The end time, in UTC, of the backup with respect to the Rubrik cluster.",
                "format": "date-time",
                "type": "string"
              },
              "rubrikSnapshotStartTime": {
                "description": "The start time, in UTC, of the backup with respect to the Rubrik cluster.",
                "format": "date-time",
                "type": "string"
              },
              "sapHanaEndTime": {
                "description": "The end time, in UTC, of the backup with respect to the SAP HANA system.",
                "format": "date-time",
                "type": "string"
              },
              "sapHanaStartTime": {
                "description": "The start time, in UTC, of the backup with respect to the SAP HANA system.",
                "format": "date-time",
                "type": "string"
              }
            },
            "required": [
              "backupId",
              "backupPrefix",
              "backupType",
              "isExternalBackup",
              "isRubrikTriggeredOnDemandBackup",
              "rubrikSnapshotEndTime",
              "rubrikSnapshotStartTime",
              "sapHanaEndTime",
              "sapHanaStartTime"
            ],
            "type": "object"
          }
        ]
      },
      "SapHanaDatabaseSnapshotSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/SapHanaDatabaseSnapshotSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "SapHanaDatabaseSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Snappable"
          },
          {
            "properties": {
              "dataPathType": {
                "$ref": "#/components/schemas/SapHanaDataPathType"
              },
              "dbStatus": {
                "description": "Whether the database is in an ACTIVE,INACTIVE, or UNKNOWN state.",
                "enum": [
                  "ACTIVE",
                  "INACTIVE",
                  "UNKNOWN"
                ],
                "type": "string"
              },
              "dbType": {
                "description": "The type of SAP HANA database. Possible values are SYSTEM or TENANT. The SYSTEM database stores information about SAP HANA users and central system management. The TENANT database contains databases used by applications.",
                "enum": [
                  "SYSTEM",
                  "TENANT"
                ],
                "type": "string"
              },
              "id": {
                "description": "The ID of the SAP HANA database.",
                "type": "string"
              },
              "isRelic": {
                "description": "Specifies whether the SAP HANA database is accessible on the CDM cluster.",
                "type": "boolean"
              },
              "logBackupIntervalInSecs": {
                "description": "The log backup interval in seconds.",
                "format": "int32",
                "type": "integer"
              },
              "name": {
                "description": "The name of the SAP HANA database.",
                "type": "string"
              },
              "primaryClusterUuid": {
                "description": "The ID of the CDM cluster that protects the SAP HANA database.",
                "type": "string"
              },
              "protectionDate": {
                "description": "The UTC timestamp for when the SAP HANA database was first protected.",
                "format": "date-time",
                "type": "string"
              },
              "sapHanaSystemId": {
                "description": "The ID of the SAP HANA system that owns the database.",
                "type": "string"
              },
              "sapHanaSystemName": {
                "description": "Name of the SAP HANA system that owns the database.",
                "type": "string"
              }
            },
            "required": [
              "dataPathType",
              "dbStatus",
              "dbType",
              "id",
              "isRelic",
              "name",
              "primaryClusterUuid",
              "sapHanaSystemId",
              "sapHanaSystemName"
            ],
            "type": "object"
          }
        ]
      },
      "SapHanaDatabaseSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/SapHanaDatabaseSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "SapHanaHost": {
        "properties": {
          "hostName": {
            "description": "The IP address or fully qualified domain name of the SAP HANA host.",
            "type": "string"
          },
          "hostType": {
            "description": "The type of the SAP HANA system host. Possible values are MASTER, SLAVE, SECONDARY_MASTER or SECONDARY_SLAVE .",
            "enum": [
              "MASTER",
              "SLAVE",
              "SECONDARY_MASTER",
              "SECONDARY_SLAVE"
            ],
            "type": "string"
          },
          "hostUuid": {
            "description": "The ID of the SAP HANA system host.",
            "type": "string"
          },
          "sapHanaHostName": {
            "description": "The local name of the SAP HANA host.",
            "type": "string"
          },
          "status": {
            "description": "The status of the SAP HANA system host.",
            "type": "string"
          }
        },
        "required": [
          "hostName",
          "hostUuid",
          "status"
        ],
        "type": "object"
      },
      "SapHanaPatchSystemResponse": {
        "properties": {
          "asyncRequestStatus": {
            "$ref": "#/components/schemas/AsyncRequestStatus"
          },
          "systemSummary": {
            "$ref": "#/components/schemas/SapHanaSystemSummary"
          }
        },
        "required": [
          "asyncRequestStatus",
          "systemSummary"
        ],
        "type": "object"
      },
      "SapHanaRecoverableRange": {
        "properties": {
          "beginTime": {
            "description": "Start time of the SAP HANA recoverable range.",
            "format": "date-time",
            "type": "string"
          },
          "endTime": {
            "description": "End time of the SAP HANA recoverable range.",
            "format": "date-time",
            "type": "string"
          }
        },
        "required": [
          "beginTime",
          "endTime"
        ],
        "type": "object"
      },
      "SapHanaRecoverableRangeListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/SapHanaRecoverableRange"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "SapHanaRestoreSourceConfig": {
        "properties": {
          "snappable_id": {
            "description": "ID of the source database.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "SapHanaSslInfo": {
        "properties": {
          "encryptionProvider": {
            "description": "The encryption provider for the SAPA HANA system. Possible values are OPENSSL, COMMON_CRYPTO, SAP_CRYPTO.",
            "enum": [
              "OPENSSL",
              "COMMON_CRYPTO",
              "SAP_CRYPTO"
            ],
            "type": "string"
          },
          "keyStorePath": {
            "description": "The path where the encryption key for the SAP HANA system is stored.",
            "type": "string"
          }
        },
        "required": [
          "encryptionProvider",
          "keyStorePath"
        ],
        "type": "object"
      },
      "SapHanaSystemConfig": {
        "properties": {
          "dataPathSpec": {
            "$ref": "#/components/schemas/SapHanaSystemDataPathSpec"
          },
          "hostIds": {
            "description": "The SAP HANA system hosts.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "instanceNumber": {
            "description": "The instance number of the SAP HANA system.",
            "type": "string"
          },
          "password": {
            "description": "The password of the SAP HANA system.",
            "type": "string",
            "x-secret": true
          },
          "sid": {
            "description": "The SAP System Identification (SID) code for the SAP HANA system.",
            "type": "string"
          },
          "username": {
            "description": "The username of the SAP HANA system.",
            "type": "string"
          }
        },
        "required": [
          "hostIds",
          "instanceNumber",
          "password",
          "sid",
          "username"
        ],
        "type": "object"
      },
      "SapHanaSystemDataPathSpec": {
        "properties": {
          "dataPathType": {
            "$ref": "#/components/schemas/SapHanaDataPathType"
          }
        },
        "type": "object"
      },
      "SapHanaSystemInfo": {
        "properties": {
          "hanaVersion": {
            "description": "The version of the SAP HANA system.",
            "type": "string"
          },
          "isSystemReplicationEnabled": {
            "description": "Indicates whether the SAP HANA system has replication enabled.",
            "type": "boolean"
          }
        },
        "required": [
          "hanaVersion",
          "isSystemReplicationEnabled"
        ],
        "type": "object"
      },
      "SapHanaSystemListSortAttribute": {
        "description": "The SAP HANA system attribute to use in sorting the responses.",
        "enum": [
          "sid"
        ],
        "type": "string"
      },
      "SapHanaSystemPatch": {
        "properties": {
          "configuredSlaDomainId": {
            "description": "The ID of the SLA Domain that is configured for the SAP HANA system.",
            "type": "string"
          },
          "hostIds": {
            "description": "The SAP HANA system hosts.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "instanceNumber": {
            "description": "The instance number of the SAP HANA system.",
            "type": "string"
          },
          "password": {
            "description": "The password of the SAP HANA system.",
            "type": "string",
            "x-secret": true
          },
          "sid": {
            "description": "The SAP System Identification (SID) code for the SAP HANA system.",
            "type": "string"
          },
          "username": {
            "description": "The username of the SAP HANA system.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "SapHanaSystemSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SlaAssignable"
          },
          {
            "properties": {
              "containerType": {
                "description": "The container type of the SAP HANA system. Possible values are SINGLE_CONTAINER, MULTI_CONTAINER.",
                "enum": [
                  "SINGLE_CONTAINER",
                  "MULTI_CONTAINER"
                ],
                "type": "string"
              },
              "hosts": {
                "items": {
                  "$ref": "#/components/schemas/SapHanaHost"
                },
                "type": "array"
              },
              "id": {
                "description": "The ID of the SAP HANA system.",
                "type": "string"
              },
              "instanceNumber": {
                "description": "The instance number of the SAP HANA system.",
                "type": "string"
              },
              "lastRefreshTime": {
                "description": "The UTC timestamp for when the SAP HANA system was last refreshed.",
                "format": "date-time",
                "type": "string"
              },
              "numDbs": {
                "description": "The number of databases in the SAP HANA system.",
                "format": "int32",
                "type": "integer"
              },
              "sid": {
                "description": "The SAP System Identification (SID) code for the SAP HANA system.",
                "type": "string"
              },
              "sslInfo": {
                "$ref": "#/components/schemas/SapHanaSslInfo"
              },
              "status": {
                "description": "The status of the SAP HANA system.",
                "enum": [
                  "OK",
                  "WARNING",
                  "ERROR",
                  "UNKNOWN"
                ],
                "type": "string"
              },
              "statusMessage": {
                "description": "The message associated with the current SAP HANA system status.",
                "type": "string"
              },
              "systemInfo": {
                "$ref": "#/components/schemas/SapHanaSystemInfo"
              },
              "username": {
                "description": "The username of the SAP HANA system.",
                "type": "string"
              }
            },
            "required": [
              "hosts",
              "id",
              "instanceNumber",
              "numDbs",
              "sid",
              "status",
              "username"
            ],
            "type": "object"
          }
        ]
      },
      "SapHanaSystemSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/SapHanaSystemSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "ScriptErrorAction": {
        "description": "Action to take if the script returns an error or times out.",
        "enum": [
          "abort",
          "continue"
        ],
        "type": "string"
      },
      "SearchResponse": {
        "properties": {
          "fileVersions": {
            "items": {
              "$ref": "#/components/schemas/FileVersion"
            },
            "type": "array"
          },
          "filename": {
            "description": "Just the filename without the whole path.",
            "type": "string"
          },
          "path": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "SearchResponseListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/SearchResponse"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "SessionSummary": {
        "properties": {
          "expiration": {
            "type": "string"
          },
          "groups": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "id": {
            "type": "string"
          },
          "organizationId": {
            "type": "string"
          },
          "tag": {
            "type": "string"
          },
          "token": {
            "type": "string"
          },
          "userId": {
            "type": "string"
          }
        },
        "required": [
          "id",
          "organizationId",
          "token",
          "userId"
        ],
        "type": "object"
      },
      "SlaAssignable": {
        "properties": {
          "configuredSlaDomainId": {
            "description": "The ID of the SLA Domain configured directly on the Rubrik object.",
            "type": "string"
          },
          "configuredSlaDomainName": {
            "description": "The name of the SLA Domain configured directly on the Rubrik object.",
            "type": "string"
          },
          "configuredSlaDomainType": {
            "$ref": "#/components/schemas/ConfiguredSlaType"
          },
          "id": {
            "description": "The ID of the Rubrik object.",
            "type": "string"
          },
          "isConfiguredSlaDomainRetentionLocked": {
            "description": "Indicates whether the configured SLA Domain is Retention Locked. When this value is 'true', the configured SLA Domain is a Retention Lock SLA Domain.",
            "type": "boolean"
          },
          "name": {
            "description": "The name of the Rubrik object.",
            "type": "string"
          },
          "primaryClusterId": {
            "description": "The ID of the cluster that manages the Rubrik object.",
            "type": "string"
          },
          "slaLastUpdateTime": {
            "description": "The UTC time when the SLA Domain was last updated.",
            "format": "date-time",
            "type": "string"
          }
        },
        "required": [
          "configuredSlaDomainId",
          "configuredSlaDomainName",
          "id",
          "name",
          "primaryClusterId"
        ],
        "type": "object"
      },
      "SlaAssignment": {
        "description": "Specifies the method used to apply an SLA Domain to an object. Possible values are Derived, Direct, and Unassigned.",
        "enum": [
          "Derived",
          "Direct",
          "Unassigned"
        ],
        "type": "string"
      },
      "SlaConflictsSummary": {
        "properties": {
          "conflicts": {
            "items": {
              "$ref": "#/components/schemas/ManagedHierarchyObjectSummary"
            },
            "type": "array"
          },
          "id": {
            "description": "managedId.",
            "type": "string"
          },
          "isPossiblyInconsistent": {
            "description": "Indicates if the results returned are inconsistent due to an ongoing SLA assignment operation within this object's hierarchy. This endpoint does not consider the results of in flight SLA operations since they have not yet completed. Because the results may change once the operation completes, Rubrik advises waiting until all SLA assignments have completed on this hierarchy before reassigning, unless changing the childrens' SLAs directly with this assignment is unacceptable.\n",
            "type": "boolean"
          }
        },
        "required": [
          "conflicts",
          "id",
          "isPossiblyInconsistent"
        ],
        "type": "object"
      },
      "SlaDayOfMonth": {
        "description": "The day of the month when snapshot will be taken.",
        "enum": [
          "FirstDay",
          "Fifteenth",
          "LastDay"
        ],
        "type": "string"
      },
      "SlaDayOfQuarter": {
        "description": "The day of the quarter when snapshot will be taken.",
        "enum": [
          "FirstDay",
          "LastDay"
        ],
        "type": "string"
      },
      "SlaDayOfWeek": {
        "description": "The day of the week when snapshot will be taken.",
        "enum": [
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday",
          "Sunday"
        ],
        "type": "string"
      },
      "SlaDayOfYear": {
        "description": "The day of the year when snapshot will be taken.",
        "enum": [
          "FirstDay",
          "LastDay"
        ],
        "type": "string"
      },
      "SlaDomainDefinition": {
        "properties": {
          "allowedBackupWindows": {
            "items": {
              "$ref": "#/components/schemas/BackupWindow"
            },
            "type": "array"
          },
          "archivalSpecs": {
            "items": {
              "$ref": "#/components/schemas/ArchivalSpec"
            },
            "type": "array"
          },
          "firstFullAllowedBackupWindows": {
            "items": {
              "$ref": "#/components/schemas/BackupWindow"
            },
            "type": "array"
          },
          "frequencies": {
            "items": {
              "$ref": "#/components/schemas/SlaFrequency"
            },
            "type": "array"
          },
          "isRetentionLocked": {
            "description": "Boolean value that identifies a Retention Lock SLA Domain. Value is true when an SLA Domain is Retention Locked and false when it is not.",
            "type": "boolean"
          },
          "localRetentionLimit": {
            "format": "int64",
            "type": "integer"
          },
          "name": {
            "type": "string"
          },
          "replicationSpecs": {
            "items": {
              "$ref": "#/components/schemas/ReplicationSpec"
            },
            "type": "array"
          }
        },
        "required": [
          "firstFullAllowedBackupWindows",
          "frequencies",
          "name"
        ],
        "type": "object"
      },
      "SlaDomainPatchDefinition": {
        "properties": {
          "allowedBackupWindows": {
            "items": {
              "$ref": "#/components/schemas/BackupWindow"
            },
            "type": "array"
          },
          "archivalSpecs": {
            "items": {
              "$ref": "#/components/schemas/ArchivalSpec"
            },
            "type": "array"
          },
          "firstFullAllowedBackupWindows": {
            "items": {
              "$ref": "#/components/schemas/BackupWindow"
            },
            "type": "array"
          },
          "frequencies": {
            "items": {
              "$ref": "#/components/schemas/SlaFrequency"
            },
            "type": "array"
          },
          "isRetentionLocked": {
            "description": "Boolean value that identifies a Retention Lock SLA Domain. Value is true when an SLA Domain is Retention Locked and false when it is not.",
            "type": "boolean"
          },
          "localRetentionLimit": {
            "format": "int64",
            "type": "integer"
          },
          "name": {
            "type": "string"
          },
          "replicationSpecs": {
            "items": {
              "$ref": "#/components/schemas/ReplicationSpec"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "SlaDomainSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SlaObjectCounts"
          },
          {
            "properties": {
              "allowedBackupWindows": {
                "items": {
                  "$ref": "#/components/schemas/BackupWindow"
                },
                "type": "array"
              },
              "archivalSpecs": {
                "description": "Specification for archival locations on this SLA.",
                "items": {
                  "$ref": "#/components/schemas/ArchivalSpec"
                },
                "type": "array"
              },
              "firstFullAllowedBackupWindows": {
                "items": {
                  "$ref": "#/components/schemas/BackupWindow"
                },
                "type": "array"
              },
              "frequencies": {
                "items": {
                  "$ref": "#/components/schemas/SlaFrequency"
                },
                "type": "array"
              },
              "id": {
                "type": "string"
              },
              "isDefault": {
                "type": "boolean"
              },
              "isPaused": {
                "description": "A Boolean value that specifies whether protection for all the snappables that are protected by the specified SLA Domain is paused. When the value is 'true' protection is paused.",
                "type": "boolean"
              },
              "isRetentionLocked": {
                "description": "Boolean value that identifies a Retention Lock SLA Domain. Value is true when an SLA Domain is Retention Locked and false when it is not.",
                "type": "boolean"
              },
              "localRetentionLimit": {
                "description": "Retention limit for snapshots on the local Rubrik system. If none, they will remain as long as SLA requires.",
                "format": "int64",
                "type": "integer"
              },
              "maxLocalRetentionLimit": {
                "description": "Maximum limit for snapshots to be retained on the local Rubrik system. For local sla, it would be max of frequencies but for remote sla, it would be the retentionLimit set on the replication target location. (Local location is the replication target location for remote sla).",
                "format": "int64",
                "type": "integer"
              },
              "name": {
                "type": "string"
              },
              "primaryClusterId": {
                "type": "string"
              },
              "replicationSpecs": {
                "description": "Specification for replication locations on this SLA.",
                "items": {
                  "$ref": "#/components/schemas/ReplicationSpec"
                },
                "type": "array"
              },
              "uiColor": {
                "type": "string"
              }
            },
            "required": [
              "allowedBackupWindows",
              "firstFullAllowedBackupWindows",
              "frequencies",
              "id",
              "isDefault",
              "maxLocalRetentionLimit",
              "name",
              "primaryClusterId"
            ],
            "type": "object"
          }
        ]
      },
      "SlaDomainSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/SlaDomainSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "SlaFrequency": {
        "properties": {
          "frequency": {
            "format": "int32",
            "type": "integer"
          },
          "retention": {
            "format": "int32",
            "type": "integer"
          },
          "timeUnit": {
            "description": "Units for frequency and retention. Accepted values are Hourly, Daily, Weekly, Monthly, and Yearly.",
            "type": "string"
          }
        },
        "required": [
          "frequency",
          "retention",
          "timeUnit"
        ],
        "type": "object"
      },
      "SlaFrequencyV2": {
        "properties": {
          "daily": {
            "$ref": "#/components/schemas/FrequencyConfig"
          },
          "hourly": {
            "$ref": "#/components/schemas/FrequencyConfig"
          },
          "minute": {
            "$ref": "#/components/schemas/FrequencyConfig"
          },
          "monthly": {
            "$ref": "#/components/schemas/MonthlyConfig"
          },
          "quarterly": {
            "$ref": "#/components/schemas/QuarterlyConfig"
          },
          "weekly": {
            "$ref": "#/components/schemas/WeeklyConfig"
          },
          "yearly": {
            "$ref": "#/components/schemas/YearlyConfig"
          }
        },
        "type": "object"
      },
      "SlaMonth": {
        "description": "The month of the year when snapshot will be taken.",
        "enum": [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December"
        ],
        "type": "string"
      },
      "SlaObjectCounts": {
        "allOf": [
          {
            "$ref": "#/components/schemas/NutanixVmSlaObjectCount"
          },
          {
            "$ref": "#/components/schemas/AwsEc2InstanceSlaObjectCount"
          },
          {
            "$ref": "#/components/schemas/HypervVmSlaObjectCount"
          },
          {
            "$ref": "#/components/schemas/ManagedVolumeSlaObjectCount"
          },
          {
            "$ref": "#/components/schemas/MssqlDbSlaObjectCount"
          },
          {
            "$ref": "#/components/schemas/VcdVappSlaObjectCount"
          },
          {
            "properties": {
              "numFilesets": {
                "description": "The number of filesets protected under this SLA Domain.",
                "format": "int32",
                "type": "integer"
              },
              "numLinuxHosts": {
                "description": "The number of Linux servers with filesets protected under this SLA Domain.",
                "format": "int32",
                "type": "integer"
              },
              "numOracleDbs": {
                "description": "The number of actively protected oracle databases under this SLA Domain.",
                "format": "int32",
                "type": "integer"
              },
              "numProtectedObjects": {
                "description": "The total number of protected ojects under this SLA Domain.",
                "format": "int32",
                "type": "integer"
              },
              "numShares": {
                "description": "The number of shares protected under this SLA Domain.",
                "format": "int32",
                "type": "integer"
              },
              "numStorageArrayVolumeGroups": {
                "description": "The number of storage array volume groups protected under this SLA Domain.",
                "format": "int32",
                "type": "integer"
              },
              "numVms": {
                "format": "int32",
                "type": "integer"
              },
              "numWindowsHosts": {
                "description": "The number of Windows servers with filesets protected under this SLA Domain.",
                "format": "int32",
                "type": "integer"
              },
              "numWindowsVolumeGroups": {
                "description": "The number of Windows volume groups protected under this SLA Domain.",
                "format": "int32",
                "type": "integer"
              }
            },
            "type": "object"
          }
        ]
      },
      "SlaStartTimeAttributes": {
        "properties": {
          "dayOfWeek": {
            "format": "int32",
            "type": "integer"
          },
          "hour": {
            "format": "int32",
            "type": "integer"
          },
          "minutes": {
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "hour",
          "minutes"
        ],
        "type": "object"
      },
      "SlaTimeUnit": {
        "description": "Units for frequency and retention. Accepted values are Minute, Hourly, Daily, Weekly, Monthly, Quarterly, and Yearly.",
        "enum": [
          "Minute",
          "Hourly",
          "Daily",
          "Weekly",
          "Monthly",
          "Quarterly",
          "Yearly"
        ],
        "type": "string"
      },
      "Snappable": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SlaAssignable"
          },
          {
            "$ref": "#/components/schemas/EffectiveSlaHolder"
          },
          {
            "properties": {
              "retentionSlaDomainId": {
                "description": "The ID of the SLA Domain whose retention policy is in use.",
                "type": "string"
              },
              "slaAssignment": {
                "description": "The SLA assignment type. Direct SLA assignment means that a SLA Domain was configured directly on the Rubrik object by the user. Derived SLA assignment means that the Rubrik object inherits an SLA Domain from its parent Rubrik object.",
                "enum": [
                  "Derived",
                  "Direct",
                  "Unassigned"
                ],
                "type": "string"
              }
            },
            "required": [
              "slaAssignment"
            ],
            "type": "object"
          }
        ]
      },
      "SnappablePrivilegeStatus": {
        "description": "Whether the data source passes additional privilege checks.",
        "enum": [
          "Protectable"
        ],
        "type": "string"
      },
      "SnappableRecoveryInfo": {
        "properties": {
          "isRefreshInProgressOpt": {
            "description": "Indicates whether snapshot metadata refresh is in progress for this data source.",
            "type": "boolean"
          },
          "lastUpdatedTimeOpt": {
            "description": "The time when the recovery infomation was updated.",
            "format": "date-time",
            "type": "string"
          },
          "locationId": {
            "description": "The reader location ID.",
            "type": "string"
          },
          "newSnappableId": {
            "description": "The newly assigned ID of the recovered data source.",
            "type": "string"
          },
          "oldSnappableId": {
            "description": "The original data source ID used in the owner cluster.",
            "type": "string"
          }
        },
        "required": [
          "locationId",
          "newSnappableId",
          "oldSnappableId"
        ],
        "type": "object"
      },
      "SnapshotCloudStorageTier": {
        "description": "The current cloud storage tier of a snapshot. A snapshot's cloud storage tier determines how the cloud provider will determine storage and retrieval costs, as well as retrieval latency. Accepted values are Hot, Cool, AzureArchive (with Azure locations), Glacier, and GlacierDeepArchive (for AWS S3 locations). The value Cold has been deprecated in favor of AzureArchive, which is the recommended replacement value.\n",
        "enum": [
          "Hot",
          "Cool",
          "Cold",
          "AzureArchive",
          "Glacier",
          "GlacierDeepArchive"
        ],
        "type": "string"
      },
      "SnapshotEventSeries": {
        "properties": {
          "eventSeriesId": {
            "description": "The event series ID for the events triggered during the verification process for that snapshot.",
            "type": "string"
          },
          "snapshotId": {
            "description": "The ID of the snapshot.",
            "type": "string"
          }
        },
        "required": [
          "eventSeriesId",
          "snapshotId"
        ],
        "type": "object"
      },
      "SnapshotLocationRetentionInfo": {
        "properties": {
          "expirationTime": {
            "description": "Time when the snapshot expired or is expected to expire at this location. This field will only be set if the snapshot has ever existed at the location. If the snapshot is present at the location, but the expiration time calculation is pending, this field will be absent. If the expiration time calculation is complete and the field is still absent, the snapshot will be retained forever at this location.",
            "format": "date-time",
            "type": "string"
          },
          "id": {
            "description": "ID of the location.",
            "type": "string"
          },
          "isExpirationDateCalculated": {
            "description": "A Boolean that indicates whether expiration date for snapshot has been calculated. This field will be absent if the snapshot has never existed at this location.",
            "type": "boolean"
          },
          "isExpirationInformationUnavailable": {
            "description": "Indicates whether expiration information of the snapshot is unavailable at this location. This field is always and only present for replication locations. Its value is true if and only if the replicated snapshots are from pre-5.2 cluster.\n",
            "type": "boolean"
          },
          "isSnapshotPresent": {
            "description": "Boolean that specifies whether the snapshot is present at this location. When this value is 'false,' the snapshot is expired at this location. Because retention information is unreliable for locations where the snapshots are not present, confirming that this value is 'true' is the best practice.",
            "type": "boolean"
          },
          "name": {
            "description": "Name of the location.",
            "type": "string"
          },
          "snapshotFrequency": {
            "description": "The tag to determine what frequency the snapshot corresponds to at this location. The snapshot tag can be hourly, daily, weekly, monthly, quarterly, or yearly depending on the SLA frequency which is used to determine the retention of the snapshot. A value of \"Ready for Deletion\" means that the snapshot will be deleted soon. A value of \"Forever\" means that the snapshot will never be deleted. This field is absent when the tag computation is incomplete.\n",
            "type": "string"
          }
        },
        "required": [
          "id",
          "isSnapshotPresent",
          "name"
        ],
        "type": "object"
      },
      "SnapshotRetentionInfo": {
        "properties": {
          "archivalInfos": {
            "description": "List of snapshot retention information on the archival locations.",
            "items": {
              "$ref": "#/components/schemas/SnapshotLocationRetentionInfo"
            },
            "type": "array"
          },
          "cloudNativeLocationInfo": {
            "description": "Snapshot retention information such as frequency tag and expected expiration time on the cloud native locations.\n",
            "items": {
              "$ref": "#/components/schemas/SnapshotLocationRetentionInfo"
            },
            "type": "array"
          },
          "localInfo": {
            "$ref": "#/components/schemas/SnapshotLocationRetentionInfo"
          },
          "replicationInfos": {
            "description": "List of snapshot retention information on the replicated locations.",
            "items": {
              "$ref": "#/components/schemas/SnapshotLocationRetentionInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "archivalInfos",
          "cloudNativeLocationInfo",
          "replicationInfos"
        ],
        "type": "object"
      },
      "SnapshotSortAttribute": {
        "description": "Attributes that are available to use when sorting query results for snapshots.",
        "enum": [
          "SnapshotDateAndTime",
          "LocalExpirationDate",
          "ArchivalLocation"
        ],
        "type": "string"
      },
      "SnapshotStorageStats": {
        "properties": {
          "historicIngestedBytes": {
            "description": "Amount of bytes actually ingested for the snapshot. This value reflects the amount of bytes ingested during snapshot capture and remains consistent across different physical representations.",
            "format": "int64",
            "type": "integer"
          },
          "ingestedBytes": {
            "description": "Amount of bytes inferred to be ingested to our system for the snapshot. This may change for existing logical content, as physical representation of content changes.",
            "format": "int64",
            "type": "integer"
          },
          "logicalBytes": {
            "description": "Amount of logical bytes the snapshot represents.",
            "format": "int64",
            "type": "integer"
          },
          "physicalBytes": {
            "description": "Amount of bytes physically stored for the snapshot.",
            "format": "int64",
            "type": "integer"
          }
        },
        "required": [
          "historicIngestedBytes",
          "ingestedBytes",
          "logicalBytes",
          "physicalBytes"
        ],
        "type": "object"
      },
      "SnapshotSummary": {
        "properties": {
          "date": {
            "description": "Time at which the snapshot was taken.",
            "format": "date-time",
            "type": "string"
          },
          "id": {
            "description": "ID of the snapshot.",
            "type": "string"
          },
          "isCustomRetentionApplied": {
            "description": "A Boolean value that indicates whether custom retention is applied to the specified snapshot. Value is true when custom retention is applied to the snapshot.\n",
            "type": "boolean"
          },
          "isRetentionLockApplied": {
            "description": "Indicates whether the snapshot is protected by a Retention Locked SLA Domain.\n",
            "type": "boolean"
          },
          "snapshotRetentionInfo": {
            "$ref": "#/components/schemas/SnapshotRetentionInfo"
          },
          "snapshotType": {
            "$ref": "#/components/schemas/UnmanagedSnapshotType"
          }
        },
        "required": [
          "date",
          "id",
          "isCustomRetentionApplied",
          "isRetentionLockApplied",
          "snapshotRetentionInfo",
          "snapshotType"
        ],
        "type": "object"
      },
      "SnapshotSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/SnapshotSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "SnapshotType": {
        "description": "Specifies the type of snapshots to be returned.",
        "enum": [
          "OnDemand",
          "Scheduled",
          "Protected",
          "Unprotected"
        ],
        "type": "string"
      },
      "SoftwareAvailability": {
        "description": "Specifies the source from which the CDM software is available.\n",
        "enum": [
          "LocalCluster",
          "LocalNode",
          "Remote",
          "Downloading"
        ],
        "type": "string"
      },
      "SortColumn": {
        "description": "Columns that jobs can be sorted on.",
        "enum": [
          "StartTime",
          "JobStatus",
          "JobType",
          "ObjectType",
          "SlaDomainName",
          "EndTime",
          "ObjectLogicalSize",
          "DataTransferred",
          "Duration",
          "ObjectName"
        ],
        "type": "string"
      },
      "SortOrder": {
        "description": "Sort order.",
        "enum": [
          "asc",
          "desc"
        ],
        "type": "string"
      },
      "StageCdmSoftwareInfo": {
        "properties": {
          "md5sum": {
            "description": "The MD5 checksum for the CDM software package.",
            "type": "string"
          },
          "packageUrl": {
            "description": "The URL where the package that contains CDM software is located.\n",
            "type": "string"
          },
          "size": {
            "description": "Size, in bytes, of the package containing CDM software.",
            "format": "int64",
            "type": "integer"
          },
          "skipDownload": {
            "default": false,
            "description": "Specifies whether to download the CDM software externally. When this value is false, the CDM software package must be available on the cluster. When this value is true, provide the version.",
            "type": "boolean"
          },
          "version": {
            "description": "The version of the CDM software package. If the version is not provided, an attempt is made to parse the version from the package URL. The version is not needed unless the Rubrik provided software package has been renamed.\n",
            "type": "string"
          }
        },
        "required": [
          "md5sum",
          "packageUrl"
        ],
        "type": "object"
      },
      "StaticIpInfo": {
        "description": "Information about static IP configuration.",
        "properties": {
          "dns_servers": {
            "description": "DNS Servers for the specified IP addresses.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "gateway": {
            "description": "Gateway for the specified IP addresses.",
            "type": "string"
          },
          "ip_addresses": {
            "description": "IP addresses and ranges, separated by commas.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "subnet_mask": {
            "description": "Subnet mask for the specified IP addresses.",
            "type": "string"
          }
        },
        "required": [
          "ip_addresses",
          "subnet_mask"
        ],
        "type": "object"
      },
      "Status": {
        "properties": {
          "description": {
            "type": "string"
          },
          "status": {
            "type": "string"
          }
        },
        "required": [
          "status"
        ],
        "type": "object"
      },
      "StringResponse": {
        "properties": {
          "response": {
            "type": "string"
          }
        },
        "required": [
          "response"
        ],
        "type": "object"
      },
      "SubscriptionAttachmentType": {
        "description": "Email subscription attachment file type.",
        "enum": [
          "Csv"
        ],
        "type": "string"
      },
      "SubscriptionOwner": {
        "properties": {
          "userId": {
            "description": "User ID of the email subscription object owner.",
            "type": "string"
          },
          "username": {
            "description": "Username of the email subscription object owner.",
            "type": "string"
          }
        },
        "required": [
          "userId",
          "username"
        ],
        "type": "object"
      },
      "SubscriptionScheduleTimeAttributes": {
        "properties": {
          "dailyScheduleHour": {
            "description": "Hour of the day to send the scheduled email, if the user picks a daily schedule. 0 = 12AM, 23 = 11PM.",
            "format": "int32",
            "type": "integer"
          },
          "dayOfMonth": {
            "description": "Day of the month to send the scheduled email, if the user picks a monthly schedule.",
            "format": "int32",
            "type": "integer"
          },
          "daysOfWeek": {
            "description": "Day of the week, represented by numbers, to send the scheduled email, if the user picks a weekly schedule. 0 = Sunday, 1 = Monday, 2 = Tuesday, 3 = Wednesday, 4 = Thursday, 5 = Friday, 6 = Saturday.",
            "items": {
              "format": "int32",
              "type": "integer"
            },
            "type": "array"
          },
          "monthlyScheduleHour": {
            "description": "Hour of the user-specified day to send the scheduled email, if the user picks a monthly schedule. 0 = 12AM, 23 = 11PM.",
            "format": "int32",
            "type": "integer"
          },
          "weeklyScheduleHour": {
            "description": "Hour of the user-specified day to send the scheduled email, if the user picks a weekly schedule. 0 = 12AM, 23 = 11PM.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "SubscriptionStatus": {
        "description": "Status of email subscription.",
        "enum": [
          "Active",
          "Suspended",
          "Unknown"
        ],
        "type": "string"
      },
      "SupportDataConfig": {
        "properties": {
          "dataTypeToConfig": {
            "items": {
              "$ref": "#/components/schemas/SupportDataTypeConfig"
            },
            "type": "array"
          }
        },
        "required": [
          "dataTypeToConfig"
        ],
        "type": "object"
      },
      "SupportDataType": {
        "description": "The type of data that the Rubrik cluster uploads to Rubrik support. Valid data types are systemstats, errorlogs, traces, or uploads. System metrics such as CPU, memory, or storage are systemstats data. Errors encountered by the system, services or apps are errorlogs data. Routes followed by processes are traces data. Bundled data such as support bundles, report bundles, or metadata tables are uploads data.\n",
        "enum": [
          "systemstats",
          "errorlogs",
          "traces",
          "uploads",
          "capacityutilization"
        ],
        "type": "string"
      },
      "SupportDataTypeConfig": {
        "properties": {
          "dataType": {
            "$ref": "#/components/schemas/SupportDataType"
          },
          "shouldToggleChisel": {
            "default": false,
            "description": "Controls all the traffic to/from the Rubrik cluster. If set to true, and the user opts-out, this flag will be used to disable all telemetry, including the creation of the support tunnel. If the user opts-in, the flag will be used to enable a service to allow traffic movement to/from the Rubrik cluster.",
            "type": "boolean"
          },
          "status": {
            "$ref": "#/components/schemas/SupportDataTypeStatus"
          }
        },
        "required": [
          "dataType",
          "status"
        ],
        "type": "object"
      },
      "SupportDataTypeStatus": {
        "description": "Specifies whether upload of support data of a given type is enabled or disabled.\n",
        "enum": [
          "enabled",
          "disabled"
        ],
        "type": "string"
      },
      "SyslogExportRuleFull": {
        "properties": {
          "certificateId": {
            "description": "The ID corresponding to the imported certificate used by the syslog server.\n",
            "type": "string"
          },
          "enableTls": {
            "description": "Specifies whether TLS should be used to communicate with the syslog server.\n",
            "type": "boolean"
          },
          "facility": {
            "$ref": "#/components/schemas/SyslogFacility"
          },
          "hostname": {
            "type": "string"
          },
          "port": {
            "format": "int32",
            "type": "integer"
          },
          "protocol": {
            "$ref": "#/components/schemas/TransportLayerProtocol"
          },
          "severity": {
            "$ref": "#/components/schemas/SyslogSeverity"
          }
        },
        "required": [
          "enableTls",
          "facility",
          "hostname",
          "port",
          "protocol",
          "severity"
        ],
        "type": "object"
      },
      "SyslogExportRulePartial": {
        "properties": {
          "certificateId": {
            "description": "The ID corresponding to the imported certificate used by the syslog server.\n",
            "type": "string"
          },
          "enableTls": {
            "description": "Specifies whether TLS should be used to communicate with the syslog server.\n",
            "type": "boolean"
          },
          "facility": {
            "$ref": "#/components/schemas/SyslogFacility"
          },
          "hostname": {
            "type": "string"
          },
          "port": {
            "format": "int32",
            "type": "integer"
          },
          "protocol": {
            "$ref": "#/components/schemas/TransportLayerProtocol"
          },
          "severity": {
            "$ref": "#/components/schemas/SyslogSeverity"
          }
        },
        "type": "object"
      },
      "SyslogExportRuleSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SyslogExportRuleFull"
          },
          {
            "properties": {
              "id": {
                "description": "ID corresponding to the syslog export rule.",
                "type": "string"
              }
            },
            "required": [
              "id"
            ],
            "type": "object"
          }
        ]
      },
      "SyslogExportRuleSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/SyslogExportRuleSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "SyslogFacility": {
        "description": "The syslog message classification based on RFC 5424.",
        "enum": [
          "Kernel",
          "User",
          "Mail",
          "Daemon",
          "Auth",
          "Syslog",
          "Lpr",
          "News",
          "UUCP",
          "Cron",
          "Security",
          "FTP",
          "NTP",
          "LogAudit",
          "LogAlert",
          "Clock",
          "RubrikEvent",
          "RubrikCLI",
          "RubrikSSH",
          "RubrikApp",
          "All"
        ],
        "type": "string"
      },
      "SyslogMsgMibFileDownloadLink": {
        "properties": {
          "downloadLink": {
            "description": "Download link for the SYSLOG-MSG-MIB file.",
            "type": "string"
          }
        },
        "required": [
          "downloadLink"
        ],
        "type": "object"
      },
      "SyslogServerTestResult": {
        "properties": {
          "message": {
            "description": "The test message that was sent.",
            "type": "string"
          }
        },
        "required": [
          "message"
        ],
        "type": "object"
      },
      "SyslogSeverity": {
        "description": "The syslog message severity based on RFC 5424.",
        "enum": [
          "Emergency",
          "Alert",
          "Critical",
          "Error",
          "Warning",
          "Notice",
          "Informational",
          "Debug",
          "All"
        ],
        "type": "string"
      },
      "SyslogTcMibFileDownloadLink": {
        "properties": {
          "downloadLink": {
            "description": "Download link for the SYSLOG-TC-MIB file.",
            "type": "string"
          }
        },
        "required": [
          "downloadLink"
        ],
        "type": "object"
      },
      "TelemetryConfig": {
        "properties": {
          "telemetryLevel": {
            "$ref": "#/components/schemas/TelemetryLevel"
          }
        },
        "required": [
          "telemetryLevel"
        ],
        "type": "object"
      },
      "TelemetryLevel": {
        "description": "The level of telemetry set for the cluster. Basic is only stats while Full includes stats and logs.\n",
        "enum": [
          "Basic",
          "Disabled",
          "Full"
        ],
        "type": "string"
      },
      "TotpConfigUpdateRequest": {
        "properties": {
          "otpForValidation": {
            "description": "String containing a one time password for the time-based one time password (TOTP) authentication method.\n",
            "type": "string",
            "x-secret": true
          },
          "secret": {
            "description": "String containing a secret key for the time-based one time password (TOTP) authentication method.\n",
            "type": "string",
            "x-secret": true
          }
        },
        "required": [
          "otpForValidation",
          "secret"
        ],
        "type": "object"
      },
      "TotpGlobalSetting": {
        "properties": {
          "isEnforced": {
            "description": "Indicates whether the TOTP is enforced globally or not.",
            "type": "boolean"
          }
        },
        "required": [
          "isEnforced"
        ],
        "type": "object"
      },
      "TotpGlobalSettingUpdate": {
        "properties": {
          "isEnforced": {
            "description": "Indicates whether the TOTP is enforced globally or not.",
            "type": "boolean"
          }
        },
        "required": [
          "isEnforced"
        ],
        "type": "object"
      },
      "TotpSecret": {
        "properties": {
          "secret": {
            "description": "String containing a generated secret key for the time-based one time password (TOTP) authentication method.\n",
            "type": "string"
          },
          "secretUri": {
            "description": "String containing a generated URI for the time-based one time password (TOTP) authentication method. The URI includes the secret key and configuration information.\n",
            "type": "string"
          }
        },
        "required": [
          "secret",
          "secretUri"
        ],
        "type": "object"
      },
      "TotpStatus": {
        "properties": {
          "isEnabled": {
            "description": "Boolean value that indicates whether the time-based one time password (TOTP) authentication method is enabled. Returns Yes when TOTP is enable and No when it is not.\n",
            "type": "boolean"
          },
          "isEnforced": {
            "description": "Boolean value that indicates whether the time-based one time password (TOTP) authentication method is being enforced. Returns Yes when TOTP is enforced and No when it is not.\n",
            "type": "boolean"
          }
        },
        "required": [
          "isEnabled",
          "isEnforced"
        ],
        "type": "object"
      },
      "TransportLayerProtocol": {
        "description": "The network protocol to use, either UDP or TCP.",
        "enum": [
          "TCP",
          "UDP"
        ],
        "type": "string"
      },
      "TruststorePayload": {
        "properties": {
          "certIds": {
            "items": {
              "description": "Certificate to associate with truststore.",
              "type": "string"
            },
            "type": "array"
          },
          "truststoreType": {
            "$ref": "#/components/schemas/TruststoreType"
          }
        },
        "required": [
          "certIds",
          "truststoreType"
        ],
        "type": "object"
      },
      "TruststoreSummary": {
        "properties": {
          "certificates": {
            "description": "Signed certificate associated with truststore.",
            "items": {
              "$ref": "#/components/schemas/CertificateSummary"
            },
            "type": "array"
          },
          "truststoreType": {
            "$ref": "#/components/schemas/TruststoreType"
          }
        },
        "required": [
          "certificates",
          "truststoreType"
        ],
        "type": "object"
      },
      "TruststoreSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/TruststoreSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "TruststoreType": {
        "description": "The truststore type.",
        "enum": [
          "System",
          "Gcp"
        ],
        "type": "string"
      },
      "UnmanagedObjectDetails": {
        "properties": {
          "archiveStorage": {
            "description": "The amount of storage on the archival location used by unmanaged snapshots.",
            "format": "int64",
            "type": "integer"
          },
          "hasSnapshotsWithPolicy": {
            "description": "A boolean that specifies whether any of the snapshots for this object are being retained by a SLA Domain at any location.\n",
            "type": "boolean"
          },
          "id": {
            "type": "string"
          },
          "isRemote": {
            "description": "Boolean that specifies whether the object is remote or local. A value of true indicates that the object is remote.\n",
            "type": "boolean"
          },
          "localStorage": {
            "description": "The amount of storage on the local cluster used by unmanaged snapshots.",
            "format": "int64",
            "type": "integer"
          },
          "name": {
            "type": "string"
          },
          "objectType": {
            "description": "The type of the unmanaged object. Valid object types are VirtualMachine, MssqlDatabase, LinuxFileset, ShareFileset, WindowsFileset, NutanixVirtualMachine, Ec2Instance and StorageArrayVolumeGroup.",
            "enum": [
              "VirtualMachine",
              "MssqlDatabase",
              "LinuxFileset",
              "WindowsFileset",
              "ShareFileset",
              "NutanixVirtualMachine",
              "HypervVirtualMachine",
              "ManagedVolume",
              "Ec2Instance",
              "StorageArrayVolumeGroup",
              "VcdVapp",
              "LinuxHost",
              "WindowsHost",
              "OracleDatabase",
              "VolumeGroup",
              "AppBlueprint"
            ],
            "type": "string"
          },
          "pendingSlaDomain": {
            "$ref": "#/components/schemas/ManagedObjectPendingSlaInfo"
          },
          "physicalLocation": {
            "description": "Summary information of all objects on the physical path to this object.",
            "items": {
              "$ref": "#/components/schemas/LocationPathPoint"
            },
            "type": "array"
          },
          "recoveryInfo": {
            "$ref": "#/components/schemas/SnappableRecoveryInfo"
          },
          "retentionSlaDomainId": {
            "description": "ID assigned to an SLA Domain retention policy.",
            "type": "string"
          },
          "retentionSlaDomainName": {
            "description": "Name of an SLA Domain retention policy.",
            "type": "string"
          },
          "retentionSlaDomainPolarisManagedId": {
            "description": "Optional field with the ID assigned to an SLA Domain by Polaris.",
            "type": "string"
          },
          "snapshotCount": {
            "description": "Total number of snapshots to for the specified object.",
            "format": "int64",
            "type": "integer"
          },
          "unmanagedStatus": {
            "description": "Unmanaged Status of this object. Protected means that this object is still protected by an SLA Policy. Unprotected means that this object has become unprotected. Relic means that Rubrik has lost contact with this object.",
            "enum": [
              "Protected",
              "Relic",
              "Unprotected",
              "ReplicatedRelic",
              "RemoteUnprotected"
            ],
            "type": "string"
          }
        },
        "required": [
          "archiveStorage",
          "hasSnapshotsWithPolicy",
          "id",
          "localStorage",
          "name",
          "objectType",
          "physicalLocation",
          "retentionSlaDomainId",
          "retentionSlaDomainName",
          "snapshotCount",
          "unmanagedStatus"
        ],
        "type": "object"
      },
      "UnmanagedObjectDetailsListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/UnmanagedObjectDetails"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "UnmanagedObjectSlaAssignmentInfo": {
        "properties": {
          "managedIds": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "shouldApplyToNonPolicySnapshots": {
            "type": "boolean"
          },
          "slaDomainId": {
            "type": "string"
          }
        },
        "required": [
          "managedIds",
          "slaDomainId"
        ],
        "type": "object"
      },
      "UnmanagedObjectSortAttribute": {
        "description": "Attributes that are available to use when sorting query results for unmanaged objects.",
        "enum": [
          "Name",
          "UnmanagedStatus",
          "Location",
          "UnmanagedSnapshotCount",
          "LocalStorage",
          "ArchiveStorage",
          "RetentionSlaDomainName",
          "ObjectType",
          "SnapshotCount",
          "AutoSnapshotCount",
          "ManualSnapshotCount"
        ],
        "type": "string"
      },
      "UnmanagedObjectStatus": {
        "description": "Attributes that are available to use when filtering query results based on unmanaged object status.",
        "enum": [
          "Protected",
          "Relic",
          "Unprotected",
          "ReplicatedRelic",
          "RemoteUnprotected"
        ],
        "type": "string"
      },
      "UnmanagedObjectSummary": {
        "properties": {
          "archiveStorage": {
            "description": "Storage being taken up in the archival location by unmanaged snapshots.",
            "format": "int64",
            "type": "integer"
          },
          "autoSnapshotCount": {
            "description": "Number of policy-based snapshots to retain for the specified object.",
            "format": "int64",
            "type": "integer"
          },
          "hasSnapshotsWithPolicy": {
            "description": "A boolean that specifies whether any of the snapshots for this object are being retained by a SLA  at any location.\n",
            "type": "boolean"
          },
          "id": {
            "type": "string"
          },
          "isRemote": {
            "description": "A boolean that specifies if the object is remote or local. When this value is true, the object is remote.",
            "type": "boolean"
          },
          "localStorage": {
            "description": "Storage being taken up on the local cluster by unmanaged snapshots.",
            "format": "int64",
            "type": "integer"
          },
          "manualSnapshotCount": {
            "description": "Number of on-demand snapshots and snapshots retrieved from an archival location for specified object.",
            "format": "int64",
            "type": "integer"
          },
          "name": {
            "type": "string"
          },
          "objectType": {
            "description": "The type of the unmanaged object. This may be VirtualMachine, MssqlDatabase, LinuxFileset, ShareFileset, WindowsFileset, NutanixVirtualMachine, Ec2Instance or StorageArrayVolumeGroup.",
            "enum": [
              "VirtualMachine",
              "MssqlDatabase",
              "LinuxFileset",
              "WindowsFileset",
              "ShareFileset",
              "NutanixVirtualMachine",
              "HypervVirtualMachine",
              "ManagedVolume",
              "Ec2Instance",
              "StorageArrayVolumeGroup",
              "VcdVapp",
              "LinuxHost",
              "WindowsHost",
              "OracleDatabase",
              "VolumeGroup",
              "AppBlueprint"
            ],
            "type": "string"
          },
          "pendingSlaDomain": {
            "$ref": "#/components/schemas/ManagedObjectPendingSlaInfo"
          },
          "physicalLocation": {
            "description": "Brief info of all the objects in the physical path to this Object.",
            "items": {
              "$ref": "#/components/schemas/LocationPathPoint"
            },
            "type": "array"
          },
          "recoveryInfo": {
            "$ref": "#/components/schemas/SnappableRecoveryInfo"
          },
          "retentionSlaDomainId": {
            "description": "ID assigned to an SLA retention policy.",
            "type": "string"
          },
          "retentionSlaDomainName": {
            "description": "Name of an SLA retention policy.",
            "type": "string"
          },
          "retentionSlaDomainPolarisManagedId": {
            "description": "Optional field with the ID assigned to an SLA Domain by Polaris.",
            "type": "string"
          },
          "unmanagedStatus": {
            "description": "Unmanaged Status of this object. Protected means that this object is still protected by an SLA Policy. Unprotected means that this object has become unprotected. Relic means that Rubrik has lost contact with this object.",
            "enum": [
              "Protected",
              "Relic",
              "Unprotected",
              "ReplicatedRelic",
              "RemoteUnprotected"
            ],
            "type": "string"
          }
        },
        "required": [
          "archiveStorage",
          "autoSnapshotCount",
          "hasSnapshotsWithPolicy",
          "id",
          "localStorage",
          "manualSnapshotCount",
          "name",
          "objectType",
          "physicalLocation",
          "retentionSlaDomainId",
          "retentionSlaDomainName",
          "unmanagedStatus"
        ],
        "type": "object"
      },
      "UnmanagedObjectSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/UnmanagedObjectSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "UnmanagedObjectType": {
        "description": "Attributes that are available to use when filtering query results based on unmanaged object type.",
        "enum": [
          "VirtualMachine",
          "MssqlDatabase",
          "LinuxFileset",
          "WindowsFileset",
          "ShareFileset",
          "NutanixVirtualMachine",
          "HypervVirtualMachine",
          "ManagedVolume",
          "Ec2Instance",
          "StorageArrayVolumeGroup",
          "VcdVapp",
          "LinuxHost",
          "WindowsHost",
          "OracleDatabase",
          "VolumeGroup",
          "AppBlueprint"
        ],
        "type": "string"
      },
      "UnmanagedSnapshotType": {
        "description": "Attributes that are available to use when filtering query results based on snapshot type.\n",
        "enum": [
          "OnDemand",
          "PolicyBased",
          "Retrieved"
        ],
        "type": "string"
      },
      "UpdateMountConfig": {
        "properties": {
          "powerStatus": {
            "description": "True to power on, false to power off.",
            "type": "boolean"
          },
          "shouldForce": {
            "description": "A Boolean that specifies whether to forcibly power down a virtual machine that is already mounted with Storage vMotion. When this value is 'true', the virtual machine is forcibly powered down. The default value for this Boolean is 'false'.",
            "type": "boolean"
          }
        },
        "required": [
          "powerStatus"
        ],
        "type": "object"
      },
      "UserActionV1": {
        "description": "Type of an user action.",
        "enum": [
          "Assign",
          "Create",
          "Delete",
          "Update"
        ],
        "type": "string"
      },
      "VappAttributes": {
        "properties": {
          "isVappTemplate": {
            "description": "Indicates whether the vCD hierarchy object is a vApp template object.",
            "type": "boolean"
          }
        },
        "required": [
          "isVappTemplate"
        ],
        "type": "object"
      },
      "VappExportMode": {
        "description": "Target type for the specified vApp export.",
        "enum": [
          "ExportToNewVapp",
          "ExportToTargetVapp"
        ],
        "type": "string"
      },
      "VappExportOptions": {
        "properties": {
          "allChildVmsWithDefaultNetworkConnections": {
            "description": "Array containing summary information for the vApp virtual machines in the specified vApp snapshot, including the default network mappings.",
            "items": {
              "$ref": "#/components/schemas/VappVmRestoreSpec"
            },
            "type": "array"
          },
          "availableStoragePolicies": {
            "description": "Storage policies that can be used as a target for virtual machines being exported.",
            "items": {
              "$ref": "#/components/schemas/VcdOrgVdcStorageProfile"
            },
            "type": "array"
          },
          "restorableNetworks": {
            "description": "Array of vApp networks in the vApp snapshot being exported that can be enabled at the export location.",
            "items": {
              "$ref": "#/components/schemas/CreateVappNetworkParams"
            },
            "type": "array"
          },
          "targetVappNetworks": {
            "description": "Array of vApp networks at the export location that can be connected to the vApp virtual machines in the exported vApp snapshot.",
            "items": {
              "$ref": "#/components/schemas/VappNetworkSummary"
            },
            "type": "array"
          }
        },
        "required": [
          "allChildVmsWithDefaultNetworkConnections",
          "availableStoragePolicies",
          "restorableNetworks"
        ],
        "type": "object"
      },
      "VappExportSnapshotJobConfig": {
        "properties": {
          "exportMode": {
            "$ref": "#/components/schemas/VappExportMode"
          },
          "networksToRestore": {
            "description": "Array of vApp networks that are in the specified vApp snapshot and should be set up as part of the export operation. A vApp network that is not included in the array will not be set up in the exported vApp.",
            "items": {
              "$ref": "#/components/schemas/CreateVappNetworkParams"
            },
            "type": "array"
          },
          "newVappParams": {
            "$ref": "#/components/schemas/CreateNewVappParams"
          },
          "shouldPowerOnVappAfterExport": {
            "default": false,
            "description": "Boolean value that indicates whether to power on the exported vApp. Use 'true' to turn the power on for the exported vApp or use 'false' to leave the power off for the exported vApp.",
            "type": "boolean"
          },
          "targetVappId": {
            "description": "ID assigned to the target vApp object, when the export is into an existing vApp. When the export is not into a target vApp, remove the 'targetVappId' member.",
            "type": "string"
          },
          "vmsToExport": {
            "description": "An array containing summary information for the virtual machines included in the vApp export.",
            "items": {
              "$ref": "#/components/schemas/VappVmRestoreSpec"
            },
            "type": "array"
          }
        },
        "required": [
          "exportMode",
          "networksToRestore",
          "vmsToExport"
        ],
        "type": "object"
      },
      "VappInstantRecoveryJobConfig": {
        "properties": {
          "shouldPowerOnVmsAfterRecovery": {
            "default": false,
            "description": "Boolean value that indicates whether to power on the recovered virtual machines in a vApp after Instant Recovery. Use 'true' to turn the power on for the recovered virtual machines or use 'false' to leave the power off for the virtual machines.",
            "type": "boolean"
          },
          "vmsToRestore": {
            "description": "An array containing the restore specification for an Instant Recovery of virtual machines in a vApp snapshot.",
            "items": {
              "$ref": "#/components/schemas/VappVmRestoreSpec"
            },
            "type": "array"
          }
        },
        "required": [
          "vmsToRestore"
        ],
        "type": "object"
      },
      "VappInstantRecoveryOptions": {
        "properties": {
          "availableVappNetworks": {
            "description": "An array of network connections available through the specified vApp object.",
            "items": {
              "$ref": "#/components/schemas/VappNetworkSummary"
            },
            "type": "array"
          },
          "restorableVms": {
            "description": "An array of virtual machines that can be restored and their associated default network connections.",
            "items": {
              "$ref": "#/components/schemas/VappVmRestoreSpec"
            },
            "type": "array"
          }
        },
        "required": [
          "availableVappNetworks",
          "restorableVms"
        ],
        "type": "object"
      },
      "VappNetworkMode": {
        "description": "Mode of connection of a vApp network to a vCloud organization VDC network.",
        "enum": [
          "Isolated",
          "NATRouted",
          "Bridged"
        ],
        "type": "string"
      },
      "VappNetworkSummary": {
        "properties": {
          "isDeployed": {
            "description": "Boolean value that indicates whether the specified vApp network object has been deployed. Value is 'true' when the vApp network object has been deployed and 'false' when it has not been deployed.",
            "type": "boolean"
          },
          "name": {
            "description": "Name of the specified vApp network object.",
            "type": "string"
          },
          "parentNetworkId": {
            "description": "vCloud Director ID of the associated organization VDC network object. For an Isolated network, the value is empty.",
            "type": "string"
          }
        },
        "required": [
          "isDeployed",
          "name"
        ],
        "type": "object"
      },
      "VappTemplateExportJobConfig": {
        "properties": {
          "catalogId": {
            "description": "ID of the target catalog.",
            "type": "string"
          },
          "name": {
            "description": "Name of vApp template.",
            "type": "string"
          },
          "orgVdcId": {
            "description": "ID of the target organization vDC.",
            "type": "string"
          },
          "storagePolicyId": {
            "description": "ID of the storage policy of the organization VDC used to create the template. When this field is absent, the default from the organization vDC is used.",
            "type": "string"
          }
        },
        "required": [
          "catalogId",
          "name",
          "orgVdcId"
        ],
        "type": "object"
      },
      "VappTemplateExportOptions": {
        "properties": {
          "availableStoragePolicies": {
            "description": "An array of the available storage profile policies where the vApp snapshot can be exported.",
            "items": {
              "$ref": "#/components/schemas/VcdOrgVdcStorageProfile"
            },
            "type": "array"
          },
          "orgVdcId": {
            "description": "The ID of the organization vDC where the vApp template can be exported.",
            "type": "string"
          }
        },
        "required": [
          "availableStoragePolicies",
          "orgVdcId"
        ],
        "type": "object"
      },
      "VappTemplateExportOptionsUnion": {
        "description": "Provides different options available for a vApp template snapshot export. Fields that correspond to unavailable choices are skipped.",
        "properties": {
          "advancedExportOptions": {
            "$ref": "#/components/schemas/VappTemplateExportOptions"
          },
          "defaultCatalogExportOptions": {
            "$ref": "#/components/schemas/VappTemplateExportOptions"
          },
          "originalVdcExportOptions": {
            "$ref": "#/components/schemas/VappTemplateExportOptions"
          }
        },
        "type": "object"
      },
      "VappVmDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/VappVmSummary"
          },
          {
            "properties": {
              "vcenterVm": {
                "$ref": "#/components/schemas/VirtualMachineDetail"
              }
            },
            "type": "object"
          }
        ]
      },
      "VappVmIpAddressingMode": {
        "description": "Method used to allocate IP addresses for the specified vApp network.",
        "enum": [
          "DHCP",
          "Manual",
          "Pool",
          "None"
        ],
        "type": "string"
      },
      "VappVmNetworkConnection": {
        "properties": {
          "addressingMode": {
            "$ref": "#/components/schemas/VappVmIpAddressingMode"
          },
          "ipAddress": {
            "description": "IPv4 address to assign to the specified vApp network connection. Set this value only when the network address allocation method is 'Static'. Otherwise, the value should be empty.",
            "type": "string"
          },
          "isConnected": {
            "description": "Boolean value that indicates whether the specified vApp network connection is enabled. Set the value to 'true' to enable the connection or 'false' to disable the connection.",
            "type": "boolean"
          },
          "macAddress": {
            "description": "MAC address of the NIC that is used by the specified vApp network connection.",
            "type": "string"
          },
          "networkAdapterType": {
            "description": "The network adapter type of the NIC.",
            "type": "string"
          },
          "nicIndex": {
            "description": "Index assigned to the NIC that is used by the specified vApp network connection.",
            "format": "int32",
            "type": "integer"
          },
          "vappNetworkName": {
            "description": "Name of the vApp network to which the NIC corresponding to this connection will connect to.",
            "type": "string"
          }
        },
        "required": [
          "addressingMode",
          "isConnected",
          "nicIndex"
        ],
        "type": "object"
      },
      "VappVmRestoreSpec": {
        "properties": {
          "name": {
            "description": "Name of the specified vApp virtual machine within vCloud.",
            "type": "string"
          },
          "networkConnections": {
            "items": {
              "$ref": "#/components/schemas/VappVmNetworkConnection"
            },
            "type": "array"
          },
          "storagePolicyId": {
            "description": "Storage policy where this vApp virtual machine should be restored to. If omitted, the virtual machines will be exported to the default storage policy of the target Organization VDC.",
            "type": "string"
          },
          "vcdMoid": {
            "description": "vCloud managed object ID (moid) of the specified vApp virtual machine.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "networkConnections",
          "vcdMoid"
        ],
        "type": "object"
      },
      "VappVmSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/VappVmRestoreSpec"
          },
          {
            "properties": {
              "storagePolicyId": {
                "description": "Storage policy where this vApp virtual machine should be restored to. If omitted, the virtual machines will be exported to the default storage policy of the target Organization VDC.",
                "type": "string"
              }
            },
            "required": [
              "storagePolicyId"
            ],
            "type": "object"
          }
        ]
      },
      "VcdClusterBaseConfig": {
        "properties": {
          "caCerts": {
            "description": "Concatenated X.509 certificates in Base64 encoded DER format. Each certificate must start with -----BEGIN CERTIFICATE----- and end with -----END CERTIFICATE-----.",
            "type": "string"
          },
          "hostname": {
            "type": "string"
          },
          "username": {
            "type": "string"
          }
        },
        "required": [
          "hostname",
          "username"
        ],
        "type": "object"
      },
      "VcdClusterConfig": {
        "allOf": [
          {
            "$ref": "#/components/schemas/VcdClusterBaseConfig"
          },
          {
            "properties": {
              "password": {
                "type": "string",
                "x-secret": true
              }
            },
            "required": [
              "password"
            ],
            "type": "object"
          }
        ]
      },
      "VcdClusterDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/VcdClusterSummary"
          }
        ]
      },
      "VcdClusterListSortAttribute": {
        "description": "Attributes that are available to use when sorting query results for vCD Cluster objects.",
        "enum": [
          "Name",
          "Status"
        ],
        "type": "string"
      },
      "VcdClusterPatch": {
        "properties": {
          "caCerts": {
            "description": "Concatenated X.509 certificates in Base64 encoded DER format. Each certificate must start with -----BEGIN CERTIFICATE----- and end with -----END CERTIFICATE-----.",
            "type": "string"
          },
          "configuredSlaDomainId": {
            "description": "Assign this Vcd Cluster to the given SLA Domain. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.",
            "type": "string"
          },
          "hostname": {
            "type": "string"
          },
          "password": {
            "type": "string",
            "x-secret": true
          },
          "username": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "VcdClusterSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SlaAssignable"
          },
          {
            "$ref": "#/components/schemas/VcdClusterBaseConfig"
          },
          {
            "properties": {
              "connectionStatus": {
                "$ref": "#/components/schemas/VcdConnectionStatus"
              },
              "id": {
                "description": "ID assigned to a vCD Cluster object.",
                "type": "string"
              }
            },
            "required": [
              "id"
            ],
            "type": "object"
          }
        ]
      },
      "VcdClusterSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/VcdClusterSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "VcdConnectionStatus": {
        "properties": {
          "message": {
            "description": "Status details for a specified vCD Cluster object. Empty except when the status of the vCD Cluster object is 'BadlyConfigured'.",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/RefreshableObjectConnectionStatusType"
          }
        },
        "required": [
          "status"
        ],
        "type": "object"
      },
      "VcdHierarchyObjectAttributes": {
        "description": "attributes pertaining to each vCD hierarchy object.",
        "properties": {
          "vappAtributes": {
            "$ref": "#/components/schemas/VappAttributes"
          }
        },
        "type": "object"
      },
      "VcdHierarchyObjectDescendantCount": {
        "properties": {
          "catalog": {
            "description": "Number of descendant vCD catalog objects in a specified; hierarchy.",
            "format": "int32",
            "type": "integer"
          },
          "connectedVimServer": {
            "description": "Number of descendant VIM Server objects that are linked to a vCenter Server object.",
            "format": "int32",
            "type": "integer"
          },
          "disconnectedVimServer": {
            "description": "Number of descendant VIM Server objects that are not linked to a vCenter Server object.",
            "format": "int32",
            "type": "integer"
          },
          "org": {
            "description": "Number of descendant Organization objects in a specified hierarchy.",
            "format": "int32",
            "type": "integer"
          },
          "orgVdc": {
            "description": "Number of descendant virtual data center objects in a specified hierarchy.",
            "format": "int32",
            "type": "integer"
          },
          "vApp": {
            "description": "Number of descendant vApp objects in a specified hierarchy.",
            "format": "int32",
            "type": "integer"
          },
          "vcdCluster": {
            "description": "Number of descendant vCD cluster objects in a specified hierarchy.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "VcdHierarchyObjectSortAttribute": {
        "description": "Attributes that are available to use when sorting query results for vCD hierarchy objects.",
        "enum": [
          "Name",
          "EffectiveSlaDomainName",
          "SlaAssignment",
          "ConnectionStatus",
          "VappCount"
        ],
        "type": "string"
      },
      "VcdHierarchyObjectSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ManagedHierarchyObjectSummary"
          },
          {
            "properties": {
              "connectionStatus": {
                "$ref": "#/components/schemas/VcdConnectionStatus"
              },
              "descendantCount": {
                "$ref": "#/components/schemas/VcdHierarchyObjectDescendantCount"
              },
              "extendedAttributes": {
                "$ref": "#/components/schemas/VcdHierarchyObjectAttributes"
              },
              "ipAddress": {
                "description": "IPv4 address for a vCD cluster or vCenter Server that is managed through a VIM Server.",
                "type": "string"
              },
              "isDeleted": {
                "description": "Indicates whether the vCD hierarchy object is deleted.",
                "type": "boolean"
              },
              "objectType": {
                "$ref": "#/components/schemas/VcdObjectType"
              },
              "pendingSlaDomain": {
                "$ref": "#/components/schemas/ManagedObjectPendingSlaInfo"
              },
              "vcenterId": {
                "description": "ID assigned to a vCenter Server instance that is managed through a VIM Server.",
                "type": "string"
              }
            },
            "required": [
              "descendantCount",
              "isDeleted",
              "objectType"
            ],
            "type": "object"
          }
        ]
      },
      "VcdHierarchyObjectSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/VcdHierarchyObjectSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "VcdObjectType": {
        "description": "Types of object that can be present in the vCD hierarchy.",
        "enum": [
          "Cluster",
          "VimServer",
          "Org",
          "OrgVdc",
          "Catalog",
          "vApp"
        ],
        "type": "string"
      },
      "VcdOrgVdcStorageProfile": {
        "properties": {
          "id": {
            "description": "ID assigned to the Organization VDC storage profile.",
            "type": "string"
          },
          "name": {
            "description": "Name of the Organization VDC storage profile.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "name"
        ],
        "type": "object"
      },
      "VcdVappDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/VcdVappPatch"
          },
          {
            "$ref": "#/components/schemas/VcdVappSummary"
          },
          {
            "properties": {
              "isPaused": {
                "description": "Boolean value that indicates whether protection activity is paused for the specified vApp. Set to 'true' when protection activity is paused and 'false' when protection activity is not paused. Protection activity includes backup, replication, and archiving.",
                "type": "boolean"
              },
              "networks": {
                "description": "Array that lists the vApp network objects that exist in the specified vApp object.",
                "items": {
                  "$ref": "#/components/schemas/VappNetworkSummary"
                },
                "type": "array"
              },
              "vms": {
                "description": "Array containing detailed information for all of the vApp virtual machine objects.",
                "items": {
                  "$ref": "#/components/schemas/VappVmDetail"
                },
                "type": "array"
              }
            },
            "required": [
              "isPaused",
              "networks",
              "vms"
            ],
            "type": "object"
          }
        ]
      },
      "VcdVappObjectSortAttribute": {
        "description": "Attributes that are available to use when sorting query results for vApp objects.",
        "enum": [
          "Name",
          "EffectiveSlaDomainName",
          "SlaAssignment"
        ],
        "type": "string"
      },
      "VcdVappPatch": {
        "properties": {
          "configuredSlaDomainId": {
            "description": "ID assigned to the SLA Domain object that manages protection for the specified vApp object. Existing snapshots of the object will be retained with the configuration of the specified SLA Domain.",
            "type": "string"
          },
          "isBestEffortSynchronizationEnabled": {
            "description": "Boolean value that indicates whether the Rubrik cluster should attempt taking synchronized snapshots across all child virtual machines of the vApp.",
            "type": "boolean"
          },
          "isPaused": {
            "description": "Boolean value that indicates whether protection activity is paused for the specified vApp. Set to 'true' when protection activity is paused and 'false' when protection activity is not paused. Protection activity includes backup, replication, and archiving.",
            "type": "boolean"
          },
          "vcdVmMoidsToExcludeFromSnapshot": {
            "description": "Array containing vCloud Director virtual machine moids that will be excluded from vApp snapshots.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "VcdVappSlaObjectCount": {
        "properties": {
          "numVcdVapps": {
            "description": "The number of vApps protected under this SLA Domain.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "VcdVappSnapshotDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseSnapshotSummary"
          },
          {
            "$ref": "#/components/schemas/VcdVappSnapshotSummaryDetailSharedFields"
          },
          {
            "properties": {
              "excludedVcdVmMoids": {
                "description": "Array that lists the Virtual Machines of the vApp that where excluded from the snapshot.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "networks": {
                "description": "Array that lists the vApp networks in the vApp at the time of the snapshot.",
                "items": {
                  "$ref": "#/components/schemas/VappNetworkSummary"
                },
                "type": "array"
              },
              "vmSnapshots": {
                "items": {
                  "$ref": "#/components/schemas/VcdVmSnapshotDetail"
                },
                "type": "array"
              }
            },
            "required": [
              "networks",
              "vmSnapshots"
            ],
            "type": "object"
          }
        ]
      },
      "VcdVappSnapshotSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseSnapshotSummary"
          },
          {
            "$ref": "#/components/schemas/VcdVappSnapshotSummaryDetailSharedFields"
          },
          {
            "properties": {
              "vmSnapshots": {
                "items": {
                  "$ref": "#/components/schemas/VcdVmSnapshotSummary"
                },
                "type": "array"
              }
            },
            "required": [
              "vmSnapshots"
            ],
            "type": "object"
          }
        ]
      },
      "VcdVappSnapshotSummaryDetailSharedFields": {
        "properties": {
          "isSynchronized": {
            "description": "Boolean value that indicates whether a vApp snapshot is synchronized with the source vApp. Set to 'true' when the vApp snapshot is synchronized, and set to 'false' when it is not synchronized.",
            "type": "boolean"
          },
          "vappName": {
            "description": "ID assigned to the vApp object that is the source of the specified snapshot object.",
            "type": "string"
          }
        },
        "required": [
          "vappName"
        ],
        "type": "object"
      },
      "VcdVappSnapshotSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/VcdVappSnapshotSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "VcdVappSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Snappable"
          },
          {
            "properties": {
              "catalogId": {
                "description": "ID of the parent catalog if the vApp object is a template.",
                "type": "string"
              },
              "currentBackupTaskInfo": {
                "$ref": "#/components/schemas/BackupTaskDiagnosticInfo"
              },
              "id": {
                "description": "ID assigned to a vCD vApp object.",
                "type": "string"
              },
              "includeBackupTaskInfo": {
                "description": "Boolean value that indicates if backup task information isincluded in the response.",
                "type": "boolean"
              },
              "infraPath": {
                "description": "Brief information of all the objects in the infrastructure path to this vCD vApp object.",
                "items": {
                  "$ref": "#/components/schemas/ManagedHierarchyObjectAncestor"
                },
                "type": "array"
              },
              "isRelic": {
                "description": "Boolean value that indicates whether a vApp is present on the specified vCD cluster. Set to 'true' when the vApp is present and 'false' when the vApp is not present.",
                "type": "boolean"
              },
              "isTemplate": {
                "description": "A Boolean value that indicates whether the vApp object is a template. When this value is 'true,' the vApp object is a template. When this value is 'false,' the vApp object is not a template.",
                "type": "boolean"
              },
              "lastSnapshotTime": {
                "description": "The timestamp of the previous snapshot.",
                "format": "date-time",
                "type": "string"
              },
              "name": {
                "description": "Name assigned to a vCD vApp object.",
                "type": "string"
              },
              "numMissedSnapshot": {
                "description": "An integer that specifies the number of missed snapshots.",
                "format": "int32",
                "type": "integer"
              },
              "pendingSlaDomain": {
                "$ref": "#/components/schemas/ManagedObjectPendingSlaInfo"
              },
              "vcdClusterId": {
                "description": "ID assigned to a vCD Cluster object that contains a specified vApp object.",
                "type": "string"
              },
              "vcdClusterName": {
                "description": "Name assigned to a vCD Cluster object that contains a specified vApp object.",
                "type": "string"
              }
            },
            "required": [
              "id",
              "infraPath",
              "name",
              "numMissedSnapshot"
            ],
            "type": "object"
          }
        ]
      },
      "VcdVappSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/VcdVappSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "VcdVmSnapshotDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/VcdVmSnapshotSummary"
          },
          {
            "properties": {
              "networkConnections": {
                "description": "Array of networks present in the virtual machine at the time of the snapshot.",
                "items": {
                  "$ref": "#/components/schemas/VappVmNetworkConnection"
                },
                "type": "array"
              }
            },
            "required": [
              "networkConnections"
            ],
            "type": "object"
          }
        ]
      },
      "VcdVmSnapshotSummary": {
        "properties": {
          "indexState": {
            "description": "Integer value representing the state of the indexing job for a snapshot. 0 means that the indexing has not begun or is in progress. 1 means indexing completed successfully. 2 means that the indexer failed to process this snapshot.\n",
            "format": "int64",
            "type": "integer"
          },
          "vcdVmMoid": {
            "description": "Id assigned by vCloud Director to the virtual machine of the specified snapshot.",
            "type": "string"
          },
          "vcenterVmId": {
            "description": "ID assigned to the object that represents the virtual machine that is the source of a specified snapshot object.",
            "type": "string"
          },
          "vmName": {
            "description": "Name of the virtual machine object of the snapshot.",
            "type": "string"
          },
          "vmSnapshotId": {
            "description": "ID assigned to the object that represents a virtual machine snapshot.",
            "type": "string"
          }
        },
        "required": [
          "vcdVmMoid",
          "vcenterVmId",
          "vmName",
          "vmSnapshotId"
        ],
        "type": "object"
      },
      "VcenterConfig": {
        "properties": {
          "caCerts": {
            "description": "Concatenated X.509 certificates in Base64 encoded DER format. Each certificate must start with -----BEGIN CERTIFICATE----- and end with -----END CERTIFICATE-----.",
            "type": "string"
          },
          "computeVisibilityFilter": {
            "description": "Select compute clusters that must be visible to this Rubrik cluster. All other compute resources are hidden. If 'computeVisibilityFilter' is not specified, all resources are visible. If 'hostGroupFilter' is not specified for a compute cluster, all compute resources in the compute cluster are visible. If 'hostGroupFilter' is specified for a compute cluster, only virtual machinesthat currently reside on these hosts are visible. For the stretched cluster configuration (vMSC), specify the appropriate host groups.",
            "items": {
              "$ref": "#/components/schemas/ClusterVisibilityConfig"
            },
            "type": "array"
          },
          "conflictResolutionAuthz": {
            "description": "Set to 'AllowAutoConflictResolution' to link the relic virtual machine objects of a virtual machine to the current object for the virtual machine or to 'NoConflictResolution' to prevent linking. The Rubrik cluster generates a unique ID for each virtual machine when a vCenter Server is added. When a virtual machine changes to another vCenter Server or unregisters and registers with the same vCenter Server, a new unique ID is generated for that virtual machine. When this happens, the virtual machine object associated with the original ID becomes a relic. This option links relic virtual machine objects with the current virtual machine object of a specific virtual machine, and makes the collective snapshot history available through the current object. Default value is 'NoConflictResolution'.",
            "enum": [
              "AllowAutoConflictResolution",
              "NoConflictResolution"
            ],
            "type": "string"
          },
          "hostname": {
            "type": "string"
          },
          "password": {
            "type": "string",
            "x-secret": true
          },
          "username": {
            "type": "string"
          }
        },
        "required": [
          "hostname",
          "password",
          "username"
        ],
        "type": "object"
      },
      "VcenterConnectionConfig": {
        "properties": {
          "caCerts": {
            "description": "Concatenated X.509 certificates in Base64 encoded DER format. Each certificate must start with -----BEGIN CERTIFICATE----- and end with -----END CERTIFICATE-----.",
            "type": "string"
          },
          "hostname": {
            "description": "Hostname of the new vCenter.",
            "type": "string"
          },
          "password": {
            "description": "Password for the new vCenter.",
            "type": "string",
            "x-secret": true
          },
          "username": {
            "description": "Username of the new vCenter.",
            "type": "string"
          }
        },
        "required": [
          "hostname",
          "password",
          "username"
        ],
        "type": "object"
      },
      "VcenterDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/VcenterSummary"
          },
          {
            "properties": {
              "status": {
                "description": "Status of a vCenter. DEPRECATED. Please use connectionStatus.",
                "type": "string"
              }
            },
            "required": [
              "status"
            ],
            "type": "object"
          }
        ]
      },
      "VcenterPatch": {
        "properties": {
          "caCerts": {
            "description": "Concatenated X.509 certificates in Base64 encoded DER format. Each certificate must start with -----BEGIN CERTIFICATE----- and end with -----END CERTIFICATE-----. Use an empty string to remove the existing certificates for the vCenter.",
            "type": "string"
          },
          "configuredSlaDomainId": {
            "description": "ID of the SLA Domain that is configured for this vCenter Server.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "VcenterPreAddConfig": {
        "properties": {
          "connectionConfig": {
            "$ref": "#/components/schemas/VcenterConnectionConfig"
          },
          "id": {
            "description": "Id of the vCenter. Specify this if the vCenter is already added to the Rubrik cluster.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "VcenterPreAddInfo": {
        "properties": {
          "clusterHostGroupInfo": {
            "description": "List of compute clusters present in the vCenter, including the host groups each cluster contains.",
            "items": {
              "$ref": "#/components/schemas/ClusterHostGroupInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "clusterHostGroupInfo"
        ],
        "type": "object"
      },
      "VcenterSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/VcenterPatch"
          },
          {
            "$ref": "#/components/schemas/SlaAssignable"
          },
          {
            "properties": {
              "computeVisibilityFilter": {
                "description": "Compute clusters that are visible to this Rubrik Cluster. All other compute resources are hidden. If 'computeVisibilityFilter' is not specified, all resources are visible. If 'hostGroupFilter' is not specified for a compute cluster, all compute resources in the compute cluster are visible. If a 'hostGroupFilter' is specified for a compute cluster, only vms that currently reside on these hosts are visible.",
                "items": {
                  "$ref": "#/components/schemas/ClusterVisibilityInfo"
                },
                "type": "array"
              },
              "configuredSlaDomainPolarisManagedId": {
                "description": "Optional field containing Polaris managed id of the configured SLA domain if it is Polaris managed.",
                "type": "string"
              },
              "conflictResolutionAuthz": {
                "description": "Set to 'AllowAutoConflictResolution' to link the relic virtual machine objects of a virtual machine to the current object for the virtual machine or to 'NoConflictResolution' to prevent linking. The Rubrik cluster generates a unique ID for each virtual machine when a vCenter Server is added. When a virtual machine changes to another vCenter Server or unregisters and registers with the same vCenter Server, a new unique ID is generated for that virtual machine. When this happens, the virtual machine object associated with the original ID becomes a relic. This option links relic virtual machine objects with the current virtual machine object of a specific virtual machine, and makes the collective snapshot history available through the current object. Default value is 'NoConflictResolution'.",
                "enum": [
                  "AllowAutoConflictResolution",
                  "NoConflictResolution"
                ],
                "type": "string"
              },
              "connectionStatus": {
                "$ref": "#/components/schemas/RefreshableObjectConnectionStatus"
              },
              "hostname": {
                "type": "string"
              },
              "isIoFilterInstalled": {
                "description": "A Boolean value that specifies whether Rubrik IO filters are installed on any compute clusters in the vCenter. When this value is 'true,' Rubrik IO filters are present on at least one compute cluster in the vCenter. When this value is 'false,' no Rubrik IO filters are present on any compute clusters in the vCenter.",
                "type": "boolean"
              },
              "isVmc": {
                "description": "Indicates if the vCenter is a VMC instance.",
                "type": "boolean"
              },
              "lastRefreshTime": {
                "description": "Optional field containing the last time that a vcenter was refreshed (either lite or full).",
                "format": "date-time",
                "type": "string"
              },
              "username": {
                "type": "string"
              },
              "version": {
                "description": "Version of vCenter.",
                "type": "string"
              }
            },
            "required": [
              "computeVisibilityFilter",
              "connectionStatus",
              "hostname",
              "username",
              "version"
            ],
            "type": "object"
          }
        ]
      },
      "VcenterSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/VcenterSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "VerificationParameters": {
        "properties": {
          "locationIdOpt": {
            "description": "Snapshot stored in the provided data location id will be verified. If not provided, we will use Rubrik cluster ID. Currently it only verifies Snapshot present Rubrik cluster.\n",
            "type": "string"
          },
          "objectId": {
            "description": "ID assigned to the object. This objectId will be used to fetch the associated object.\n",
            "type": "string"
          },
          "shouldVerifyAfterOpt": {
            "description": "The backup should be verified exactly once after the given timestamp. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\". If not provided, it will default to \"1970-01-01T00:00:00.000\".\n",
            "format": "date-time",
            "type": "string"
          },
          "snapshotIdsOpt": {
            "description": "ID assigned to a snapshot. This snapshotId will be used to fetch the associated snapshot. The scheduled job will verify this snapshot.\n",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "objectId"
        ],
        "type": "object"
      },
      "VerificationResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/AsyncRequestStatus"
          },
          {
            "properties": {
              "snapshotVerificationInfo": {
                "description": "List of IDs of the snapshots requested for verification and their corresponding event series IDs.\n",
                "items": {
                  "$ref": "#/components/schemas/SnapshotEventSeries"
                },
                "type": "array"
              }
            },
            "required": [
              "snapshotVerificationInfo"
            ],
            "type": "object"
          }
        ]
      },
      "VimserverSummary": {
        "properties": {
          "connectionStatus": {
            "$ref": "#/components/schemas/VcdConnectionStatus"
          },
          "hostname": {
            "description": "Hostname of a vCenter Server that is the target of a connection from a specified VimServer object.",
            "type": "string"
          },
          "id": {
            "description": "ID assigned to a VimServer object.",
            "type": "string"
          },
          "name": {
            "description": "Name of a VimServer object.",
            "type": "string"
          },
          "vcdClusterId": {
            "description": "ID assigned to a vCD Cluster object that contains a specified VimServer object.",
            "type": "string"
          },
          "vcdClusterName": {
            "description": "Name of a vCD Cluster object that contains a specified VimServer object.",
            "type": "string"
          },
          "vcenterId": {
            "description": "ID assigned to a vCenter Server object that is attached to a specified VimServer object.",
            "type": "string"
          }
        },
        "required": [
          "connectionStatus",
          "hostname",
          "id",
          "name",
          "vcdClusterId",
          "vcdClusterName"
        ],
        "type": "object"
      },
      "VimserverSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/VimserverSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "VirtualDiskDetail": {
        "properties": {
          "deviceKey": {
            "description": "Unique and reusable key that vSphere uses to identify VMDK files and other devices in the hardware of a virtual machine.",
            "format": "int64",
            "type": "integer"
          },
          "excludeFromSnapshots": {
            "type": "boolean"
          },
          "fileName": {
            "type": "string"
          },
          "id": {
            "type": "string"
          },
          "size": {
            "format": "int64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "VirtualDiskUpdate": {
        "properties": {
          "excludeFromSnapshots": {
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "VirtualMachineDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/VirtualMachineUpdate"
          },
          {
            "$ref": "#/components/schemas/VirtualMachineSummary"
          },
          {
            "$ref": "#/components/schemas/BlackoutWindowResponseInfo"
          },
          {
            "properties": {
              "cdpState": {
                "$ref": "#/components/schemas/CdpState"
              },
              "currentHost": {
                "$ref": "#/components/schemas/VmwareHostSummary"
              },
              "effectiveSlaDomain": {
                "$ref": "#/components/schemas/SlaDomainSummary"
              },
              "guestCredential": {
                "$ref": "#/components/schemas/BaseGuestCredentialDetail"
              },
              "guestOsName": {
                "description": "Long form name, including type and release designation, for the operating system that is installed on a virtual machine.",
                "type": "string"
              },
              "guestOsType": {
                "description": "Type of operating system used by the VMware virtual machine.",
                "enum": [
                  "Linux",
                  "Windows",
                  "Unknown"
                ],
                "type": "string"
              },
              "isAgentRegistered": {
                "description": "Boolean value that indicates whether the Rubrik Backup Service is installed and registered for the specified virtual machine. Set to 'true' when the Rubrik Backup Service is installed and registered and in all other cases set to 'false'.",
                "type": "boolean"
              },
              "isArrayIntegrationEnabled": {
                "description": "Boolean value that determines whether the available storage array integration is used with the specified virtual machine. Set to 'true' to use storage array integration and set to 'false' to not use storage array integration. Refer to the value of 'isArrayIntegrationPossible' to determine whether storage array integration is available for a virtual machine.",
                "type": "boolean"
              },
              "isArrayIntegrationPossible": {
                "description": "Boolean value that indicates whether the performance enhancements of storage array integration are available for the specified virtual machine object. Storage array integration is available when all of the datastores that are assigned to the virtual machine reside on a qualified storage array. Set to 'true' when storage array integration is available and set to 'false' when storage array integration is not available.",
                "type": "boolean"
              },
              "isCdpEnabled": {
                "type": "boolean"
              },
              "isInVmc": {
                "description": "A Boolean that specifies whether the virtual machine is in a VMC environment.",
                "type": "boolean"
              },
              "latestRecoveryPoint": {
                "description": "Latest point in time that we can recover to if this is a CDP enabled VM.",
                "format": "date-time",
                "type": "string"
              },
              "logicalSize": {
                "description": "This returns the sum of all virtual disk sizes in the specified virtual machine.",
                "format": "int64",
                "type": "integer"
              },
              "maxNestedVsphereSnapshots": {
                "format": "int32",
                "type": "integer"
              },
              "oldestRecoveryPoint": {
                "description": "Oldest point in time that we can recover to if this is a CDP enabled VM.",
                "format": "date-time",
                "type": "string"
              },
              "pendingSlaDomain": {
                "$ref": "#/components/schemas/ManagedObjectPendingSlaInfo"
              },
              "physicalStorage": {
                "format": "int64",
                "type": "integer"
              },
              "snapshotCount": {
                "format": "int32",
                "type": "integer"
              },
              "snapshots": {
                "items": {
                  "$ref": "#/components/schemas/VmSnapshotSummary"
                },
                "type": "array"
              },
              "vcenterName": {
                "description": "The name of vCenter that the virtual machine belongs to.",
                "type": "string"
              },
              "virtualDiskIds": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            },
            "required": [
              "cdpState",
              "effectiveSlaDomain",
              "guestOsType",
              "isArrayIntegrationEnabled",
              "isArrayIntegrationPossible",
              "isCdpEnabled",
              "isInVmc",
              "maxNestedVsphereSnapshots",
              "physicalStorage",
              "vcenterName"
            ],
            "type": "object"
          }
        ]
      },
      "VirtualMachineScriptDetail": {
        "properties": {
          "failureHandling": {
            "description": "Action to take if the script returns an error or times out.",
            "enum": [
              "abort",
              "continue"
            ],
            "type": "string"
          },
          "scriptPath": {
            "description": "The command to be run in VM guest OS.",
            "type": "string"
          },
          "timeoutMs": {
            "description": "Time (in ms) after which the script will be terminated if it has not completed.",
            "format": "int64",
            "type": "integer"
          }
        },
        "required": [
          "failureHandling",
          "scriptPath",
          "timeoutMs"
        ],
        "type": "object"
      },
      "VirtualMachineSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Snappable"
          },
          {
            "properties": {
              "agentStatus": {
                "$ref": "#/components/schemas/AgentStatus"
              },
              "cloudInstantiationSpec": {
                "$ref": "#/components/schemas/CloudInstantiationSpec"
              },
              "clusterName": {
                "type": "string"
              },
              "folderPath": {
                "description": "Brief info of all the objects in the folder path to this VM.",
                "items": {
                  "$ref": "#/components/schemas/VmPathPoint"
                },
                "type": "array"
              },
              "guestCredentialAuthorizationStatus": {
                "description": "Status of authentication with a specific virtual machine using guest credentials. Possible values are: SUCCESSFUL, PENDING, or FAILED.",
                "type": "string"
              },
              "guestOsName": {
                "type": "string"
              },
              "hostId": {
                "type": "string"
              },
              "hostName": {
                "type": "string"
              },
              "infraPath": {
                "description": "Brief info of all the objects in the infrastructure path to this VM.",
                "items": {
                  "$ref": "#/components/schemas/VmPathPoint"
                },
                "type": "array"
              },
              "ipAddress": {
                "type": "string"
              },
              "isRelic": {
                "type": "boolean"
              },
              "isReplicationEnabled": {
                "type": "boolean"
              },
              "moid": {
                "type": "string"
              },
              "parentAppInfo": {
                "$ref": "#/components/schemas/ParentAppInfo"
              },
              "powerStatus": {
                "description": "The power status of VM(ON,OFF,SLEEP etc.).",
                "type": "string"
              },
              "protectionDate": {
                "format": "date-time",
                "type": "string"
              },
              "snapshotConsistencyMandate": {
                "description": "Consistency level mandated for this VM or empty string for none.",
                "enum": [
                  "UNKNOWN",
                  "INCONSISTENT",
                  "CRASH_CONSISTENT",
                  "FILE_SYSTEM_CONSISTENT",
                  "VSS_CONSISTENT",
                  "APP_CONSISTENT"
                ],
                "type": "string"
              },
              "toolsInstalled": {
                "type": "boolean"
              },
              "vcenterId": {
                "type": "string"
              },
              "vmwareToolsInstalled": {
                "type": "boolean"
              }
            },
            "required": [
              "folderPath",
              "guestCredentialAuthorizationStatus",
              "infraPath",
              "ipAddress",
              "isRelic",
              "isReplicationEnabled",
              "moid",
              "snapshotConsistencyMandate",
              "vmwareToolsInstalled"
            ],
            "type": "object"
          }
        ]
      },
      "VirtualMachineSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/VirtualMachineSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "VirtualMachineUpdate": {
        "properties": {
          "cloudInstantiationSpec": {
            "$ref": "#/components/schemas/CloudInstantiationSpec"
          },
          "configuredSlaDomainId": {
            "description": "Assign this VM to the given SLA domain. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.",
            "type": "string"
          },
          "isArrayIntegrationEnabled": {
            "description": "User setting to dictate whether to use storage array snaphots for ingest. This setting only makes sense for VMs where array based ingest is possible.",
            "type": "boolean"
          },
          "isVmPaused": {
            "description": "Whether to pause or resume backups/archival for this VM.",
            "type": "boolean"
          },
          "maxNestedVsphereSnapshots": {
            "format": "int32",
            "type": "integer"
          },
          "postBackupScript": {
            "$ref": "#/components/schemas/VirtualMachineScriptDetail"
          },
          "postSnapScript": {
            "$ref": "#/components/schemas/VirtualMachineScriptDetail"
          },
          "preBackupScript": {
            "$ref": "#/components/schemas/VirtualMachineScriptDetail"
          },
          "snapshotConsistencyMandate": {
            "description": "Consistency level mandated for this VM or empty string for none.",
            "enum": [
              "UNKNOWN",
              "INCONSISTENT",
              "CRASH_CONSISTENT",
              "FILE_SYSTEM_CONSISTENT",
              "VSS_CONSISTENT",
              "APP_CONSISTENT"
            ],
            "type": "string"
          },
          "throttlingSettings": {
            "$ref": "#/components/schemas/VmwareAdaptiveThrottlingSettings"
          }
        },
        "type": "object"
      },
      "VirtualMachineUpdateWithSecret": {
        "allOf": [
          {
            "$ref": "#/components/schemas/VirtualMachineUpdate"
          },
          {
            "properties": {
              "guestCredential": {
                "$ref": "#/components/schemas/BaseGuestCredential"
              },
              "shouldRefreshCacheAfterUpdate": {
                "description": "A boolean value that specifies whether an update also refreshes the in-memory cache. When 'false' updates do not refresh the in-memory cache. When 'true' updates refresh the in-memory cache. By default, this value is 'true'. Setting this value to 'false' reduces the time required for updates to complete.",
                "type": "boolean"
              }
            },
            "type": "object"
          }
        ]
      },
      "VmForceFullRequest": {
        "properties": {
          "virtualDiskInfos": {
            "description": "List of virtual disks to be configured to force a full snapshot. The configuration specifies which virtual disks in VMware VM should do forced full snapshots and whether to perform deduplication. If it contains an empty array, a forced full snapshot is requested for all virtual disks in the VMware VM and deduplication is performed by default; otherwise a forced full snapshot is requested for the virtual disks in the array and the shouldDedupe determines whether deduplication is performed. The next backup job checks the configuration and takes full snapshot according to the specification. After the backup job is done, it clears the configuration in order to prevent further full snapshots.",
            "items": {
              "$ref": "#/components/schemas/VmwareVdiskForceFullInfo"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "VmForceFullResponse": {
        "properties": {
          "virtualDiskInfos": {
            "description": "List of objects that provide information about each virtual disk that has requested a forced full snapshot.",
            "items": {
              "$ref": "#/components/schemas/VmwareVdiskForceFullInfo"
            },
            "type": "array"
          },
          "vmId": {
            "description": "VMware virtual machine ID.",
            "type": "string"
          }
        },
        "required": [
          "vmId"
        ],
        "type": "object"
      },
      "VmGuestScriptRunConfig": {
        "properties": {
          "phase": {
            "description": "Run the script configured (if any) for this phase.",
            "enum": [
              "PreBackup",
              "PostSnap",
              "PostBackup"
            ],
            "type": "string"
          }
        },
        "required": [
          "phase"
        ],
        "type": "object"
      },
      "VmPathPoint": {
        "properties": {
          "id": {
            "description": "ID of the object.",
            "type": "string"
          },
          "managedId": {
            "description": "(Deprecated) - See **id**.",
            "type": "string"
          },
          "name": {
            "description": "Name of the object.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "managedId",
          "name"
        ],
        "type": "object"
      },
      "VmSnapshotDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/VmSnapshotSummary"
          },
          {
            "$ref": "#/components/schemas/BaseSnapshotDetail"
          },
          {
            "properties": {
              "snapshotDiskDetails": {
                "items": {
                  "$ref": "#/components/schemas/VmSnapshotDiskDetail"
                },
                "type": "array"
              },
              "snapshotDiskIds": {
                "description": "This field is deprecated, use snapshotDiskDetails instead.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "virtualMachine": {
                "$ref": "#/components/schemas/VirtualMachineSummary"
              },
              "vmwareTagList": {
                "description": "List of vSphere tags assigned to the virtual machine.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "vmxFileContent": {
                "type": "string"
              }
            },
            "required": [
              "snapshotDiskDetails"
            ],
            "type": "object"
          }
        ]
      },
      "VmSnapshotDiskDetail": {
        "properties": {
          "deviceKey": {
            "description": "Unique and reusable key that vSphere uses to identify VMDK files and other devices in the hardware of a virtual machine.",
            "format": "int64",
            "type": "integer"
          },
          "fileName": {
            "type": "string"
          },
          "id": {
            "type": "string"
          },
          "size": {
            "format": "int64",
            "type": "integer"
          },
          "virtualDiskId": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "VmSnapshotSummaries": {
        "description": "Snapshot summaries for the virtual machine.",
        "properties": {
          "vmId": {
            "description": "The ID of the virtual machine.",
            "type": "string"
          },
          "vmSnapshotsSummaries": {
            "description": "A list of VmSnapshotSummary for the virtual machine.",
            "items": {
              "$ref": "#/components/schemas/VmSnapshotSummary"
            },
            "type": "array"
          }
        },
        "required": [
          "vmId",
          "vmSnapshotsSummaries"
        ],
        "type": "object"
      },
      "VmSnapshotSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseSnapshotSummary"
          },
          {
            "properties": {
              "vNicsInfo": {
                "items": {
                  "$ref": "#/components/schemas/VmwareVNicBindingInfo"
                },
                "type": "array"
              },
              "vmName": {
                "type": "string"
              }
            },
            "required": [
              "vmName"
            ],
            "type": "object"
          }
        ]
      },
      "VmSnapshotSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/VmSnapshotSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "VmwareAdaptiveThrottlingSettings": {
        "properties": {
          "cpuUtilizationThreshold": {
            "description": "Threshold virtual machine CPU utilization value that determines whether to postpone a scheduled snapshot of a vSphere virtual machine. Specify the threshold value as a percentage.",
            "format": "int32",
            "type": "integer"
          },
          "datastoreIoLatencyThreshold": {
            "description": "Threshold datastore latency value, measured across all datastores, that determines whether to postpone a scheduled snapshot of a vSphere virtual machine. Specify the threshold value in milliseconds (ms).",
            "format": "int32",
            "type": "integer"
          },
          "ioLatencyThreshold": {
            "description": "Threshold virtual machine latency value that determines whether to postpone a scheduled snapshot of the vSphere virtual machine. Specify the threshold value in milliseconds (ms).",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "VmwareCdpLiveInfo": {
        "properties": {
          "currentTime": {
            "description": "The time on this node. Computed after computing the live CDP info for the virtual machine.",
            "format": "date-time",
            "type": "string"
          },
          "localRecoveryPoint": {
            "description": "The latest time to which this virtual machine can be recovered locally.",
            "format": "date-time",
            "type": "string"
          },
          "remoteRecoveryPoint": {
            "description": "The latest time to which this virtual machine can be recovered on a remote cluster.",
            "format": "date-time",
            "type": "string"
          },
          "vmId": {
            "description": "The ID of the virtual machine that we are getting CDP live fields for.",
            "type": "string"
          }
        },
        "required": [
          "vmId"
        ],
        "type": "object"
      },
      "VmwareCdpStateInfo": {
        "properties": {
          "healthPercentage": {
            "description": "The percentage of healthy time over all CDP-enabled time over the last 24 hours. Range from 0.0 to 100.0 .",
            "format": "double",
            "type": "number"
          },
          "localStatus": {
            "$ref": "#/components/schemas/CdpLocalStatus"
          },
          "replicationStatus": {
            "$ref": "#/components/schemas/CdpReplicationStatus"
          },
          "vmId": {
            "description": "The ID of the virtual machine for which the cluster is retrieving CDP state information.",
            "type": "string"
          }
        },
        "required": [
          "vmId"
        ],
        "type": "object"
      },
      "VmwareHierarchyInfo": {
        "properties": {
          "datastores": {
            "items": {
              "$ref": "#/components/schemas/DataStoreSummary"
            },
            "type": "array"
          },
          "hasChildren": {
            "type": "boolean"
          },
          "id": {
            "type": "string"
          },
          "location": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "objectType": {
            "$ref": "#/components/schemas/VmwareHierarchyObjectType"
          },
          "recoverableTo": {
            "type": "boolean"
          },
          "rootId": {
            "type": "string"
          }
        },
        "required": [
          "datastores",
          "hasChildren",
          "id",
          "location",
          "name",
          "objectType",
          "recoverableTo"
        ],
        "type": "object"
      },
      "VmwareHierarchyInfoListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/VmwareHierarchyInfo"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "VmwareHierarchyObjectType": {
        "description": "Vmware Hierarchy Object Type.",
        "enum": [
          "ComputeCluster",
          "Host",
          "ResourcePool"
        ],
        "type": "string"
      },
      "VmwareHostDatastoreDetail": {
        "properties": {
          "datastores": {
            "items": {
              "$ref": "#/components/schemas/DataStoreSummary"
            },
            "type": "array"
          },
          "hostId": {
            "type": "string"
          },
          "hostName": {
            "type": "string"
          }
        },
        "required": [
          "hostId"
        ],
        "type": "object"
      },
      "VmwareHostDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/VmwareHostUpdate"
          },
          {
            "$ref": "#/components/schemas/VmwareHostSummary"
          },
          {
            "properties": {
              "computeClusterId": {
                "type": "string"
              },
              "datacenter": {
                "$ref": "#/components/schemas/DataCenterSummary"
              },
              "datastores": {
                "items": {
                  "$ref": "#/components/schemas/DataStoreSummary"
                },
                "type": "array"
              },
              "moid": {
                "type": "string"
              },
              "virtualMachines": {
                "items": {
                  "$ref": "#/components/schemas/VirtualMachineSummary"
                },
                "type": "array"
              }
            },
            "type": "object"
          }
        ]
      },
      "VmwareHostSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SlaAssignable"
          },
          {
            "$ref": "#/components/schemas/EffectiveSlaHolder"
          },
          {
            "properties": {
              "computeClusterId": {
                "type": "string"
              },
              "datacenterId": {
                "type": "string"
              },
              "datastores": {
                "items": {
                  "$ref": "#/components/schemas/DataStoreSummary"
                },
                "type": "array"
              },
              "esxiVersion": {
                "description": "API Version of the ESXi Host.",
                "type": "string"
              },
              "ioFilterStatus": {
                "$ref": "#/components/schemas/HostFilterStatus"
              },
              "ioFilterUiStatus": {
                "$ref": "#/components/schemas/HostUiFilterStatus"
              },
              "isInVmc": {
                "type": "boolean"
              }
            },
            "required": [
              "ioFilterStatus"
            ],
            "type": "object"
          }
        ]
      },
      "VmwareHostSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/VmwareHostSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "VmwareHostUpdate": {
        "properties": {
          "configuredSlaDomainId": {
            "description": "ID of the SLA Domain that is configured for this ESXi hypervisor. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.\n",
            "type": "string"
          }
        },
        "type": "object"
      },
      "VmwareNetworkCollection": {
        "description": "A collection of VMware networks.",
        "properties": {
          "networks": {
            "description": "A list of VMware network information.",
            "items": {
              "$ref": "#/components/schemas/VmwareNetworkInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "networks"
        ],
        "type": "object"
      },
      "VmwareNetworkDeviceInfo": {
        "properties": {
          "key": {
            "format": "int32",
            "type": "integer"
          },
          "name": {
            "type": "string"
          }
        },
        "required": [
          "key",
          "name"
        ],
        "type": "object"
      },
      "VmwareNetworkInfo": {
        "properties": {
          "id": {
            "description": "ID of the VMware network.",
            "type": "string"
          },
          "moid": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "networkType": {
            "$ref": "#/components/schemas/VmwareNetworkType"
          }
        },
        "required": [
          "moid",
          "name"
        ],
        "type": "object"
      },
      "VmwareNetworkType": {
        "description": "VMware network type.",
        "enum": [
          "LOCAL_NETWORK",
          "DISTRIBUTED_PORT_GROUP",
          "OPAQUE_NETWORK",
          "OTHER"
        ],
        "type": "string"
      },
      "VmwareRecoverableRange": {
        "properties": {
          "beginTime": {
            "format": "date-time",
            "type": "string"
          },
          "endTime": {
            "format": "date-time",
            "type": "string"
          }
        },
        "type": "object"
      },
      "VmwareRecoverableRangeListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/VmwareRecoverableRange"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "VmwareVNicBindingInfo": {
        "properties": {
          "backingNetworkInfo": {
            "$ref": "#/components/schemas/VmwareNetworkInfo"
          },
          "networkDeviceInfo": {
            "$ref": "#/components/schemas/VmwareNetworkDeviceInfo"
          }
        },
        "required": [
          "backingNetworkInfo",
          "networkDeviceInfo"
        ],
        "type": "object"
      },
      "VmwareVdiskForceFullInfo": {
        "properties": {
          "shouldDedupe": {
            "default": true,
            "description": "Specifies whether deduplication should be enabled for the forced full snapshot of the virtual disk.",
            "type": "boolean"
          },
          "virtualDiskId": {
            "description": "Virtual disk ID within the VMware virtual machine.",
            "type": "string"
          }
        },
        "required": [
          "shouldDedupe",
          "virtualDiskId"
        ],
        "type": "object"
      },
      "VmwareVmMissedRecoverableRanges": {
        "properties": {
          "missedRecoverableRanges": {
            "description": "Missed recoverable ranges for the virtual machine.",
            "items": {
              "$ref": "#/components/schemas/VmwareRecoverableRange"
            },
            "type": "array"
          },
          "vmId": {
            "description": "ID of the virtual machine for which missed recoverable ranges are being retrieved.",
            "type": "string"
          }
        },
        "required": [
          "missedRecoverableRanges",
          "vmId"
        ],
        "type": "object"
      },
      "VmwareVmMountDetailV1": {
        "allOf": [
          {
            "$ref": "#/components/schemas/VmwareVmMountSummaryV1"
          },
          {
            "properties": {
              "powerStatus": {
                "description": "The power status of the mounted VM(ON,OFF,SLEEP etc.).",
                "type": "string"
              }
            },
            "type": "object"
          }
        ]
      },
      "VmwareVmMountSummaryV1": {
        "properties": {
          "attachingDiskCount": {
            "description": "An integer value that identifies how many disks are attached.",
            "format": "int32",
            "type": "integer"
          },
          "createDatastoreOnlyMount": {
            "description": "This boolean value determines whether or not the mount is created as a datastore only. When 'true,' the mount is created with datastore and not the associated virtual machine. When 'false,' the mount is created with both the datastore and the associated virtual machine.",
            "type": "boolean"
          },
          "datastoreName": {
            "description": "The name of the datastore that contains the mounted VMDK.",
            "type": "string"
          },
          "datastoreReady": {
            "description": "A boolean value that specifies whether the datastore is ready. When 'true,' the datastore is ready. When 'false,' the datastore is not ready.",
            "type": "boolean"
          },
          "hasAttachingDisk": {
            "description": "A Boolean value that determines whether this job is an attaching disk mount job. When 'true,' this is an attaching disk mount job. When 'false,' this is not an attaching disk mount job.",
            "type": "boolean"
          },
          "hostId": {
            "type": "string"
          },
          "id": {
            "type": "string"
          },
          "isReady": {
            "type": "boolean"
          },
          "mountRequestId": {
            "type": "string"
          },
          "mountTimestamp": {
            "description": "Gives the timestamp at which the mount was created.",
            "format": "date-time",
            "type": "string"
          },
          "mountedVmId": {
            "type": "string"
          },
          "snapshotDate": {
            "format": "date-time",
            "type": "string"
          },
          "unmountRequestId": {
            "type": "string"
          },
          "vmId": {
            "type": "string"
          }
        },
        "required": [
          "id",
          "isReady",
          "snapshotDate",
          "vmId"
        ],
        "type": "object"
      },
      "VmwareVmMountSummaryV1ListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/VmwareVmMountSummaryV1"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "VmwareVmRecoverableRanges": {
        "properties": {
          "recoverableRanges": {
            "description": "The recoverable ranges for the virtual machine.",
            "items": {
              "$ref": "#/components/schemas/VmwareRecoverableRange"
            },
            "type": "array"
          },
          "vmId": {
            "description": "The ID of the virtual machine for which to retrieve recoverable ranges.",
            "type": "string"
          }
        },
        "required": [
          "recoverableRanges",
          "vmId"
        ],
        "type": "object"
      },
      "VolumeGroupDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/VolumeGroupSummary"
          },
          {
            "$ref": "#/components/schemas/BlackoutWindowResponseInfo"
          },
          {
            "properties": {
              "configuredSlaDomainId": {
                "description": "The ID of the SLA Domain policy to assign to the Volume Group.",
                "type": "string"
              },
              "isPaused": {
                "description": "Indicates whether backup, archival, and replication are paused for this Volume Group.",
                "type": "boolean"
              },
              "pendingSlaDomain": {
                "$ref": "#/components/schemas/ManagedObjectPendingSlaInfo"
              },
              "volumes": {
                "description": "Configuration details for the volumes in the Volume Group.",
                "items": {
                  "$ref": "#/components/schemas/HostVolumeSummary"
                },
                "type": "array"
              }
            },
            "required": [
              "configuredSlaDomainId",
              "isPaused",
              "volumes"
            ],
            "type": "object"
          }
        ]
      },
      "VolumeGroupForceFullRequest": {
        "properties": {
          "volumeInfos": {
            "description": "Configuration for forcing a full snapshot for the listed volumes in the request. The configuration specifies which volumes in a Volume Group should get forced full snapshots, and whether to perform deduplication. If the configuration is missing, no forced full snapshot is requested. If the configuration contains an empty array, a forced full snapshot is requested for all volumes in the Volume Group and deduplication is performed by default. If the configuration array contains specific volumes, a forced full snapshot is requested for these volumes only. The shouldDedupe flag determines whether deduplication is performed. If a forced full snapshot is requested, the next backup job checks the configuration and takes the full snapshot according to the specification. After the full snapshot is taken, the backup job clears the configuration to prevent additional full snapshots from being taken.",
            "items": {
              "$ref": "#/components/schemas/ForceFullVolumeInfo"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "VolumeGroupForceFullResponse": {
        "properties": {
          "volumeGroupId": {
            "description": "The ID of the Volume group.",
            "type": "string"
          },
          "volumeInfos": {
            "description": "Configuration for each volume that has requested a forced full snapshot. If the configuration is absent, that means either a forced full snapshot has not been requested for the Volume Group, or a backup job has taken the requested full snapshot and cleared the configuration.",
            "items": {
              "$ref": "#/components/schemas/ForceFullVolumeInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "volumeGroupId"
        ],
        "type": "object"
      },
      "VolumeGroupListSortAttribute": {
        "description": "Attributes that are available to use when sorting query results for Volume Groups.",
        "enum": [
          "name",
          "effectiveSlaDomainName"
        ],
        "type": "string"
      },
      "VolumeGroupMountListSortAttribute": {
        "description": "Attributes that are available to use when sorting query results for Volume Group snapshot mounts.",
        "enum": [
          "name",
          "sourceHostName",
          "snapshotDate",
          "mountedDate"
        ],
        "type": "string"
      },
      "VolumeGroupMountSummary": {
        "properties": {
          "canUnmount": {
            "description": "Indicates if the logged-in user has the authority to remove the specified mount.",
            "type": "boolean"
          },
          "id": {
            "description": "The unique ID of the mount.",
            "type": "string"
          },
          "isReady": {
            "description": "Specifies whether the volume mount operation has successfully completed and is ready to use.",
            "type": "boolean"
          },
          "mountRequestId": {
            "description": "The ID of the job instance that initiated the request for the specified mount.",
            "type": "string"
          },
          "mountedDate": {
            "description": "The UTC timestamp at which the mount was created.",
            "format": "date-time",
            "type": "string"
          },
          "mountedVolumes": {
            "description": "Configuration details for each of the mounted Volumes in the Volume Group.",
            "items": {
              "$ref": "#/components/schemas/VolumeMountInfo"
            },
            "type": "array"
          },
          "name": {
            "description": "The name of the Volume Group.",
            "type": "string"
          },
          "restoreScriptSmbPath": {
            "description": "The link to the script that can perform bare-metal recovery for the mounted snapshot.",
            "type": "string"
          },
          "snapshotDate": {
            "description": "The UTC timestamp at which the snapshot was originally taken.",
            "format": "date-time",
            "type": "string"
          },
          "snapshotSourceVersion": {
            "$ref": "#/components/schemas/VolumeGroupReleaseVersion"
          },
          "sourceHostId": {
            "description": "The ID of the Host on which the snapshot was originally taken.",
            "type": "string"
          },
          "sourceHostName": {
            "description": "The name of the Host on which the snapshot was originally taken.",
            "type": "string"
          },
          "sourceVolumeGroupId": {
            "description": "The ID of the Volume Group from which this snapshot was created.",
            "type": "string"
          },
          "targetHostId": {
            "description": "The ID of the host where the volumes are mounted.",
            "type": "string"
          },
          "targetHostName": {
            "description": "The name of the host where the volumes are mounted.",
            "type": "string"
          },
          "unmountRequestId": {
            "description": "The ID of the job instance that initiated the request to remove the specified mount.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "isReady",
          "mountedDate",
          "mountedVolumes",
          "name",
          "snapshotDate",
          "snapshotSourceVersion",
          "sourceHostId",
          "sourceHostName",
          "sourceVolumeGroupId"
        ],
        "type": "object"
      },
      "VolumeGroupMountSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/VolumeGroupMountSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "VolumeGroupOnDemandSnapshotConfig": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseOnDemandSnapshotConfig"
          },
          {
            "properties": {
              "volumeIdsIncludedInSnapshot": {
                "description": "The unique ID of each volume included in the Volume Group snapshot.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            },
            "type": "object"
          }
        ]
      },
      "VolumeGroupPatch": {
        "properties": {
          "configuredSlaDomainId": {
            "description": "The ID of the SLA Domain policy to assign to the Volume Group.",
            "type": "string"
          },
          "forceFull": {
            "description": "Determines whether the next snapshot of the Volume Group is a full. After the snapshot has completed, this parameter will be reset to the default false value.",
            "type": "boolean"
          },
          "isPaused": {
            "description": "Indicates whether backup, archival, and replicated is paused for this Volume Group.",
            "type": "boolean"
          },
          "volumeIdsIncludedInSnapshots": {
            "description": "The unique ID of each volume included in the Volume Group.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "VolumeGroupReleaseVersion": {
        "description": "Rubrik release version that supports volume group snappable.",
        "enum": [
          "WithLayoutInfo",
          "WithoutLayoutInfo"
        ],
        "type": "string"
      },
      "VolumeGroupRestoreVolumeSpec": {
        "properties": {
          "targetVolumePath": {
            "description": "Path of the target volume for the restore operation.",
            "type": "string"
          },
          "volumeId": {
            "description": "ID of volume in snapshot to restore.",
            "type": "string"
          }
        },
        "required": [
          "targetVolumePath",
          "volumeId"
        ],
        "type": "object"
      },
      "VolumeGroupRestoreVolumesConfig": {
        "properties": {
          "restoreSpec": {
            "description": "Array of volume ID and target volume path pairs.",
            "items": {
              "$ref": "#/components/schemas/VolumeGroupRestoreVolumeSpec"
            },
            "type": "array"
          },
          "targetHostId": {
            "description": "ID of the host where this restore operation restores volumes.",
            "type": "string"
          }
        },
        "required": [
          "restoreSpec",
          "targetHostId"
        ],
        "type": "object"
      },
      "VolumeGroupSnapshotDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/VolumeGroupSnapshotSummary"
          }
        ]
      },
      "VolumeGroupSnapshotSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseSnapshotSummary"
          },
          {
            "properties": {
              "fileSizeInBytes": {
                "description": "The logical size of the Volume Group snapshot in bytes.",
                "format": "int64",
                "type": "integer"
              },
              "includedVolumes": {
                "description": "Configuration details of the volume(s) included in the snapshot.",
                "items": {
                  "$ref": "#/components/schemas/VolumeGroupSnapshotVolumeSummary"
                },
                "type": "array"
              },
              "name": {
                "description": "A human-readable name of the mount points included in the snapshot.",
                "type": "string"
              },
              "usedFastVhdx": {
                "description": "Specifies whether the snapshot was taken using the fast VHDX builder, which became available in the Rubrik CDM 5.1 release.",
                "type": "boolean"
              },
              "volumeGroupId": {
                "description": "The unique ID of the Volume Group that was snapshoted.",
                "type": "string"
              }
            },
            "required": [
              "includedVolumes",
              "name",
              "volumeGroupId"
            ],
            "type": "object"
          }
        ]
      },
      "VolumeGroupSnapshotSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/VolumeGroupSnapshotSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "VolumeGroupSnapshotVolumeSummary": {
        "properties": {
          "fileSystemType": {
            "$ref": "#/components/schemas/FileSystemType"
          },
          "id": {
            "description": "The unique ID of the snapshot volume summary.",
            "type": "string"
          },
          "mountPoints": {
            "description": "The mount points of the volume on the host.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "size": {
            "description": "The size of the volume in bytes.",
            "format": "int64",
            "type": "integer"
          }
        },
        "required": [
          "fileSystemType",
          "id",
          "mountPoints",
          "size"
        ],
        "type": "object"
      },
      "VolumeGroupSummary": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Snappable"
          },
          {
            "properties": {
              "forceFull": {
                "description": "Specifies whether the Volume Group is set to take a full snapshot for the next backup.",
                "type": "boolean"
              },
              "hostId": {
                "description": "The unique ID of the host that contains the Volume Group.",
                "type": "string"
              },
              "hostname": {
                "description": "The name of the host that contains the Volume Group.",
                "type": "string"
              },
              "id": {
                "description": "The unique ID of the Volume Group.",
                "type": "string"
              },
              "isRelic": {
                "description": "Specifies whether the Volume Group is accessible on the Rubrik cluster.",
                "type": "boolean"
              },
              "name": {
                "description": "The name of the Volume Group.",
                "type": "string"
              },
              "needsMigration": {
                "description": "Specifies whether the Volume Group needs to be migrated in order to use the fast VHDX builder. This flag is set only when the Volume Group's last backup job failed due to an error during data fetch, and the backup job did not use the fast VHDX builder.",
                "type": "boolean"
              }
            },
            "required": [
              "id",
              "isRelic",
              "name"
            ],
            "type": "object"
          }
        ]
      },
      "VolumeGroupSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/VolumeGroupSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "VolumeMountInfo": {
        "properties": {
          "fileSystemType": {
            "$ref": "#/components/schemas/FileSystemType"
          },
          "hostMountedPath": {
            "description": "The mount path of volume on the new host.",
            "type": "string"
          },
          "id": {
            "description": "The unique ID of the mount.",
            "type": "string"
          },
          "originalMountPoints": {
            "description": "The source host mount points of the specified volume.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "size": {
            "description": "The size of the volume in bytes.",
            "format": "int64",
            "type": "integer"
          },
          "smbPath": {
            "description": "The SMB path to the VHD file that contains the snapshot volume. This path is available when the mount is ready.",
            "type": "string"
          }
        },
        "required": [
          "fileSystemType",
          "id",
          "originalMountPoints",
          "size"
        ],
        "type": "object"
      },
      "WebServerCertificatePayload": {
        "properties": {
          "certificateId": {
            "description": "ID assigned to the imported certificate object.",
            "type": "string"
          }
        },
        "required": [
          "certificateId"
        ],
        "type": "object"
      },
      "WebServerCertificateSummary": {
        "properties": {
          "cert": {
            "$ref": "#/components/schemas/CertificateSummary"
          },
          "webServerConfiguredWithCASignedCertificate": {
            "description": "A Boolean value that indicates if the web server is configured to use a certificate signed by an external CA.",
            "type": "boolean"
          }
        },
        "required": [
          "webServerConfiguredWithCASignedCertificate"
        ],
        "type": "object"
      },
      "WeeklyConfig": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FrequencyConfig"
          },
          {
            "properties": {
              "dayOfWeek": {
                "$ref": "#/components/schemas/SlaDayOfWeek"
              }
            },
            "required": [
              "dayOfWeek"
            ],
            "type": "object"
          }
        ]
      },
      "WindowsClusterDetail": {
        "allOf": [
          {
            "$ref": "#/components/schemas/WindowsClusterSummary"
          },
          {
            "properties": {
              "naturalId": {
                "description": "Obtained from ClusterInstanceID under the registry key HKLM\\Cluster.",
                "type": "string"
              }
            },
            "required": [
              "naturalId"
            ],
            "type": "object"
          }
        ]
      },
      "WindowsClusterSummary": {
        "properties": {
          "fqdn": {
            "description": "Fully qualified domain name of this cluster.",
            "type": "string"
          },
          "hostIds": {
            "description": "IDs of the hosts in this cluster.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "id": {
            "type": "string"
          },
          "isAgentless": {
            "description": "Indicates whether the Rubrik Backup Service is installed on hosts in a Windows cluster. The value is true when all hosts in the cluster do not have the Rubrik Backup Service installed. The value is false when one or more of the hosts in the cluster have the Rubrik Backup Service installed.",
            "type": "boolean"
          },
          "name": {
            "type": "string"
          },
          "primaryClusterId": {
            "type": "string"
          }
        },
        "required": [
          "fqdn",
          "hostIds",
          "id",
          "isAgentless",
          "name",
          "primaryClusterId"
        ],
        "type": "object"
      },
      "WindowsClusterSummaryListResponse": {
        "properties": {
          "data": {
            "description": "List of matching objects.",
            "items": {
              "$ref": "#/components/schemas/WindowsClusterSummary"
            },
            "type": "array"
          },
          "hasMore": {
            "description": "If there is more.",
            "type": "boolean"
          },
          "total": {
            "description": "Total list responses.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "YearlyConfig": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FrequencyConfig"
          },
          {
            "properties": {
              "dayOfYear": {
                "$ref": "#/components/schemas/SlaDayOfYear"
              },
              "yearStartMonth": {
                "$ref": "#/components/schemas/SlaMonth"
              }
            },
            "required": [
              "dayOfYear",
              "yearStartMonth"
            ],
            "type": "object"
          }
        ]
      }
    },
    "securitySchemes": {
      "BasicAuth": {
        "scheme": "basic",
        "type": "http"
      },
      "Bearer": {
        "in": "header",
        "name": "Authorization",
        "type": "apiKey"
      }
    }
  }
}